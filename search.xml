<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[echarts源码解读《五》：echarts源码之Series分析]]></title>
    <url>%2F2019%2F06%2F06%2Fecharts-5%2F</url>
    <content type="text"><![CDATA[在分析完echarts Component渲染过程之后，我们便开始进行echarts Series渲染过程的分析。 希望和小伙伴们一起进步呀！！加油！！ 前言在这篇博文中我们将探讨line（折线图）、bar（柱状图）、pie（饼图）等Series。 用户通过传递option对象来设置相应的Series。 在这部分中echarts采用了Model以及View的架构来管理Series： Model：model/Series.js 管理Series数据。 View：view/Charts.js 负责渲染Chart视图，定义了init、render、highlight、downplay、remove等方法 Model层model/Series.js。Series通过extend方法扩展自Component Model，重写了init等方法，并定义了getData、setData、getSource、getBaseAxis等方法。 View层view/Charts.js。Charts中定义了init、render、highlight、downplay、remove等方法。 Line 折线图LineSeriesLineSeries通过extend方法扩展自Series Model，重写了defaultOption属性以及getInitialData方法。 LineViewLineView通过extend方法扩展自Chart View，重写了init、render、highlight及downplay等方法，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061init: function () &#123; var lineGroup = new graphic.Group(); // 使用SymbolDraw绘制Symbol var symbolDraw = new SymbolDraw(); this.group.add(symbolDraw.group); this._symbolDraw = symbolDraw; this._lineGroup = lineGroup;&#125;,render: function (seriesModel, ecModel, api) &#123; ... if ( !(polyline &amp;&amp; prevCoordSys.type === coordSys.type &amp;&amp; step === this._step) ) &#123; // 折线图 // symbolDraw绘制symbol showSymbol &amp;&amp; symbolDraw.updateData(data, &#123; isIgnore: isIgnoreFunc, // createClipShape创建方法分为极坐标createPolarClipShape以及直角坐标createGridClipShape // createPolarClipShape：通过graphic.Sector创建Clip区域 // createGridClipShape：通过graphic.Rect创建Clip区域 clipShape: createClipShape(coordSys, false, true, seriesModel) &#125;); ... // 通过zrender Polyline绘制折线图 polyline = this._newPolyline(points, coordSys, hasAnimation); if (isAreaChart) &#123; // 通过zrender Polygon绘制折线区域 polygon = this._newPolygon( points, stackedOnPoints, coordSys, hasAnimation ); &#125; lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel)); &#125; else &#123; if (isAreaChart &amp;&amp; !polygon) &#123; polygon = this._newPolygon( points, stackedOnPoints, coordSys, hasAnimation ); &#125; else if (polygon &amp;&amp; !isAreaChart) &#123; // If areaStyle is removed lineGroup.remove(polygon); polygon = this._polygon = null; &#125; // Update clipPath lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend // because points are not changed showSymbol &amp;&amp; symbolDraw.updateData(data, &#123; isIgnore: isIgnoreFunc, clipShape: createClipShape(coordSys, false, true, seriesModel) &#125;); ... &#125; ...&#125; Bar 柱状图BaseBarSeriesBaseBarSeries通过extend方法扩展自Series Model，重写了defaultOption属性，以及getMarkerPosition和getInitialData方法。 BarSeriesBarSeries通过extend方法扩展自BaseBarSeries，重写了getProgressive等方法。 BarViewBarView通过extendChartView方法扩展自Chart View，重写了render等方法，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667render: function (seriesModel, ecModel, api) &#123; // 更新绘制模式 this._updateDrawMode(seriesModel); var coordinateSystemType = seriesModel.get('coordinateSystem'); // 支持笛卡尔坐标系以及极坐标系 if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar' ) &#123; // 绘制 this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api); &#125; else if (__DEV__) &#123; console.warn('Only cartesian2d and polar supported for bar.'); &#125; return this.group;&#125;_renderNormal: function (seriesModel, ecModel, api) &#123; ... data.diff(oldData) .add(function (dataIndex) &#123; if (!data.hasValue(dataIndex)) &#123; return; &#125; var itemModel = data.getItemModel(dataIndex); // 返回layout信息 var layout = getLayout[coord.type](data, dataIndex, itemModel); // 创建元素 // 通过graphic.Rect（笛卡尔坐标系）/ graphic.Sector（极坐标系）绘制柱形图 var el = elementCreator[coord.type]( data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel ); data.setItemGraphicEl(dataIndex, el); group.add(el); updateStyle( el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar' ); &#125;) .update(function (newIndex, oldIndex) &#123; // 更新元素 var el = oldData.getItemGraphicEl(oldIndex); ... if (el) &#123; graphic.updateProps(el, &#123;shape: layout&#125;, animationModel, newIndex); &#125; else &#123; el = elementCreator[coord.type]( data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true ); &#125; ... &#125;) .remove(function (dataIndex) &#123; var el = oldData.getItemGraphicEl(dataIndex); if (coord.type === 'cartesian2d') &#123; el &amp;&amp; removeRect(dataIndex, animationModel, el); &#125; else &#123; el &amp;&amp; removeSector(dataIndex, animationModel, el); &#125; &#125;) .execute(); this._data = data;&#125; Pie 饼图Pie.jspie.js中注册了pieToggleSelect、pieSelect、pieUnSelect等Action PieSeriesPieSeries通过extendSeriesModel方法扩展自Series Model，重写了defaultOption属性，以及init、mergeOption、getInitialData等方法。 PieViewPieView通过extend方法扩展自Chart View，重写了init、render等方法，主要实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546render: function (seriesModel, ecModel, api, payload) &#123; ... var onSectorClick = zrUtil.curry( updateDataSelected, this.uid, seriesModel, hasAnimation, api ); var selectedMode = seriesModel.get('selectedMode'); data.diff(oldData) .add(function (idx) &#123; // 添加 // PiePiece通过graphic.Sector、graphic.Polyline及graphic.Text绘制饼图的每一块扇形 // 并绑定了emphasis、mouseover、mouseout等处理器 var piePiece = new PiePiece(data, idx); // Default expansion animation if (isFirstRender &amp;&amp; animationType !== 'scale') &#123; piePiece.eachChild(function (child) &#123; child.stopAnimation(true); &#125;); &#125; // 绑定点击事件处理器 selectedMode &amp;&amp; piePiece.on('click', onSectorClick); data.setItemGraphicEl(idx, piePiece); group.add(piePiece); &#125;) .update(function (newIdx, oldIdx) &#123; // 更新 var piePiece = oldData.getItemGraphicEl(oldIdx); piePiece.updateData(data, newIdx); piePiece.off('click'); selectedMode &amp;&amp; piePiece.on('click', onSectorClick); group.add(piePiece); data.setItemGraphicEl(newIdx, piePiece); &#125;) .remove(function (idx) &#123; var piePiece = oldData.getItemGraphicEl(idx); group.remove(piePiece); &#125;) .execute(); ... this._data = data;&#125; PieLayoutPieLayout为饼图的布局文件，通过setItemLayout方法来设置每个Sector绘制的属性信息，包括angle、startAngle、endAngle、cx、cy等。 LabelLayoutLabelLayout用于设置饼图中每个Sector的label属性信息，包括x、y、position、height等。 Scatter 散点图ScatterSeriesScatterSeries通过extend方法扩展自Series Model，重写了defaultOption属性以及getInitialData等方法。 ScatterViewScatterView通过extendChartView方法扩展自Chart View，重写了render、updateTransform等方法，主要实现代码如下： 1234567891011121314151617181920212223242526render: function (seriesModel, ecModel, api) &#123; var data = seriesModel.getData(); // 绘制散点图symbol // 通过SymbolDraw/LargeSymbolDraw绘制 var symbolDraw = this._updateSymbolDraw(data, seriesModel); symbolDraw.updateData(data); this._finished = true;&#125;_updateSymbolDraw: function (data, seriesModel) &#123; var symbolDraw = this._symbolDraw; var pipelineContext = seriesModel.pipelineContext; var isLargeDraw = pipelineContext.large; if (!symbolDraw || isLargeDraw !== this._isLargeDraw) &#123; symbolDraw &amp;&amp; symbolDraw.remove(); symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw(); this._isLargeDraw = isLargeDraw; this.group.removeAll(); &#125; this.group.add(symbolDraw.group); return symbolDraw;&#125; EffectScatter 带涟漪效果的散点图EffectScatterSeriesEffectScatterSeries通过extend方法扩展自Series Model，重写了defaultOption属性以及getInitialData方法。 EffectScatterViewEffectScatterView通过extendChartView方法扩展自Chart View，重写了init、render等方法，主要实现如下： 1234567891011121314151617181920212223242526272829303132333435render: function (seriesModel, ecModel, api) &#123; var data = seriesModel.getData(); // 通过SymbolDraw绘制symbol var effectSymbolDraw = this._symbolDraw; // SymbolCtr为EffectSymbol对象实例 effectSymbolDraw.updateData(data); this.group.add(effectSymbolDraw.group);&#125;effectSymbolProto.updateData = function (data, idx) &#123; ... var effectCfg = &#123;&#125;; effectCfg.showEffectOn = seriesModel.get('showEffectOn'); effectCfg.rippleScale = itemModel.get('rippleEffect.scale'); effectCfg.brushType = itemModel.get('rippleEffect.brushType'); effectCfg.period = itemModel.get('rippleEffect.period') * 1000; effectCfg.effectOffset = idx / data.count(); effectCfg.z = itemModel.getShallow('z') || 0; effectCfg.zlevel = itemModel.getShallow('zlevel') || 0; effectCfg.symbolType = symbolType; effectCfg.color = color; this.off('mouseover').off('mouseout').off('emphasis').off('normal'); // 设置或更新effectScatter 动画 // 通过util中的crateSymbol创建symbol以及scale缩放来实现涟漪效果 if (effectCfg.showEffectOn === 'render') &#123; this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg); this._effectCfg = effectCfg; &#125; ... this._effectCfg = effectCfg;&#125; Radar 雷达图RadarSeriesRadarSeries通过extend方法扩展自Series Model，重写了defaultOption属性以及init、getInitialData、formatTooltip方法。 RadarViewRadarView通过extendChartView方法扩展自Chart View，重写了render方法，主要实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263render: function (seriesModel, ecModel, api) &#123; ... data.diff(oldData) .add(function (idx) &#123; var points = data.getItemLayout(idx); if (!points) &#123; return; &#125; var polygon = new graphic.Polygon(); var polyline = new graphic.Polyline(); var target = &#123; shape: &#123; points: points &#125; &#125;; polygon.shape.points = getInitialPoints(points); polyline.shape.points = getInitialPoints(points); graphic.initProps(polygon, target, seriesModel, idx); graphic.initProps(polyline, target, seriesModel, idx); var itemGroup = new graphic.Group(); var symbolGroup = new graphic.Group(); itemGroup.add(polyline); itemGroup.add(polygon); itemGroup.add(symbolGroup); // 更新symbol // 通过symbolUtil.createSymbol创建symbol updateSymbols( polyline.shape.points, points, symbolGroup, data, idx, true ); data.setItemGraphicEl(idx, itemGroup); &#125;) .update(function (newIdx, oldIdx) &#123; var itemGroup = oldData.getItemGraphicEl(oldIdx); var polyline = itemGroup.childAt(0); var polygon = itemGroup.childAt(1); var symbolGroup = itemGroup.childAt(2); var target = &#123; shape: &#123; points: data.getItemLayout(newIdx) &#125; &#125;; if (!target.shape.points) &#123; return; &#125; updateSymbols( polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false ); graphic.updateProps(polyline, target, seriesModel); graphic.updateProps(polygon, target, seriesModel); data.setItemGraphicEl(newIdx, itemGroup); &#125;) .remove(function (idx) &#123; group.remove(oldData.getItemGraphicEl(idx)); &#125;) .execute(); ... this._data = data;&#125; RadarLayoutRadarLayout主要用于处理data数据，返回坐标信息。 Tree 树图TreeActionTreeAction注册了treeRoam及treeExpandAndCollapse等Action。 TreeSeriesTreeSeries通过extend方法扩展自Series Model，重写了defaultOption属性以及getInitialData、getOrient、setZoom、setCenter、formatTooltip等方法。 TreeLayoutTreeLayout处理data数据，返回layout属性信息。 TreeViewTreeView通过extendChartView方法扩展自Chart View，重写了init、render等方法，主要实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364render: function (seriesModel, ecModel, api, payload) &#123; ... // 更新坐标系以及控制器 this._updateViewCoordSys(seriesModel); this._updateController(seriesModel, ecModel, api); var oldData = this._data; var seriesScope = &#123; expandAndCollapse: seriesModel.get('expandAndCollapse'), layout: layout, orient: seriesModel.getOrient(), curvature: seriesModel.get('lineStyle.curveness'), symbolRotate: seriesModel.get('symbolRotate'), symbolOffset: seriesModel.get('symbolOffset'), hoverAnimation: seriesModel.get('hoverAnimation'), useNameLabel: true, fadeIn: true &#125;; data.diff(oldData) .add(function (newIdx) &#123; if (symbolNeedsDraw(data, newIdx)) &#123; // 创建节点以及连线 // 通过SymbolCtr来绘制symbol // 通过graphic.BezierCurve来绘制节点间的连线 updateNode(data, newIdx, null, group, seriesModel, seriesScope); &#125; &#125;) .update(function (newIdx, oldIdx) &#123; var symbolEl = oldData.getItemGraphicEl(oldIdx); if (!symbolNeedsDraw(data, newIdx)) &#123; symbolEl &amp;&amp; removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope); return; &#125; // 更新 updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope); &#125;) .remove(function (oldIdx) &#123; var symbolEl = oldData.getItemGraphicEl(oldIdx); if (symbolEl) &#123; removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope); &#125; &#125;) .execute(); this._nodeScaleRatio = seriesModel.get('nodeScaleRatio'); this._updateNodeAndLinkScale(seriesModel); // 绑定节点click事件处理器，实现节点展开/收起效果 if (seriesScope.expandAndCollapse === true) &#123; data.eachItemGraphicEl(function (el, dataIndex) &#123; el.off('click').on('click', function () &#123; api.dispatchAction(&#123; type: 'treeExpandAndCollapse', seriesId: seriesModel.id, dataIndex: dataIndex &#125;); &#125;); &#125;); &#125; this._data = data;&#125; TreeMap 面积树状图TreemapActionTreemapAction注册了treemapZoomToNode、treemapRender、treemapMove、treemapRootToNode等Action。 TreemapSeriesTreemapSeries通过extend方法扩展自Series Model，重写了defaultOption属性以及getInitialData、formatTooltip等方法。 TreemapViewTreemapView通过extendChartView方法扩展自Chart View，重写了init、render等方法，主要实现如下： 1234567891011121314151617181920212223242526272829303132333435render: function (seriesModel, ecModel, api, payload) &#123; ... var renderResult = this._doRender(containerGroup, seriesModel, reRoot); ( !isInit &amp;&amp; ( !payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode' ) ) ...&#125;_doRender: function (containerGroup, seriesModel, reRoot) &#123; var thisTree = seriesModel.getData().tree; var oldTree = this._oldTree; var lastsForAnimation = createStorage(); var thisStorage = createStorage(); var oldStorage = this._storage; var willInvisibleEls = []; // renderNode创建Node // 通过graphic.Rect绘制 var doRenderNode = zrUtil.curry( renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls ); ... return &#123; lastsForAnimation: lastsForAnimation, willDeleteEls: willDeleteEls, renderFinally: renderFinally &#125;; ...&#125;]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts源码解读《四》：echarts源码之Component分析]]></title>
    <url>%2F2019%2F05%2F23%2Fecharts-4%2F</url>
    <content type="text"><![CDATA[在本篇博文中，我们将继续Component源码解读，我将主要介绍各Component的渲染过程以及其使用的zrender graphic。希望和小伙伴们一起进步呀！！加油！！ 前言echarts对Component的定义呢，可以认为是除Series外的其他配置项，在这篇博文中我们将探讨datazoom（区域缩放）、visualMap（视图映射）、tooltip（提示框组件）、toolbox（工具栏）、brush（区域选择组件）、timeline（时间轴）、graphic（原生图形组件）、dataset（数据集）、marker（包括markPoint（图标标注）、markLine（图表标线）、markArea（图表标域））这些Component。 用户通过传递option对象来设置相应的Component。 区域缩放 DataZoomdataZoom分为inside和slider两种类型 公共文件DataZoomModelDataZoomModel通过extendComponentModel扩展自Component Model，重写了defaultOption属性以及init、mergeOption等方法。 DataZoomViewDataZoomView通过extend扩展自Component View，重写了render方法并定义了getTargetCoordInfo方法。 DataZoomActionDataZoomAction中注册了dataZoom action SliderSliderZoomModelSliderZoomModel通过extend扩展自DataZoomModel，重写了defaultOption属性 SliderZoomViewSliderZoomView通过extend扩展自DataZoomView，重写了render、remove、dispose等方法，主要实现代码如下： 1234567891011121314151617181920212223242526272829303132333435render: function (dataZoomModel, ecModel, api, payload) &#123; // 调用DataZoomView中的render方法 SliderZoomView.superApply(this, 'render', arguments); ... if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) &#123; // 绘制 this._buildView(); &#125; // 更新 this._updateView();&#125;_buildView: function () &#123; var thisGroup = this.group; thisGroup.removeAll(); this._resetLocation(); this._resetInterval(); var barGroup = this._displayables.barGroup = new graphic.Group(); // 绘制背景，通过graphic.Rect绘制背景，包括可视层以及Click panel this._renderBackground(); // 绘制handle，通过graphic.Rect绘制选择的区域，并绑定拖拽相关以及mouseover、mouseout等事件处理器 // 通过graphic.Rect绘制Frame border // 通过graphic.createIcon创建handler 图标，并绑定拖拽相关以及mouseover、mouseout等事件处理器 // 通过graphic.Text绘制handle中的label数据 this._renderHandle(); // 通过graphic.Polyline及graphic.Polygon绘制出datazoom下的数据缩略图 this._renderDataShadow(); thisGroup.add(barGroup); this._positionGroup();&#125; InsideInsideZoomModelInsideZoomModel通过extend扩展自DataZoomModel，重写了defaultOption属性。 InsideZoomViewInsideZoomView通过extend扩展自DataZoomView，重写了init、render、dispose等方法，主要实现代码如下： 12345678910111213141516171819render: function (dataZoomModel, ecModel, api, payload) &#123; // 调用DataZoomView中的render方法 InsideZoomView.superApply(this, 'render', arguments); this._range = dataZoomModel.getPercentRange(); // Reset controllers. zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) &#123; ... zrUtil.each(coordInfoList, function (coordInfo) &#123; var coordModel = coordInfo.model; var getRange = &#123;&#125;; // 绑定pan、zoom、scrollMove事件处理器，roamHandlers中定义了相关类型的事件处理函数 zrUtil.each(['pan', 'zoom', 'scrollMove'], function (eventName) &#123; getRange[eventName] = bind(roamHandlers[eventName], this, coordInfo, coordSysName); &#125;, this); ... &#125;, this); &#125;, this);&#125; 视图映射 VisualMapVisualMap分为continuous连续型及piecewise分段型两个类型 公共文件VisualMapActionVisualMapAction中注册了selectDataRange action VisualMapModelVisualMapModel通过extendComponentModel方法扩展自Component Model，重写了defaultOption属性以及init、optionUpdated等方法，并定义了resetVisual、formatValueText等方法。 VisualMapViewVisualMapView通过extendComponentView方法扩展自Component View，重写了init、render等方法，定义了renderBackground方法，主要代码为： 1234567891011121314151617181920212223242526render: function (visualMapModel, ecModel, api, payload) &#123; ... // 调用子类doRender方法 this.doRender.apply(this, arguments);&#125;renderBackground: function (group) &#123; var visualMapModel = this.visualMapModel; var padding = formatUtil.normalizeCssArray(visualMapModel.get('padding') || 0); var rect = group.getBoundingRect(); // 通过graphic.Rect渲染visualMap背景 group.add(new graphic.Rect(&#123; z2: -1, // Lay background rect on the lowest layer. silent: true, shape: &#123; x: rect.x - padding[3], y: rect.y - padding[0], width: rect.width + padding[3] + padding[1], height: rect.height + padding[0] + padding[2] &#125;, style: &#123; fill: visualMapModel.get('backgroundColor'), stroke: visualMapModel.get('borderColor'), lineWidth: visualMapModel.get('borderWidth') &#125; &#125;));&#125; ContinuousContinuousModelContinuousModel通过extend方法扩展自VisualMapModel，重写了defaultOption属性以及optionUpdated、resetItemSize等方法，并定义了completeVisualOption、setSelected、getSelected、getValueState等方法。 ContinuousViewContinuousView通过extend方法扩展自VisualMapView，重写了init方法并定义了doRender方法，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940doRender: function (visualMapModel, ecModel, api, payload) &#123; if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) &#123; this._buildView(); &#125;&#125;_buildView: function () &#123; this.group.removeAll(); var visualMapModel = this.visualMapModel; var thisGroup = this.group; this._orient = visualMapModel.get('orient'); this._useHandle = visualMapModel.get('calculable'); this._resetInterval(); // 绘制visualMap映射组件 // 1）通过graphic.Polygon绘制inRange及outOfRange形状，并为inRange形状绑定drag相关事件处理器 // 2）若userHandle为true，则通过graphic.Polygon绘制handler，graphic.Text绘制handler label // 并为handler绑定drag相关时间处理器 // 3）通过graphic.Polygon绘制指示器，graphic.Text绘制指示器 label this._renderBar(thisGroup); var dataRangeText = visualMapModel.get('text'); // 通过graphic.Text渲染visualMap首与尾处的label this._renderEndsText(thisGroup, dataRangeText, 0); this._renderEndsText(thisGroup, dataRangeText, 1); this._updateView(true); // 调用VisualMapView中的renderBackground方法 this.renderBackground(thisGroup); // 通过graphic.LinearGradient创建线性渐变 this._updateView(); // 绑定mouseover及mouseout相关的事件处理器 // mouseover：showIndicator // mouseout：hideIndicator this._enableHoverLinkToSeries(); this._enableHoverLinkFromSeries(); this.positionGroup(thisGroup);&#125; PiecewisePiecewiseModelPiecewiseModel通过extend方法扩展自VisualMapModel，重写了defaultOption属性以及optionUpdated等方法，并定义了getPieceList、getValueState、findTargetDataIndices等方法 PiecewiseViewPiecewiseView通过extend方法扩展自VisualMapView，定义了doRender方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354doRender: function () &#123; ... // 通过graphic.Text绘制 endsText &amp;&amp; this._renderEndsText( thisGroup, endsText[0], itemSize, showLabel, itemAlign ); // viewPieceList数据处理的实现在PiecewiseModel中resetMethods // 遍历viewPieceList调用renderItem进行片段visual的绘制 zrUtil.each(viewData.viewPieceList, renderItem, this); endsText &amp;&amp; this._renderEndsText( thisGroup, endsText[1], itemSize, showLabel, itemAlign ); layout.box( visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap') ); // 调用VisualMapView中的renderBackground方法 this.renderBackground(thisGroup); this.positionGroup(thisGroup); function renderItem(item) &#123; var piece = item.piece; var itemGroup = new graphic.Group(); // 绑定onclick时的事件处理器 itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece); // 绑定mouseover、mouseout相关的事件处理器 this._enableHoverLink(itemGroup, item.indexInModelPieceList); var representValue = visualMapModel.getRepresentValue(piece); // 通过createSymbol方法创建symbol this._createItemSymbol( itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]] ); if (showLabel) &#123; var visualState = this.visualMapModel.getValueState(representValue); // 渲染文本 itemGroup.add(new graphic.Text(&#123; style: &#123; x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap, y: itemSize[1] / 2, text: piece.text, textVerticalAlign: 'middle', textAlign: itemAlign, textFont: textFont, textFill: textFill, opacity: visualState === 'outOfRange' ? 0.5 : 1 &#125; &#125;)); &#125; thisGroup.add(itemGroup); &#125;&#125; 提示框 TooltipTooltip.jsTooltip.js中注册了showTip及hideTip action，trigger处理器调用TooltipView中定义的manuallyShowTip及manuallyHideTip方法。代码如下： 1234567891011121314151617echarts.registerAction( &#123; type: 'showTip', event: 'showTip', update: 'tooltip:manuallyShowTip' &#125;, function () &#123;&#125;);echarts.registerAction( &#123; type: 'hideTip', event: 'hideTip', update: 'tooltip:manuallyHideTip' &#125;, function () &#123;&#125;); TooltipModelTooltipModel通过extendComponentModel扩展自Component Model，重写了defaultOption属性。 TooltipViewTooltipView通过extendComponentView扩展自Component View，重写了init、render等方法，并定义了manuallyShowTip、manuallyHideTip等方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657init: function (ecModel, api) &#123; ... var tooltipModel = ecModel.getComponent('tooltip'); var renderMode = tooltipModel.get('renderMode'); this._renderMode = getTooltipRenderMode(renderMode); var tooltipContent; // 设置TooltipContent内容 // TooltipContent 中绑定了mouseenter、mousemove、mouseleave等事件处理器， // TooltipRichContent 中绑定了mouseover、mouseout等事件处理器 // TooltipContent&amp;TooltipRichContent 定义了setContent、show、hide、update、getSize等方法 if (this._renderMode === 'html') &#123; tooltipContent = new TooltipContent(api.getDom(), api); this._newLine = '&lt;br/&gt;'; &#125; else &#123; tooltipContent = new TooltipRichContent(api); this._newLine = '\n'; &#125; this._tooltipContent = tooltipContent;&#125;render: function (tooltipModel, ecModel, api) &#123; ... var tooltipContent = this._tooltipContent; // 调用tooltipContent的update方法 tooltipContent.update(); tooltipContent.setEnterable(tooltipModel.get('enterable')); // 初始化tooltip触发监听器 “triggerOn” this._initGlobalListener(); // 调用manuallyShowTip展示tooltip // manuallyShowTip中调用了tryShow方法 this._keepShow();&#125;_tryShow: function (e, dispatchAction) &#123; ... if (dataByCoordSys &amp;&amp; dataByCoordSys.length) &#123; // 展示axis的tooltip信息 // 调用formatTooltip方法渲染Tooltip中的展示内容，包括圆点和数据信息 this._showAxisTooltip(dataByCoordSys, e); &#125; else if (el &amp;&amp; el.dataIndex != null) &#123; // 展示series tooltip信息 // 调用formatTooltip方法渲染Tooltip中的展示内容，包括圆点和数据信息 this._lastDataByCoordSys = null; this._showSeriesItemTooltip(e, el, dispatchAction); &#125; else if (el &amp;&amp; el.tooltip) &#123; // 展示Component下的tooltip信息 this._lastDataByCoordSys = null; this._showComponentItemTooltip(e, el, dispatchAction); &#125; else &#123; this._lastDataByCoordSys = null; this._hide(dispatchAction); &#125;&#125; 工具栏 ToolboxToolboxModelToolboxModel通过extendComponentModel方法扩展自Component Model，重写了defaultOption属性以及optionUpdated方法（merge feature下的option） ToolboxViewToolboxView通过extendComponentView扩展自Component View，重写了render、remove以及dispose等方法，并定义了updateView方法（调用feature下的updateView）。主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485render: function (toolboxModel, ecModel, api, payload) &#123; var group = this.group; group.removeAll(); if (!toolboxModel.get('show')) &#123; return; &#125; var itemSize = +toolboxModel.get('itemSize'); var featureOpts = toolboxModel.get('feature') || &#123;&#125;; var features = this._features || (this._features = &#123;&#125;); var featureNames = []; zrUtil.each(featureOpts, function (opt, name) &#123; featureNames.push(name); &#125;); (new DataDiffer(this._featureNames || [], featureNames)) .add(processFeature) .update(processFeature) .remove(zrUtil.curry(processFeature, null)) .execute(); this._featureNames = featureNames; function processFeature(newIndex, oldIndex) &#123; var featureName = featureNames[newIndex]; var oldName = featureNames[oldIndex]; var featureOpt = featureOpts[featureName]; var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel); var feature; if (featureName &amp;&amp; !oldName) &#123; // Create if (isUserFeatureName(featureName)) &#123; feature = &#123; model: featureModel, onclick: featureModel.option.onclick, featureName: featureName &#125;; &#125; else &#123; var Feature = featureManager.get(featureName); if (!Feature) &#123; return; &#125; feature = new Feature(featureModel, ecModel, api); &#125; features[featureName] = feature; &#125; else &#123; feature = features[oldName]; // If feature does not exsit. if (!feature) &#123; return; &#125; feature.model = featureModel; feature.ecModel = ecModel; feature.api = api; &#125; ... // 通过graphic.createIcon创建工具图标，绑定mouseover、mouseout及click事件处理器 createIconPaths(featureModel, feature, featureName); featureModel.setIconStatus = function (iconName, status) &#123; var option = this.option; var iconPaths = this.iconPaths; option.iconStatus = option.iconStatus || &#123;&#125;; option.iconStatus[iconName] = status; // FIXME iconPaths[iconName] &amp;&amp; iconPaths[iconName].trigger(status); &#125;; if (feature.render) &#123; // 调用相应feature的render方法 feature.render(featureModel, ecModel, api, payload); &#125; &#125; listComponentHelper.layout(group, toolboxModel, api); // 渲染背景 group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // 处理icon title的位置，避免title溢出屏幕 group.eachChild(function (icon) &#123; ... &#125;);&#125; FeaturefeatureManager中定义了注册以及获取feature的方法，实现代码如下： 123456export function register(name, ctor) &#123; features[name] = ctor;&#125;export function get(name) &#123; return features[name];&#125; SaveAsImageSaveAsImage（保存为图片）定义了defaultOption属性以及onclick事件处理器，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var proto = SaveAsImage.prototype;proto.onclick = function (ecModel, api) &#123; var model = this.model; var title = model.get('name') || ecModel.get('title.0.text') || 'echarts'; var $a = document.createElement('a'); var type = model.get('type', true) || 'png'; $a.download = title + '.' + type; $a.target = '_blank'; var url = api.getConnectedDataURL(&#123; type: type, backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff', excludeComponents: model.get('excludeComponents'), pixelRatio: model.get('pixelRatio') &#125;); $a.href = url; // Chrome and Firefox if (typeof MouseEvent === 'function' &amp;&amp; !env.browser.ie &amp;&amp; !env.browser.edge) &#123; var evt = new MouseEvent('click', &#123; view: window, bubbles: true, cancelable: false &#125;); $a.dispatchEvent(evt); &#125; // IE浏览器 else &#123; if (window.navigator.msSaveOrOpenBlob) &#123; var bstr = atob(url.split(',')[1]); var n = bstr.length; var u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; var blob = new Blob([u8arr]); window.navigator.msSaveOrOpenBlob(blob, title + '.' + type); &#125; else &#123; var lang = model.get('lang'); var html = '' + '&lt;body style="margin:0;"&gt;' + '&lt;img src="' + url + '" style="max-width:100%;" title="' + ((lang &amp;&amp; lang[0]) || '') + '" /&gt;' + '&lt;/body&gt;'; var tab = window.open(); tab.document.write(html); &#125; &#125;&#125;; MagicTypeMagicType（动态类型切换）定义了defaultOption属性，以及getIcons、onclick方法，并注册了changeMagicType action，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145var proto = MagicType.prototype;proto.getIcons = function () &#123; var model = this.model; var availableIcons = model.get('icon'); var icons = &#123;&#125;; zrUtil.each(model.get('type'), function (type) &#123; if (availableIcons[type]) &#123; icons[type] = availableIcons[type]; &#125; &#125;); return icons;&#125;;// series option生成器var seriesOptGenreator = &#123; 'line': function (seriesType, seriesId, seriesModel, model) &#123; if (seriesType === 'bar') &#123; return zrUtil.merge(&#123; id: seriesId, type: 'line', // Preserve data related option data: seriesModel.get('data'), stack: seriesModel.get('stack'), markPoint: seriesModel.get('markPoint'), markLine: seriesModel.get('markLine') &#125;, model.get('option.line') || &#123;&#125;, true); &#125; &#125;, 'bar': function (seriesType, seriesId, seriesModel, model) &#123; if (seriesType === 'line') &#123; return zrUtil.merge(&#123; id: seriesId, type: 'bar', // Preserve data related option data: seriesModel.get('data'), stack: seriesModel.get('stack'), markPoint: seriesModel.get('markPoint'), markLine: seriesModel.get('markLine') &#125;, model.get('option.bar') || &#123;&#125;, true); &#125; &#125;, 'stack': function (seriesType, seriesId, seriesModel, model) &#123; if (seriesType === 'line' || seriesType === 'bar') &#123; return zrUtil.merge(&#123; id: seriesId, stack: '__ec_magicType_stack__' &#125;, model.get('option.stack') || &#123;&#125;, true); &#125; &#125;, 'tiled': function (seriesType, seriesId, seriesModel, model) &#123; if (seriesType === 'line' || seriesType === 'bar') &#123; return zrUtil.merge(&#123; id: seriesId, stack: '' &#125;, model.get('option.tiled') || &#123;&#125;, true); &#125; &#125;&#125;;var radioTypes = [ ['line', 'bar'], ['stack', 'tiled']];proto.onclick = function (ecModel, api, type) &#123; var model = this.model; var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType if (!seriesOptGenreator[type]) &#123; return; &#125; var newOption = &#123; series: [] &#125;; // 生成新类型的series var generateNewSeriesTypes = function (seriesModel) &#123; var seriesType = seriesModel.subType; var seriesId = seriesModel.id; var newSeriesOpt = seriesOptGenreator[type]( seriesType, seriesId, seriesModel, model ); if (newSeriesOpt) &#123; // PENDING If merge original option? zrUtil.defaults(newSeriesOpt, seriesModel.option); newOption.series.push(newSeriesOpt); &#125; // Modify boundaryGap var coordSys = seriesModel.coordinateSystem; if (coordSys &amp;&amp; coordSys.type === 'cartesian2d' &amp;&amp; (type === 'line' || type === 'bar')) &#123; var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; if (categoryAxis) &#123; var axisDim = categoryAxis.dim; var axisType = axisDim + 'Axis'; var axisModel = ecModel.queryComponents(&#123; mainType: axisType, index: seriesModel.get(name + 'Index'), id: seriesModel.get(name + 'Id') &#125;)[0]; var axisIndex = axisModel.componentIndex; newOption[axisType] = newOption[axisType] || []; for (var i = 0; i &lt;= axisIndex; i++) &#123; newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || &#123;&#125;; &#125; newOption[axisType][axisIndex].boundaryGap = type === 'bar'; &#125; &#125; &#125;; zrUtil.each(radioTypes, function (radio) &#123; if (zrUtil.indexOf(radio, type) &gt;= 0) &#123; zrUtil.each(radio, function (item) &#123; model.setIconStatus(item, 'normal'); &#125;); &#125; &#125;); // 设置icon的状态 model.setIconStatus(type, 'emphasis'); // 为每个series生成新option ecModel.eachComponent( &#123; mainType: 'series', query: seriesIndex == null ? null : &#123; seriesIndex: seriesIndex &#125; &#125;, generateNewSeriesTypes ); api.dispatchAction(&#123; type: 'changeMagicType', currentType: type, newOption: newOption &#125;);&#125;;echarts.registerAction(&#123; type: 'changeMagicType', event: 'magicTypeChanged', update: 'prepareAndUpdate'&#125;, function (payload, ecModel) &#123; // 合并option ecModel.mergeOption(payload.newOption);&#125;); DataViewDataView（数据视图工具）定义了defaultOption属性及onclick、remove、dispose方法，并注册了changeDataView action，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131DataView.prototype.onclick = function (ecModel, api) &#123; var container = api.getDom(); var model = this.model; if (this._dom) &#123; container.removeChild(this._dom); &#125; var root = document.createElement('div'); root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;'; root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // 创建element var header = document.createElement('h4'); var lang = model.get('lang') || []; header.innerHTML = lang[0] || model.get('title'); header.style.cssText = 'margin: 10px 20px;'; header.style.color = model.get('textColor'); var viewMain = document.createElement('div'); var textarea = document.createElement('textarea'); viewMain.style.cssText = 'display:block;width:100%;overflow:auto;'; var optionToContent = model.get('optionToContent'); var contentToOption = model.get('contentToOption'); // 获取数据 var result = getContentFromModel(ecModel); if (typeof optionToContent === 'function') &#123; var htmlOrDom = optionToContent(api.getOption()); if (typeof htmlOrDom === 'string') &#123; viewMain.innerHTML = htmlOrDom; &#125; else if (zrUtil.isDom(htmlOrDom)) &#123; viewMain.appendChild(htmlOrDom); &#125; &#125; else &#123; // 默认使用textarea viewMain.appendChild(textarea); textarea.readOnly = model.get('readOnly'); textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;'; textarea.style.color = model.get('textColor'); textarea.style.borderColor = model.get('textareaBorderColor'); textarea.style.backgroundColor = model.get('textareaColor'); textarea.value = result.value; &#125; var blockMetaList = result.meta; // 创建按钮容器 var buttonContainer = document.createElement('div'); buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;'; var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px'; // 创建关闭以及刷新按钮 var closeButton = document.createElement('div'); var refreshButton = document.createElement('div'); buttonStyle += ';background-color:' + model.get('buttonColor'); buttonStyle += ';color:' + model.get('buttonTextColor'); var self = this; ... // 添加click事件处理器 eventTool.addEventListener(closeButton, 'click', close); eventTool.addEventListener(refreshButton, 'click', function () &#123; var newOption; try &#123; if (typeof contentToOption === 'function') &#123; newOption = contentToOption(viewMain, api.getOption()); &#125; else &#123; newOption = parseContents(textarea.value, blockMetaList); &#125; &#125; catch (e) &#123; close(); throw new Error('Data view format error ' + e); &#125; if (newOption) &#123; api.dispatchAction(&#123; type: 'changeDataView', newOption: newOption &#125;); &#125; close(); &#125;); closeButton.innerHTML = lang[1]; refreshButton.innerHTML = lang[2]; refreshButton.style.cssText = buttonStyle; closeButton.style.cssText = buttonStyle; !model.get('readOnly') &amp;&amp; buttonContainer.appendChild(refreshButton); buttonContainer.appendChild(closeButton); // 使用tab键进行数据分割 eventTool.addEventListener(textarea, 'keydown', function (e) &#123; if ((e.keyCode || e.which) === 9) &#123; var val = this.value; var start = this.selectionStart; var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose eventTool.stop(e); &#125; &#125;); root.appendChild(header); root.appendChild(viewMain); root.appendChild(buttonContainer); viewMain.style.height = (container.clientHeight - 80) + 'px'; container.appendChild(root); this._dom = root;&#125;;DataView.prototype.remove = function (ecModel, api) &#123; this._dom &amp;&amp; api.getDom().removeChild(this._dom);&#125;;DataView.prototype.dispose = function (ecModel, api) &#123; this.remove(ecModel, api);&#125;; DataZoomDataZoom（数据区域缩放）设置defaultOption属性，定义了render、onclick、remove以及dispose等方法。主要代码如下： 123456789101112131415161718192021222324252627282930proto.render = function (featureModel, ecModel, api, payload) &#123; this.model = featureModel; this.ecModel = ecModel; this.api = api; // 使用BrushTargetManager管理区域选择 updateZoomBtnStatus(featureModel, ecModel, this, payload, api); // 渲染还原按钮的iconStatus updateBackBtnStatus(featureModel, ecModel);&#125;;proto.onclick = function (ecModel, api, type) &#123; handlers[type].call(this);&#125;;var handlers = &#123; zoom: function () &#123; var nextActive = !this._isZoomActive; this.api.dispatchAction(&#123; type: 'takeGlobalCursor', key: 'dataZoomSelect', dataZoomSelectActive: nextActive &#125;); &#125;, back: function () &#123; this._dispatchZoomAction(history.pop(this.ecModel)); &#125;&#125;; RestoreRestore（配置项还原）定义了defaultOption属性以及onclick方法，并注册了restore action，主要代码如下： 12345678910var proto = Restore.prototype;proto.onclick = function (ecModel, api, type) &#123; history.clear(ecModel); api.dispatchAction(&#123; type: 'restore', from: this.uid &#125;);&#125;; Brushbrush（选框组件的控制按钮）定义了defaultOption属性以及onclick、updateView、getIcons等方法，主要代码如下： 123456789101112131415161718192021222324252627282930var proto = Brush.prototype;proto.onclick = function (ecModel, api, type) &#123; var brushType = this._brushType; var brushMode = this._brushMode; if (type === 'clear') &#123; api.dispatchAction(&#123; type: 'axisAreaSelect', intervals: [] &#125;); api.dispatchAction(&#123; type: 'brush', command: 'clear', areas: [] &#125;); &#125; else &#123; api.dispatchAction(&#123; type: 'takeGlobalCursor', key: 'brush', brushOption: &#123; brushType: type === 'keep' ? brushType : (brushType === type ? false : type), brushMode: type === 'keep' ? (brushMode === 'multiple' ? 'single' : 'multiple') : brushMode &#125; &#125;); &#125;&#125;; 区域选择组件 BrushBrushModelBrushModel通过extendComponentModel方法扩展自Component Model，重写了defaultOption属性以及optionUpdated方法，并定义了setAreas、setBrushOption等方法。 BrushViewBrushView通过extendComponentView方法扩展自Component View，重写了init、render、dispose等方法，主要代码如下： 123456789101112init: function (ecModel, api) &#123; ... // 绑定_onBrush事件 (this._brushController = new BrushController(api.getZr())) .on('brush', zrUtil.bind(this._onBrush, this)) .mount();&#125;,render: function (brushModel) &#123; this.model = brushModel; return updateController.apply(this, arguments);&#125;, BrushActionBrushAction注册了brush、brushSelect等action Brush.jsBrush.js即toolbox中Brush的内容 时间轴 Timeline默认为slider类型 TimelineActionTimelineAction注册了timelineChange、timelinePlayChange等action TimelineModelTimelineModel通过extend方法扩展自Component Model，重写了defaultOption属性以及init方法，并定义了setCurrentIndex、getCurrentIndex、 setPlayState、getPlayState等方法 TimelineViewTimelineView通过extend方法扩展自Component Model。 SliderTimelineModelSliderTimelineModel通过extend方法扩展自TimelineModel，重写了defaultOption属性 SliderTimelineViewSliderTimelineView通过extend方法扩展自TimelineView，重写了init、render方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839render: function (timelineModel, ecModel, api, payload) &#123; this.model = timelineModel; this.api = api; this.ecModel = ecModel; this.group.removeAll(); if (timelineModel.get('show', true)) &#123; // 获取布局信息 var layoutInfo = this._layout(timelineModel, api); // 通过graphic.Group创建组 var mainGroup = this._createGroup('mainGroup'); var labelGroup = this._createGroup('labelGroup'); // 新建new TimelineAxis对象实例 var axis = this._axis = this._createAxis(layoutInfo, timelineModel); timelineModel.formatTooltip = function (dataIndex) &#123; return encodeHTML(axis.scale.getLabel(dataIndex)); &#125;; // 调用_renderAxisLine：通过graphic.Line绘制轴线 // 调用_renderAxisTick：通过createSymbol创建symbol // 调用_renderControl：通过new BoundingRect来创建control btn，包括prev、next、play及stop // 调用_renderCurrentPointer：通过createSymbol创建pointer symbol each( ['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) &#123; this['_render' + name](layoutInfo, mainGroup, axis, timelineModel); &#125;, this ); // 通过graphic.Text渲染axis label this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel); this._position(layoutInfo, timelineModel); &#125; // 设置定时器，实现时间轴自动播放效果 this._doPlayStop();&#125;, 原生图形组件 Graphicgraphic.jsgraphic.js文件中定义了GraphicModel以及GraphicView GraphicModelGraphicModel通过extendComponentModel扩展自Component Model，重写了defaultOption属性以及mergeOption、optionUpdated等方法 GraphicViewGraphicView通过extendComponentView扩展自Component View，重写了init、render方法。主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364render: function (graphicModel, ecModel, api) &#123; if (graphicModel !== this._lastGraphicModel) &#123; this._clear(); &#125; this._lastGraphicModel = graphicModel; this._updateElements(graphicModel); this._relocate(graphicModel, api);&#125;_updateElements: function (graphicModel) &#123; var elOptionsToUpdate = graphicModel.useElOptionsToUpdate(); if (!elOptionsToUpdate) &#123; return; &#125; var elMap = this._elMap; var rootGroup = this.group; // Top-down tranverse to assign graphic settings to each elements. zrUtil.each(elOptionsToUpdate, function (elOption) &#123; var $action = elOption.$action; var id = elOption.id; var existEl = elMap.get(id); var parentId = elOption.parentId; var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup; var elOptionStyle = elOption.style; if (elOption.type === 'text' &amp;&amp; elOptionStyle) &#123; // In top/bottom mode, textVerticalAlign should not be used, which cause // inaccurately locating. if (elOption.hv &amp;&amp; elOption.hv[1]) &#123; elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null; &#125; // Compatible with previous setting: both support fill and textFill, // stroke and textStroke. !elOptionStyle.hasOwnProperty('textFill') &amp;&amp; elOptionStyle.fill &amp;&amp; ( elOptionStyle.textFill = elOptionStyle.fill ); !elOptionStyle.hasOwnProperty('textStroke') &amp;&amp; elOptionStyle.stroke &amp;&amp; ( elOptionStyle.textStroke = elOptionStyle.stroke ); &#125; // Remove unnecessary props to avoid potential problems. var elOptionCleaned = getCleanedElOption(elOption); ... // createEl：根据graphicType创建元素 if (!$action || $action === 'merge') &#123; existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap); &#125; else if ($action === 'replace') &#123; removeEl(existEl, elMap); createEl(id, targetElParent, elOptionCleaned, elMap); &#125; else if ($action === 'remove') &#123; removeEl(existEl, elMap); &#125; ... &#125;);&#125; 数据集 Datasetdatasetdataset中定义了Model&amp;View Model： 通过extend方法扩展自Component Model，重写了defaultOption属性以及optionUpdated方法 View： 通过extend方法扩展自Component View 图表标识 Marker公共文件MarkerModelMarkerModel通过extendComponentModel方法扩展自Component Model，重写了init、mergeOption、formatTooltip、getData及setData等方法 MarkerViewMarkerView通过extendComponentView方法扩展自Component View，重写了init、render等方法并定义了renderSeries方法（子类中重写），主要代码如下： 1234567891011121314151617render: function (markerModel, ecModel, api) &#123; var markerGroupMap = this.markerGroupMap; markerGroupMap.each(function (item) &#123; item.__keep = false; &#125;); var markerModelKey = this.type + 'Model'; // 调用子类的renderSeries方法 ecModel.eachSeries(function (seriesModel) &#123; var markerModel = seriesModel[markerModelKey]; markerModel &amp;&amp; this.renderSeries(seriesModel, markerModel, ecModel, api); &#125;, this); markerGroupMap.each(function (item) &#123; !item.__keep &amp;&amp; this.group.remove(item.group); &#125;, this);&#125; 图表标线 MarkLineMarkLineModelMarkLineModel通过extend方法扩展自MarkerModel，重写了defaultOption属性 MarkLineViewMarkLineView通过extend方法扩展自MarkerView，重写了renderSeries方法，主要代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556renderSeries: function (seriesModel, mlModel, ecModel, api) &#123; var coordSys = seriesModel.coordinateSystem; var seriesId = seriesModel.id; var seriesData = seriesModel.getData(); var lineDrawMap = this.markerGroupMap; // 创建LineDraw对象（绘制line）实例 var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw()); this.group.add(lineDraw.group); // 处理data数据，并返回 var mlData = createList(coordSys, seriesModel, mlModel); var fromData = mlData.from; var toData = mlData.to; var lineData = mlData.line; mlModel.__from = fromData; mlModel.__to = toData; // Line data for tooltip and formatter mlModel.setData(lineData); var symbolType = mlModel.get('symbol'); var symbolSize = mlModel.get('symbolSize'); if (!zrUtil.isArray(symbolType)) &#123; symbolType = [symbolType, symbolType]; &#125; if (typeof symbolSize === 'number') &#123; symbolSize = [symbolSize, symbolSize]; &#125; ... // Update visual and layout of line lineData.each(function (idx) &#123; var lineColor = lineData.getItemModel(idx).get('lineStyle.color'); lineData.setItemVisual(idx, &#123; color: lineColor || fromData.getItemVisual(idx, 'color') &#125;); lineData.setItemLayout(idx, [ fromData.getItemLayout(idx), toData.getItemLayout(idx) ]); lineData.setItemVisual(idx, &#123; 'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'), 'fromSymbol': fromData.getItemVisual(idx, 'symbol'), 'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'), 'toSymbol': toData.getItemVisual(idx, 'symbol') &#125;); &#125;); // 根据lineData绘制line lineDraw.updateData(lineData); ... lineDraw.__keep = true; lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');&#125; 图标标注 MarkPointMarkPointModelMarkPointModel通过extend方法扩展自MarkerModel，重写了defaultOption属性 MarkPointViewMarkPointView通过extend方法扩展自MarkerView，重写了renderSeries方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142renderSeries: function (seriesModel, mpModel, ecModel, api) &#123; var coordSys = seriesModel.coordinateSystem; var seriesId = seriesModel.id; var seriesData = seriesModel.getData(); var symbolDrawMap = this.markerGroupMap; // 创建SymbolDraw对象（绘制Symbol）实例 var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw()); var mpData = createList(coordSys, seriesModel, mpModel); // FIXME mpModel.setData(mpData); updateMarkerLayout(mpModel.getData(), seriesModel, api); mpData.each(function (idx) &#123; var itemModel = mpData.getItemModel(idx); var symbolSize = itemModel.getShallow('symbolSize'); if (typeof symbolSize === 'function') &#123; // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？ symbolSize = symbolSize( mpModel.getRawValue(idx), mpModel.getDataParams(idx) ); &#125; mpData.setItemVisual(idx, &#123; symbolSize: symbolSize, color: itemModel.get('itemStyle.color') || seriesData.getVisual('color'), symbol: itemModel.getShallow('symbol') &#125;); &#125;); // mpData绘制Symbol symbolDraw.updateData(mpData); this.group.add(symbolDraw.group); ... symbolDraw.__keep = true; symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');&#125; 图表标域 MarkAreaMarkAreaModelMarkAreaModel通过extend方法扩展自MarkerModel，重写了defaultOption属性 MarkAreaViewMarkAreaView通过extend方法扩展自MarkerView，重写了renderSeries方法，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182renderSeries: function (seriesModel, maModel, ecModel, api) &#123; var coordSys = seriesModel.coordinateSystem; var seriesId = seriesModel.id; var seriesData = seriesModel.getData(); var areaGroupMap = this.markerGroupMap; // 创建group var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, &#123;group: new graphic.Group()&#125;); this.group.add(polygonGroup.group); polygonGroup.__keep = true; // 处理数据 var areaData = createList(coordSys, seriesModel, maModel); ... areaData.diff(polygonGroup.__data) .add(function (idx) &#123; // 通过graphic.Polygon创建元素 var polygon = new graphic.Polygon(&#123; shape: &#123; points: areaData.getItemLayout(idx) &#125; &#125;); areaData.setItemGraphicEl(idx, polygon); polygonGroup.group.add(polygon); &#125;) .update(function (newIdx, oldIdx) &#123; // 更新 var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx); graphic.updateProps(polygon, &#123; shape: &#123; points: areaData.getItemLayout(newIdx) &#125; &#125;, maModel, newIdx); polygonGroup.group.add(polygon); areaData.setItemGraphicEl(newIdx, polygon); &#125;) .remove(function (idx) &#123; var polygon = polygonGroup.__data.getItemGraphicEl(idx); polygonGroup.group.remove(polygon); &#125;) .execute(); areaData.eachItemGraphicEl(function (polygon, idx) &#123; // 设置样式 var itemModel = areaData.getItemModel(idx); var labelModel = itemModel.getModel('label'); var labelHoverModel = itemModel.getModel('emphasis.label'); var color = areaData.getItemVisual(idx, 'color'); polygon.useStyle( zrUtil.defaults( itemModel.getModel('itemStyle').getItemStyle(), &#123; fill: colorUtil.modifyAlpha(color, 0.4), stroke: color &#125; ) ); polygon.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle(); graphic.setLabelStyle( polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, &#123; labelFetcher: maModel, labelDataIndex: idx, defaultText: areaData.getName(idx) || '', isRectText: true, autoColor: color &#125; ); graphic.setHoverStyle(polygon, &#123;&#125;); polygon.dataModel = maModel; &#125;); polygonGroup.__data = areaData; polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');&#125; 总结这篇博文简单介绍了DataZoom、VisualMap、Tooltip、Toolbox、Brush、Timeline、Graphic以及Marker等组件的渲染细节，到这里我们对于Echarts组件的渲染分析已经告一段落了，接下来我们将进入Series即图表的渲染过程分析阶段。 希望能够跟小伙伴们一起进步呀！继续加油！！]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts源码解读《三》：echarts源码之Component分析]]></title>
    <url>%2F2019%2F05%2F22%2Fecharts-3%2F</url>
    <content type="text"><![CDATA[分析完echarts简单的结构之后，我们就进入到了Component源码解读，在这篇博文中，我将主要介绍各Component的渲染过程以及其使用的zrender graphic。希望和小伙伴们一起进步呀！！加油！！ 前言echarts对Component的定义呢，可以认为是除Series外的其他配置项，在这篇博文中我们将探讨title（图标标题）、legend（图例组件）、AxisPointer（坐标轴指示器）、坐标系以及坐标轴这些Component。 用户通过传递option对象来设置相应的Component。 在这部分中echarts采用了Model以及View的架构来管理Component： Model：model/Component.js 管理Component数据 View：view/Component.js 负责渲染Component视图 Model层model/Component.js。Component扩展自Model（Model是Echarts中最基本的元素，其定义了mergeOption等方法，混合了LineStyle、AraeStyle、ItemStyle以及TextStyle），重写了init及mergeOption等方法，定义了mergeDefaultAndTheme、getDefaultOption等方法以及defaultOption（Component默认配置）、componentIndex等属性。 View层view/Component.js。Component中定义了group等属性以及init、render、dispose等方法。 快速扩展在echarts中定义了extendComponentModel以及extendComponentView方法，可以让Component对Model以及View进行快速扩展 1234567export function extendComponentModel(opts) &#123; return ComponentModel.extend(opts);&#125;export function extendComponentView(opts) &#123; return ComponentView.extend(opts);&#125; Titletitle是我们在使用echarts图表时设置的标题组件，简单的🌰： 1234title: &#123; left: 'center', text: '例子Title',&#125; title文件中Model部分通过extendComponentModel方法扩展自Component Model，重写了defaultOption属性，用于设置title的默认option。 View部分通过extendComponentView方法扩展Component View，重写了render方法对title进行渲染，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990render: function (titleModel, ecModel, api) &#123; ... // 通过zrender的Text图形新建文本元素 var textEl = new graphic.Text(&#123; style: graphic.setTextStyle(&#123;&#125;, textStyleModel, &#123; text: titleModel.get('text'), textFill: textStyleModel.getTextColor() &#125;, &#123;disableBox: true&#125;), z2: 10 &#125;); var textRect = textEl.getBoundingRect(); var subText = titleModel.get('subtext'); // 创建subText元素 var subTextEl = new graphic.Text(&#123; style: graphic.setTextStyle(&#123;&#125;, subtextStyleModel, &#123; text: subText, textFill: subtextStyleModel.getTextColor(), y: textRect.height + titleModel.get('itemGap'), textVerticalAlign: 'top' &#125;, &#123;disableBox: true&#125;), z2: 10 &#125;); ... group.add(textEl); subText &amp;&amp; group.add(subTextEl); // If no subText, but add subTextEl, there will be an empty line. ... // 设定title的位置 if (!textAlign) &#123; // Align left if title is on the left. center and right is same textAlign = titleModel.get('left') || titleModel.get('right'); if (textAlign === 'middle') &#123; textAlign = 'center'; &#125; // Adjust layout by text align if (textAlign === 'right') &#123; layoutRect.x += layoutRect.width; &#125; else if (textAlign === 'center') &#123; layoutRect.x += layoutRect.width / 2; &#125; &#125; if (!textBaseline) &#123; textBaseline = titleModel.get('top') || titleModel.get('bottom'); if (textBaseline === 'center') &#123; textBaseline = 'middle'; &#125; if (textBaseline === 'bottom') &#123; layoutRect.y += layoutRect.height; &#125; else if (textBaseline === 'middle') &#123; layoutRect.y += layoutRect.height / 2; &#125; textBaseline = textBaseline || 'top'; &#125; group.attr('position', [layoutRect.x, layoutRect.y]); var alignStyle = &#123; textAlign: textAlign, textVerticalAlign: textBaseline &#125;; // 设置文本样式 textEl.setStyle(alignStyle); subTextEl.setStyle(alignStyle); // 渲染背景 // Get groupRect again because textAlign has been changed groupRect = group.getBoundingRect(); var padding = layoutRect.margin; var style = titleModel.getItemStyle(['color', 'opacity']); style.fill = titleModel.get('backgroundColor'); var rect = new graphic.Rect(&#123; shape: &#123; x: groupRect.x - padding[3], y: groupRect.y - padding[0], width: groupRect.width + padding[1] + padding[3], height: groupRect.height + padding[0] + padding[2], r: titleModel.get('borderRadius') &#125;, style: style, silent: true &#125;); graphic.subPixelOptimizeRect(rect); group.add(rect);&#125; title文本渲染主要是通过zrender graphic中的Text进行渲染的，通过zrender Style中定义的setStyle方法对元素进行样式设定。 Legendlegend为echarts的图例组件，简单的🌰： 123legend: &#123; data:['支出','收入']&#125;, 展示效果图如： legend分为两种：plain（平面）和scroll（可滚动），接下来我将分别讲解两种类型的legend是如何作用的。 Plainlegend.plain为平面的legend图例组件，主要包括LegendAction、LegendModel、LegendView文件。 LegendActionlegendAction文件中注册了legend对外API： legendToggleSelect、legendSelect以及legendUnSelect，主要代码如下： 1234567891011121314echarts.registerAction( 'legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));echarts.registerAction( 'legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));echarts.registerAction( 'legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect')); LegendFilterlegendFilter文件中实现了数据过滤，也就是当legend的isSelected方法返回为false时，则与legend name相同的series的数据则不显示，主要代码如下： 1234567891011121314151617export default function (ecModel) &#123; var legendModels = ecModel.findComponents(&#123; mainType: 'legend' &#125;); if (legendModels &amp;&amp; legendModels.length) &#123; ecModel.filterSeries(function (series) &#123; // If in any legend component the status is not selected. // Because in legend series is assumed selected when it is not in the legend data. for (var i = 0; i &lt; legendModels.length; i++) &#123; if (!legendModels[i].isSelected(series.name)) &#123; return false; &#125; &#125; return true; &#125;); &#125;&#125; LegendModellegendModel通过extendComponentModel方法扩展自Component Model，重写了defaultOption属性，重写了init方法，定义了select、unSelect、toggleSelected以及isSelected等方法。 LegendViewlegendView通过extendComponentView方法扩展自Component View，重写了init以及render方法对legend进行渲染，主要渲染的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162render: function (legendModel, ecModel, api) &#123; ... // renderInner中调用了createItem方法创建Legend item // 并绑定了click、mouseover、mouseout等事件 this.renderInner(itemAlign, legendModel, ecModel, api); ...&#125;;_createItem: function ( name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) &#123; ... // 使用util/symbol导出的createSymbol方法，创建相应Type的Symbol图形 itemGroup.add(createSymbol( legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, // symbolKeepAspect default true for legend symbolKeepAspect == null ? true : symbolKeepAspect )); ... // 渲染legend文本 itemGroup.add(new graphic.Text(&#123; style: graphic.setTextStyle(&#123;&#125;, textStyleModel, &#123; text: content, x: textX, y: itemHeight / 2, textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor, textAlign: textAlign, textVerticalAlign: 'middle' &#125;) &#125;)); // Add a invisible rect to increase the area of mouse hover // 添加legend的tooltip效果 var hitRect = new graphic.Rect(&#123; shape: itemGroup.getBoundingRect(), invisible: true, tooltip: tooltipModel.get('show') ? zrUtil.extend(&#123; content: name, // Defaul formatter formatter: legendGlobalTooltipModel.get('formatter', true) || function () &#123; return name; &#125;, formatterParams: &#123; componentType: 'legend', legendIndex: legendModel.componentIndex, name: name, $vars: ['name'] &#125; &#125;, tooltipModel.option) : null &#125;); itemGroup.add(hitRect); ... this.getContentGroup().add(itemGroup); ... return itemGroup; &#125; Scrolllegend.scroll为可滚动的legend图例组件，主要包括ScrollableLegendAction、ScrollableLegendModel、ScrollableLegendView文件。 ScrollableLegendActionScrollableLegendAction文件中注册了legend对外API：legendScroll，主要代码如下： 12345678910111213echarts.registerAction( 'legendScroll', 'legendscroll', function (payload, ecModel) &#123; var scrollDataIndex = payload.scrollDataIndex; scrollDataIndex != null &amp;&amp; ecModel.eachComponent( &#123;mainType: 'legend', subType: 'scroll', query: payload&#125;, function (legendModel) &#123; legendModel.setScrollDataIndex(scrollDataIndex); &#125; ); &#125;); ScrollableLegendModelScrollableLegendModel通过extend方法扩展自LegendMode，重写了defaultOption属性，重写了init方法，定义了setScrollDataIndex以及getOrient等方法。 ScrollableLegendViewScrollableLegendView通过extend方法扩展自LegendView，重写了init以及renderInner方法对scrollable legend进行渲染，主要渲染的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455renderInner: function (itemAlign, legendModel, ecModel, api) &#123; var me = this; // Render content items. // 调用LegenView中renderInner渲染基本的legend视图 ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api); // 创建分页器 var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length, // e.g., '3/12345' should not overlap with the control arrow button. var pageIconSize = legendModel.get('pageIconSize', true); if (!zrUtil.isArray(pageIconSize)) &#123; pageIconSize = [pageIconSize, pageIconSize]; &#125; createPageButton('pagePrev', 0); var pageTextStyleModel = legendModel.getModel('pageTextStyle'); controllerGroup.add(new graphic.Text(&#123; name: 'pageText', style: &#123; textFill: pageTextStyleModel.getTextColor(), font: pageTextStyleModel.getFont(), textVerticalAlign: 'middle', textAlign: 'center' &#125;, silent: true &#125;)); createPageButton('pageNext', 1); // 创建prev&amp;next button function createPageButton(name, iconIdx) &#123; var pageDataIndexName = name + 'DataIndex'; var icon = graphic.createIcon( legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], &#123; // Buttons will be created in each render, so we do not need // to worry about avoiding using legendModel kept in scope. onclick: zrUtil.bind( me._pageGo, me, pageDataIndexName, legendModel, api ) &#125;, &#123; x: -pageIconSize[0] / 2, y: -pageIconSize[1] / 2, width: pageIconSize[0], height: pageIconSize[1] &#125; ); icon.name = name; controllerGroup.add(icon); &#125;&#125; AxisPointerAxisPointer为echarts中的坐标指示器，包括直角坐标以及极坐标等。 AxisPointer.jsaxisPointer.js文件中注册了axisPointer对外api，主要代码如下： 12345echarts.registerAction(&#123; type: 'updateAxisPointer', event: 'updateAxisPointer', update: ':updateAxisPointer'&#125;, axisTrigger); 存储coordSysAxesInfo信息，主要代码如下： 123456echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) &#123; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis. // allAxesInfo should be updated when setOption performed. ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);&#125;); AxisPointerModelAxisPointerModel通过extendComponentModel方法扩展自Component Model，重写了defaultOption属性。 AxisPointerViewAxisPointerView过extendComponentModel方法扩展自Component View，重写了render、remove以及dispose方法。 BaseAxisPointerBaseAxisPointer为CartesianAxisPointer、PolarAxisPointer等的基类，重写了render以及renderHandler等方法。renderHandler主要是定义move、drag等情况时视图更新方法。 render主要代码： 12345678910111213141516171819202122232425262728293031323334353637render: function (axisModel, axisPointerModel, api, forceRender) &#123; ... var elOption = &#123;&#125;; // 调用子类的makeElOption方法 this.makeElOption(elOption, value, axisModel, axisPointerModel, api); ... // 创建pointer this.createPointerEl(group, elOption, axisModel, axisPointerModel); // 渲染label元素 this.createLabelEl(group, elOption, axisModel, axisPointerModel); ... updateMandatoryProps(group, axisPointerModel, true); // 渲染handler this._renderHandle(value);&#125;createPointerEl: function (group, elOption, axisModel, axisPointerModel) &#123; var pointerOption = elOption.pointer; if (pointerOption) &#123; // 通过graphic创建 var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type]( clone(elOption.pointer) ); group.add(pointerEl); &#125;&#125;createLabelEl: function (group, elOption, axisModel, axisPointerModel) &#123; if (elOption.label) &#123; var labelEl = inner(group).labelEl = new graphic.Rect( clone(elOption.label) ); group.add(labelEl); updateLabelShowHide(labelEl, axisPointerModel); &#125;&#125; CartesianAxisPointerCartesianAxisPointer使用extend方法扩展自BaseAxisPointer，重写了makeElOption、getHandleTransform以及updateHandleTransform方法。makeElOption主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152makeElOption: function (elOption, value, axisModel, axisPointerModel, api) &#123; var axis = axisModel.axis; var grid = axis.grid; var axisPointerType = axisPointerModel.get('type'); var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent(); var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true)); if (axisPointerType &amp;&amp; axisPointerType !== 'none') &#123; var elStyle = viewHelper.buildElStyle(axisPointerModel); var pointerOption = pointerShapeBuilder[axisPointerType]( axis, pixelValue, otherExtent, elStyle ); pointerOption.style = elStyle; elOption.graphicKey = pointerOption.type; elOption.pointer = pointerOption; &#125; var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel); viewHelper.buildCartesianSingleLabelElOption( value, elOption, layoutInfo, axisModel, axisPointerModel, api );&#125;var pointerShapeBuilder = &#123; line: function (axis, pixelValue, otherExtent, elStyle) &#123; var targetShape = viewHelper.makeLineShape( [pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis) ); graphic.subPixelOptimizeLine(&#123; shape: targetShape, style: elStyle &#125;); return &#123; type: 'Line', shape: targetShape &#125;; &#125;, shadow: function (axis, pixelValue, otherExtent, elStyle) &#123; var bandWidth = Math.max(1, axis.getBandWidth()); var span = otherExtent[1] - otherExtent[0]; return &#123; type: 'Rect', shape: viewHelper.makeRectShape( [pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis) ) &#125;; &#125;&#125;; SingleAxisPointerSingleAxisPointer同CartesianAxisPointer。 PolarAxisPointerPolarAxisPointer使用extend扩展自BaseAxisPointer，重写了makeElOption方法，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576makeElOption: function (elOption, value, axisModel, axisPointerModel, api) &#123; var axis = axisModel.axis; if (axis.dim === 'angle') &#123; this.animationThreshold = Math.PI / 18; &#125; var polar = axis.polar; var otherAxis = polar.getOtherAxis(axis); var otherExtent = otherAxis.getExtent(); var coordValue; coordValue = axis['dataTo' + formatUtil.capitalFirst(axis.dim)](value); var axisPointerType = axisPointerModel.get('type'); if (axisPointerType &amp;&amp; axisPointerType !== 'none') &#123; var elStyle = viewHelper.buildElStyle(axisPointerModel); var pointerOption = pointerShapeBuilder[axisPointerType]( axis, polar, coordValue, otherExtent, elStyle ); pointerOption.style = elStyle; elOption.graphicKey = pointerOption.type; elOption.pointer = pointerOption; &#125; var labelMargin = axisPointerModel.get('label.margin'); var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin); viewHelper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);&#125;var pointerShapeBuilder = &#123; line: function (axis, polar, coordValue, otherExtent, elStyle) &#123; return axis.dim === 'angle' ? &#123; type: 'Line', shape: viewHelper.makeLineShape( polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]) ) &#125; : &#123; type: 'Circle', shape: &#123; cx: polar.cx, cy: polar.cy, r: coordValue &#125; &#125;; &#125;, shadow: function (axis, polar, coordValue, otherExtent, elStyle) &#123; var bandWidth = Math.max(1, axis.getBandWidth()); var radian = Math.PI / 180; return axis.dim === 'angle' ? &#123; type: 'Sector', shape: viewHelper.makeSectorShape( polar.cx, polar.cy, otherExtent[0], otherExtent[1], // In ECharts y is negative if angle is positive (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian ) &#125; : &#123; type: 'Sector', shape: viewHelper.makeSectorShape( polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2 ) &#125;; &#125;&#125;; 坐标轴公共文件在直角坐标系以及极坐标系等坐标轴组件中，存在着多个公共文件。 AxisViewAxisView通过extendComponentView方法扩展自Component Model，重写了render、remove以及dispose方法，定义了updateAxisPointer方法。 AxisBuilderAxisBuilder中定义了axisLine、axisTickLabel以及axisName的渲染方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125var builders = &#123; axisLine: function () &#123; ... this.group.add(new graphic.Line(graphic.subPixelOptimizeLine(&#123; // Id for animation anid: 'line', shape: &#123; x1: pt1[0], y1: pt1[1], x2: pt2[0], y2: pt2[1] &#125;, style: lineStyle, strokeContainThreshold: opt.strokeContainThreshold || 5, silent: true, z2: 1 &#125;))); var arrows = axisModel.get('axisLine.symbol'); var arrowSize = axisModel.get('axisLine.symbolSize'); var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0; if (typeof arrowOffset === 'number') &#123; arrowOffset = [arrowOffset, arrowOffset]; &#125; if (arrows != null) &#123; ... each([&#123; rotate: opt.rotation + Math.PI / 2, offset: arrowOffset[0], r: 0 &#125;, &#123; rotate: opt.rotation - Math.PI / 2, offset: arrowOffset[1], r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1])) &#125;], function (point, index) &#123; // 创建arrow symbole if (arrows[index] !== 'none' &amp;&amp; arrows[index] != null) &#123; var symbol = createSymbol( arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true ); // Calculate arrow position with offset var r = point.r + point.offset; var pos = [ pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation) ]; symbol.attr(&#123; rotation: point.rotate, position: pos, silent: true, z2: 11 &#125;); this.group.add(symbol); &#125; &#125;, this); &#125; &#125;, axisTickLabel: function () &#123; var axisModel = this.axisModel; var opt = this.opt; // 通过graphic.Line以及graphic.Text分别对tick及label进行渲染 var tickEls = buildAxisTick(this, axisModel, opt); var labelEls = buildAxisLabel(this, axisModel, opt); fixMinMaxLabelShow(axisModel, labelEls, tickEls); &#125;, axisName: function () &#123; ... var textEl = new graphic.Text(&#123; // Id for animation anid: 'name', __fullText: name, __truncatedText: truncatedText, position: pos, rotation: labelLayout.rotation, silent: isSilent(axisModel), z2: 1, tooltip: (tooltipOpt &amp;&amp; tooltipOpt.show) ? extend(&#123; content: name, formatter: function () &#123; return name; &#125;, formatterParams: formatterParams &#125;, tooltipOpt) : null &#125;); graphic.setTextStyle(textEl.style, textStyleModel, &#123; text: truncatedText, textFont: textFont, textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'), textAlign: labelLayout.textAlign, textVerticalAlign: labelLayout.textVerticalAlign &#125;); ... // FIXME this._dumbGroup.add(textEl); textEl.updateTransform(); this.group.add(textEl); textEl.decomposeTransform(); &#125;&#125;; AxisModelCreatorAxisModelCreator为生成AxisModel的方法，其在AxisModel的基础上扩展了getCategories、getOrdinalMeta、mergeDefaultAndTheme等方法，重写了defaultOption属性，并通过： 1234ComponentModel.registerSubTypeDefaulter( axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName)); 来注册相应的Axis子类，如xAxis、yAxis、radiusAxis以及angleAxis等。 直角坐标轴 AxisAxis为直角坐标系Grid中的坐标轴，包括xAxis（x轴）以及yAxis（y轴）。 AxisModelAxisModel通过extend方法扩展自Component Model，重写了init、mergeOption、，并使用AxisModelCreator分别创建额xAxisModel以及yAxisModel， CartesianAxisViewCartesianAxisView通过extend方法扩展自AxisView，重写了render方法，定义了splitLine以及splitArea方法，并扩展了xAxis以及yAxis View。主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var CartesianAxisView = AxisView.extend(&#123; type: 'cartesianAxis', axisPointerClass: 'CartesianAxisPointer', render: function (axisModel, ecModel, api, payload) &#123; ... // 结合AxisBuilder var axisBuilder = new AxisBuilder(axisModel, layout); zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder); ... CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload); &#125;, ... _splitLine: function (axisModel, gridModel) &#123; ... // Simple optimization // Batching the lines if color are the same for (var i = 0; i &lt; ticksCoords.length; i++) &#123; ... this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine(&#123; anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null, shape: &#123; x1: p1[0], y1: p1[1], x2: p2[0], y2: p2[1] &#125;, style: zrUtil.defaults(&#123; stroke: lineColors[colorIndex] &#125;, lineStyle), silent: true &#125;))); &#125; &#125;, _splitArea: function (axisModel, gridModel) &#123; ... for (var i = 1; i &lt; ticksCoords.length; i++) &#123; ... this._axisGroup.add(new graphic.Rect(&#123; anid: tickValue != null ? 'area_' + tickValue : null, shape: &#123; x: x, y: y, width: width, height: height &#125;, style: zrUtil.defaults(&#123; fill: areaColors[colorIndex] &#125;, areaStyle), silent: true &#125;)); colorIndex = (colorIndex + 1) % areaColorsLen; &#125; this._splitAreaColors = newSplitAreaColors; &#125;&#125;);CartesianAxisView.extend(&#123; type: 'xAxis'&#125;);CartesianAxisView.extend(&#123; type: 'yAxis'&#125;); 极坐标轴 AngleAxis&amp;RadiusAxis每一个极坐标都拥有一个角度轴AngleAxis和一个半径轴RadiusAxis。 公共文件AxisModelAxisModel通过extend方法扩展自Component Model，定义了getCoordSysModel方法，并根据不同option创建了angle和radius Model，主要代码如下： 12axisModelCreator('angle', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);axisModelCreator('radius', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius); 角度轴 AngleAxisAngleAxis为极坐标Polar中的角度轴， AngleAxisViewAngleAxisView通过extend方法扩展自AxisView，重写了render方法，并定义了axisLine、axisTick、axisLabel、splitLine以及splitArea等方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123render: function (angleAxisModel, ecModel) &#123; ... var angleAxis = angleAxisModel.axis; var polar = angleAxis.polar; var radiusExtent = polar.getRadiusAxis().getExtent(); var ticksAngles = angleAxis.getTicksCoords(); var labels = zrUtil.map(angleAxis.getViewLabels(), function (labelItem) &#123; var labelItem = zrUtil.clone(labelItem); labelItem.coord = angleAxis.dataToCoord(labelItem.tickValue); return labelItem; &#125;); ...&#125;,_axisLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) &#123; var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle'); var circle = new graphic.Circle(&#123; shape: &#123; cx: polar.cx, cy: polar.cy, r: radiusExtent[getRadiusIdx(polar)] &#125;, style: lineStyleModel.getLineStyle(), z2: 1, silent: true &#125;); circle.style.fill = null; this.group.add(circle); &#125;, _axisTick: function (angleAxisModel, polar, ticksAngles, radiusExtent) &#123; var tickModel = angleAxisModel.getModel('axisTick'); var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length'); var radius = radiusExtent[getRadiusIdx(polar)]; var lines = zrUtil.map(ticksAngles, function (tickAngleItem) &#123; return new graphic.Line(&#123; shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord) &#125;); &#125;); this.group.add(graphic.mergePath( lines, &#123; style: zrUtil.defaults( tickModel.getModel('lineStyle').getLineStyle(), &#123; stroke: angleAxisModel.get('axisLine.lineStyle.color') &#125; ) &#125; )); &#125;, _axisLabel: function (angleAxisModel, polar, ticksAngles, radiusExtent, labels) &#123; ... // Use length of ticksAngles because it may remove the last tick to avoid overlapping zrUtil.each(labels, function (labelItem, idx) &#123; ... var textEl = new graphic.Text(&#123;silent: true&#125;); this.group.add(textEl); graphic.setTextStyle(textEl.style, labelModel, &#123; x: p[0], y: p[1], textFill: labelModel.getTextColor() || angleAxisModel.get('axisLine.lineStyle.color'), text: labelItem.formattedLabel, textAlign: labelTextAlign, textVerticalAlign: labelTextVerticalAlign &#125;); &#125;, this); &#125;, _splitLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) &#123; ... for (var i = 0; i &lt; ticksAngles.length; i++) &#123; var colorIndex = (lineCount++) % lineColors.length; splitLines[colorIndex] = splitLines[colorIndex] || []; splitLines[colorIndex].push(new graphic.Line(&#123; shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord) &#125;)); &#125; // Simple optimization // Batching the lines if color are the same for (var i = 0; i &lt; splitLines.length; i++) &#123; this.group.add(graphic.mergePath(splitLines[i], &#123; style: zrUtil.defaults(&#123; stroke: lineColors[i % lineColors.length] &#125;, lineStyleModel.getLineStyle()), silent: true, z: angleAxisModel.get('z') &#125;)); &#125; &#125;, _splitArea: function (angleAxisModel, polar, ticksAngles, radiusExtent) &#123; ... for (var i = 1; i &lt; ticksAngles.length; i++) &#123; var colorIndex = (lineCount++) % areaColors.length; splitAreas[colorIndex] = splitAreas[colorIndex] || []; splitAreas[colorIndex].push(new graphic.Sector(&#123; shape: &#123; cx: polar.cx, cy: polar.cy, r0: r0, r: r1, startAngle: prevAngle, endAngle: -ticksAngles[i].coord * RADIAN, clockwise: clockwise &#125;, silent: true &#125;)); prevAngle = -ticksAngles[i].coord * RADIAN; &#125; // Simple optimization // Batching the lines if color are the same for (var i = 0; i &lt; splitAreas.length; i++) &#123; this.group.add(graphic.mergePath(splitAreas[i], &#123; style: zrUtil.defaults(&#123; fill: areaColors[i % areaColors.length] &#125;, areaStyleModel.getAreaStyle()), silent: true &#125;)); &#125; &#125; 半径轴 RadiusAxisRadiusAxis为极坐标Polar中的半径轴。 RadiusAxisViewRadiusAxisView通过extend方法扩展自AxisView，重写了render方法，并定义了splitLine、splitArea方法，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758_splitLine: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) &#123; ... for (var i = 0; i &lt; ticksCoords.length; i++) &#123; var colorIndex = (lineCount++) % lineColors.length; splitLines[colorIndex] = splitLines[colorIndex] || []; splitLines[colorIndex].push(new graphic.Circle(&#123; shape: &#123; cx: polar.cx, cy: polar.cy, r: ticksCoords[i].coord &#125;, silent: true &#125;)); &#125; // Simple optimization // Batching the lines if color are the same for (var i = 0; i &lt; splitLines.length; i++) &#123; this.group.add(graphic.mergePath(splitLines[i], &#123; style: zrUtil.defaults(&#123; stroke: lineColors[i % lineColors.length], fill: null &#125;, lineStyleModel.getLineStyle()), silent: true &#125;)); &#125;&#125;,_splitArea: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) &#123; ... for (var i = 1; i &lt; ticksCoords.length; i++) &#123; var colorIndex = (lineCount++) % areaColors.length; splitAreas[colorIndex] = splitAreas[colorIndex] || []; splitAreas[colorIndex].push(new graphic.Sector(&#123; shape: &#123; cx: polar.cx, cy: polar.cy, r0: prevRadius, r: ticksCoords[i].coord, startAngle: 0, endAngle: Math.PI * 2 &#125;, silent: true &#125;)); prevRadius = ticksCoords[i].coord; &#125; // Simple optimization // Batching the lines if color are the same for (var i = 0; i &lt; splitAreas.length; i++) &#123; this.group.add(graphic.mergePath(splitAreas[i], &#123; style: zrUtil.defaults(&#123; fill: areaColors[i % areaColors.length] &#125;, areaStyleModel.getAreaStyle()), silent: true &#125;)); &#125; &#125; 雷达坐标轴RadarViewRadarView通过extendComponentView方法扩展自Component View，重写了render方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110render: function (radarModel, ecModel, api) &#123; var group = this.group; group.removeAll(); this._buildAxes(radarModel); this._buildSplitLineAndArea(radarModel);&#125;,_buildAxes: function (radarModel) &#123; var radar = radarModel.coordinateSystem; var indicatorAxes = radar.getIndicatorAxes(); var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) &#123; var axisBuilder = new AxisBuilder(indicatorAxis.model, &#123; position: [radar.cx, radar.cy], rotation: indicatorAxis.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 &#125;); return axisBuilder; &#125;); zrUtil.each(axisBuilders, function (axisBuilder) &#123; zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder); this.group.add(axisBuilder.getGroup()); &#125;, this);&#125;,_buildSplitLineAndArea: function (radarModel) &#123; ... if (shape === 'circle') &#123; var ticksRadius = indicatorAxes[0].getTicksCoords(); var cx = radar.cx; var cy = radar.cy; for (var i = 0; i &lt; ticksRadius.length; i++) &#123; if (showSplitLine) &#123; var colorIndex = getColorIndex(splitLines, splitLineColors, i); splitLines[colorIndex].push(new graphic.Circle(&#123; shape: &#123; cx: cx, cy: cy, r: ticksRadius[i].coord &#125; &#125;)); &#125; if (showSplitArea &amp;&amp; i &lt; ticksRadius.length - 1) &#123; var colorIndex = getColorIndex(splitAreas, splitAreaColors, i); splitAreas[colorIndex].push(new graphic.Ring(&#123; shape: &#123; cx: cx, cy: cy, r0: ticksRadius[i].coord, r: ticksRadius[i + 1].coord &#125; &#125;)); &#125; &#125; &#125; // Polygon else &#123; ... for (var i = 0; i &lt;= realSplitNumber; i++) &#123; ... if (showSplitLine) &#123; var colorIndex = getColorIndex(splitLines, splitLineColors, i); splitLines[colorIndex].push(new graphic.Polyline(&#123; shape: &#123; points: points &#125; &#125;)); &#125; if (showSplitArea &amp;&amp; prevPoints) &#123; var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1); splitAreas[colorIndex].push(new graphic.Polygon(&#123; shape: &#123; points: points.concat(prevPoints) &#125; &#125;)); &#125; prevPoints = points.slice().reverse(); &#125; &#125; var lineStyle = lineStyleModel.getLineStyle(); var areaStyle = areaStyleModel.getAreaStyle(); // Add splitArea before splitLine zrUtil.each(splitAreas, function (splitAreas, idx) &#123; this.group.add(graphic.mergePath( splitAreas, &#123; style: zrUtil.defaults(&#123; stroke: 'none', fill: splitAreaColors[idx % splitAreaColors.length] &#125;, areaStyle), silent: true &#125; )); &#125;, this); zrUtil.each(splitLines, function (splitLines, idx) &#123; this.group.add(graphic.mergePath( splitLines, &#123; style: zrUtil.defaults(&#123; fill: 'none', stroke: splitLineColors[idx % splitLineColors.length] &#125;, lineStyle), silent: true &#125; )); &#125;, this);&#125; RadarModelRadarModel通过extendComponentModel扩展自Component Model，重写了defaultOption属性以及optionUpdated方法。 平行坐标轴 ParallelAxisParallelModelParallelModel使用extend方法扩展自Component Model，重写了defaultOption属性，并重写了init、mergeOption等方法。 ParallelAxisActionparallelAxisAction中注册了axisAreaSelected以及parallelAxisExpand API，主要代码如下： 12345678910111213141516171819202122var actionInfo = &#123; type: 'axisAreaSelect', event: 'axisAreaSelected'&#125;;echarts.registerAction(actionInfo, function (payload, ecModel) &#123; ecModel.eachComponent( &#123;mainType: 'parallelAxis', query: payload&#125;, function (parallelAxisModel) &#123; parallelAxisModel.axis.model.setActiveIntervals(payload.intervals); &#125; );&#125;);echarts.registerAction('parallelAxisExpand', function (payload, ecModel) &#123; ecModel.eachComponent( &#123;mainType: 'parallel', query: payload&#125;, function (parallelModel) &#123; parallelModel.setAxisExpand(payload); &#125; );&#125;); ParallelAxisViewParallelAxisView使用extendComponentView方法扩展自Component View，重写了render等方法。渲染代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546render: function (axisModel, ecModel, api, payload) &#123; ... var axisBuilder = new AxisBuilder(axisModel, builderOpt); zrUtil.each(elementList, axisBuilder.add, axisBuilder); this._axisGroup.add(axisBuilder.getGroup()); this._refreshBrushController( builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api ); ... &#125;, _refreshBrushController: function ( builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) &#123; ... var rect = graphic.BoundingRect.create(&#123; x: extent[0], y: -areaWidth / 2, width: extentLen, height: areaWidth &#125;); rect.x -= extra; rect.width += 2 * extra; // _brushController为平行坐标轴上的控制器 this._brushController .mount(&#123; enableGlobalPan: true, rotation: builderOpt.rotation, position: builderOpt.position &#125;) .setPanels([&#123; panelId: 'pl', clipPath: brushHelper.makeRectPanelClipPath(rect), isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, coordSysModel), getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect, 0) &#125;]) .enableBrush(&#123; brushType: 'lineX', brushStyle: areaSelectStyle, removeOnClick: true &#125;) .updateCovers(getCoverInfoList(axisModel));&#125;, 单轴 SingleAxisSingleCreatorSingleCreator文件主要为创建单轴的逻辑代码，主要代码如下： 1234567891011121314151617181920212223242526function create(ecModel, api) &#123; var singles = []; ecModel.eachComponent('singleAxis', function (axisModel, idx) &#123; var single = new Single(axisModel, ecModel, api); single.name = 'single_' + idx; single.resize(axisModel, api); axisModel.coordinateSystem = single; singles.push(single); &#125;); ecModel.eachSeries(function (seriesModel) &#123; if (seriesModel.get('coordinateSystem') === 'singleAxis') &#123; var singleAxisModel = ecModel.queryComponents(&#123; mainType: 'singleAxis', index: seriesModel.get('singleAxisIndex'), id: seriesModel.get('singleAxisId') &#125;)[0]; seriesModel.coordinateSystem = singleAxisModel &amp;&amp; singleAxisModel.coordinateSystem; &#125; &#125;); return singles;&#125; AxisModelaxisModel扩展自Component Model，重写了defaultOption属性 SingleAxisViewSingleAxisView使用extend方法扩展自AxisView，重写了render方法，并定义了splitLine方法，实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051render: function (axisModel, ecModel, api, payload) &#123; ... var layout = singleAxisHelper.layout(axisModel); var axisBuilder = new AxisBuilder(axisModel, layout); zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder); ... SingleAxisView.superCall(this, 'render', axisModel, ecModel, api, payload); &#125;, _splitLine: function (axisModel) &#123; var axis = axisModel.axis; ... var ticksCoords = axis.getTicksCoords(&#123; tickModel: splitLineModel &#125;); var p1 = []; var p2 = []; for (var i = 0; i &lt; ticksCoords.length; ++i) &#123; var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord); if (isHorizontal) &#123; p1[0] = tickCoord; p1[1] = gridRect.y; p2[0] = tickCoord; p2[1] = gridRect.y + gridRect.height; &#125; else &#123; p1[0] = gridRect.x; p1[1] = tickCoord; p2[0] = gridRect.x + gridRect.width; p2[1] = tickCoord; &#125; var colorIndex = (lineCount++) % lineColors.length; splitLines[colorIndex] = splitLines[colorIndex] || []; splitLines[colorIndex].push(new graphic.Line( graphic.subPixelOptimizeLine(&#123; shape: &#123; x1: p1[0], y1: p1[1], x2: p2[0], y2: p2[1] &#125;, style: &#123; lineWidth: lineWidth &#125;, silent: true &#125;))); &#125; ... &#125; 坐标系在上一节中，我们介绍了直角坐标轴、极坐标轴以及雷达坐标轴，我们将在这节解读坐标轴是如何在坐标系中展示的。 公共文件AxisAxis对象中定义了scale、dim等属性以及contain、containData、getExtent、getTicksCoords、getViewLabels等方法。 Grid 直角坐标系Grid为echarts中的直角坐标系组件。 gridSimplegridSimple通过extendComponentView扩展自Component View，重写了render方法，主要代码如下： 12345678910111213render: function (gridModel, ecModel) &#123; this.group.removeAll(); if (gridModel.get('show')) &#123; this.group.add(new graphic.Rect(&#123; shape: gridModel.coordinateSystem.getRect(), style: zrUtil.defaults(&#123; fill: gridModel.get('backgroundColor') &#125;, gridModel.getItemStyle()), silent: true, z2: -1 &#125;)); &#125;&#125; Gridcoord/cartesian/Grid.js，实现直角坐标系的渲染，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function Grid(gridModel, ecModel, api) &#123; ... this._initCartesian(gridModel, ecModel, api); ...&#125;gridProto._initCartesian = function (gridModel, ecModel, api) &#123; var axisPositionUsed = &#123; left: false, right: false, top: false, bottom: false &#125;; var axesMap = &#123; x: &#123;&#125;, y: &#123;&#125; &#125;; var axesCount = &#123; x: 0, y: 0 &#125;; /// Create axis // 创建x及y坐标轴 ecModel.eachComponent('xAxis', createAxisCreator('x'), this); ecModel.eachComponent('yAxis', createAxisCreator('y'), this); ... /// Create cartesian2d // 创建 each(axesMap.x, function (xAxis, xAxisIndex) &#123; each(axesMap.y, function (yAxis, yAxisIndex) &#123; var key = 'x' + xAxisIndex + 'y' + yAxisIndex; var cartesian = new Cartesian2D(key); cartesian.grid = this; cartesian.model = gridModel; this._coordsMap[key] = cartesian; this._coordsList.push(cartesian); cartesian.addAxis(xAxis); cartesian.addAxis(yAxis); &#125;, this); &#125;, this); function createAxisCreator(axisType) &#123; return function (axisModel, idx) &#123; ... // 创建坐标轴 var axis = new Axis2D( axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition ); ... &#125;; &#125;&#125;; Polar 极坐标系Polar为echarts中的极坐标系组件，每一个极坐标都拥有一个角度轴和一个半径轴。 PolarPolar定义了angleAxis（new RadiusAxis()）、radiusAxis（new AngleAxis()）等属性以及containPoint、containData、getAxis、getAngleAxis、getRadiusAxis等方法。 PolarCreatorPolarCreator用于创建极坐标系，主要代码如下： 12345678910111213141516171819202122232425262728create: function (ecModel, api) &#123; var polarList = []; ecModel.eachComponent('polar', function (polarModel, idx) &#123; var polar = new Polar(idx); // Inject resize and update method polar.update = updatePolarScale; var radiusAxis = polar.getRadiusAxis(); var angleAxis = polar.getAngleAxis(); var radiusAxisModel = polarModel.findAxisModel('radiusAxis'); var angleAxisModel = polarModel.findAxisModel('angleAxis'); // 设置角度轴和半径轴 setAxis(radiusAxis, radiusAxisModel); setAxis(angleAxis, angleAxisModel); resizePolar(polar, polarModel, api); polarList.push(polar); polarModel.coordinateSystem = polar; polar.model = polarModel; &#125;); ... return polarList;&#125; Radar 雷达坐标系Radar为echarts中的雷达坐标系组件。 ###Radar Radar文件位于coord/radar目录下，定义了getIndicatorAxes、coordToPoint、dataToPoint等方法，并注册了雷达坐标信息，主要代码为： 12345678910111213141516171819202122232425262728293031function Radar(radarModel, ecModel, api) &#123; ... this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) &#123; var dim = 'indicator_' + idx; // 创建雷达坐标轴 var indicatorAxis = new IndicatorAxis(dim, new IntervalScale()); indicatorAxis.name = indicatorModel.get('name'); // Inject model and axis indicatorAxis.model = indicatorModel; indicatorModel.axis = indicatorAxis; this.dimensions.push(dim); return indicatorAxis; &#125;, this); ...&#125;Radar.create = function (ecModel, api) &#123; var radarList = []; ecModel.eachComponent('radar', function (radarModel) &#123; var radar = new Radar(radarModel, ecModel, api); radarList.push(radar); radarModel.coordinateSystem = radar; &#125;); ecModel.eachSeriesByType('radar', function (radarSeries) &#123; if (radarSeries.get('coordinateSystem') === 'radar') &#123; // Inject coordinate system radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0]; &#125; &#125;); return radarList;&#125;;CoordinateSystem.register('radar', Radar); Parallel 平行坐标系Parallel为echarts中的平行坐标系组件。 ParallelParallel定义了rect、dimensions等属性以及init、containPoint、getRect、getAxis、axisCoordToPoint等方法。 ParallelCreatorParallelCreator用于创建平行坐标系，主要代码如下： 12345678910111213141516171819202122232425262728293031function create(ecModel, api) &#123; var coordSysList = []; ecModel.eachComponent('parallel', function (parallelModel, idx) &#123; var coordSys = new Parallel(parallelModel, ecModel, api); coordSys.name = 'parallel_' + idx; coordSys.resize(parallelModel, api); parallelModel.coordinateSystem = coordSys; coordSys.model = parallelModel; coordSysList.push(coordSys); &#125;); // Inject the coordinateSystems into seriesModel ecModel.eachSeries(function (seriesModel) &#123; if (seriesModel.get('coordinateSystem') === 'parallel') &#123; var parallelModel = ecModel.queryComponents(&#123; mainType: 'parallel', index: seriesModel.get('parallelIndex'), id: seriesModel.get('parallelId') &#125;)[0]; seriesModel.coordinateSystem = parallelModel.coordinateSystem; &#125; &#125;); return coordSysList;&#125;CoordinateSystem.register('parallel', &#123;create: create&#125;); geo 地理坐标系geo.jsgeo.js中注册了geoToggleSelect、geoSelect、geoUnSelect等action GeoModeGeoModel通过extend方法扩展自Component Model，重写了defaultOption属性以及init、optionUpdated方法，并定义了getRegionModel、getFormattedLabel、setZoom以及setCenter方法。 geoCreatorgeoCreator用于创建Geo 地理坐标系 GeoViewGeoView通过extendComponentView扩展自Compnent View，重写了init、render以及dispose方法，主要代码如下： 123456789101112131415init: function (ecModel, api) &#123; var mapDraw = new MapDraw(api, true); this._mapDraw = mapDraw; this.group.add(mapDraw.group);&#125;,render: function (geoModel, ecModel, api, payload) &#123; ... var mapDraw = this._mapDraw; if (geoModel.get('show')) &#123; mapDraw.draw(geoModel, ecModel, api, this, payload); &#125; ...&#125;, MapDrawMapDraw， 主要绘制代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283draw: function (mapOrGeoModel, ecModel, api, fromView, payload) &#123; ... // 渲染背景 this._updateBackground(geo); ... zrUtil.each(geo.regions, function (region) &#123; var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new graphic.Group()); var compoundPath = new graphic.CompoundPath(&#123; shape: &#123; paths: [] &#125; &#125;); regionGroup.add(compoundPath); ... zrUtil.each(region.geometries, function (geometry) &#123; // 仅支持polygon if (geometry.type !== 'polygon') &#123; return; &#125; compoundPath.shape.paths.push(new graphic.Polygon(&#123; shape: &#123; points: geometry.exterior &#125; &#125;)); for (var i = 0; i &lt; (geometry.interiors ? geometry.interiors.length : 0); i++) &#123; compoundPath.shape.paths.push(new graphic.Polygon(&#123; shape: &#123; points: geometry.interiors[i] &#125; &#125;)); &#125; &#125;); compoundPath.setStyle(itemStyle); compoundPath.style.strokeNoScale = true; compoundPath.culling = true; // Label ... if ( (isGeo || isDataNaN &amp;&amp; (showLabel || hoverShowLabel)) || (itemLayout &amp;&amp; itemLayout.showLabel) ) &#123; ... var textEl = new graphic.Text(&#123; position: region.center.slice(), scale: [1 / scale[0], 1 / scale[1]], z2: 10, silent: true &#125;); graphic.setLabelStyle( textEl.style, textEl.hoverStyle = &#123;&#125;, labelModel, hoverLabelModel, &#123; labelFetcher: labelFetcher, labelDataIndex: query, defaultText: region.name, useInsideStyle: false &#125;, &#123; textAlign: 'center', textVerticalAlign: 'middle' &#125; ); regionGroup.add(textEl); &#125; ... var groupRegions = regionGroup.__regions || (regionGroup.__regions = []); groupRegions.push(region); ... regionsGroup.add(regionGroup); &#125;); // 绑定pan、zoom等事件处理器 this._updateController(mapOrGeoModel, ecModel, api); updateMapSelectHandler(this, mapOrGeoModel, regionsGroup, api, fromView); updateMapSelected(mapOrGeoModel, regionsGroup);&#125; geoRoamgeoRoam中注册了geoRoam api，trigger中调用了geoModel的setCenter及setZoom方法来更新视图。 Calendar 日历坐标系calendar.jscalendar.js创建日历坐标系 CalendarModelCalendarModel通过extend方法扩展自Component Model，重写了defaultOption属性以及init、mergeOption方法。 CalendarViewCalendarView通过extendComponentView扩展自Component View，重写了render方法，主要代码如下： 1234567891011121314151617render: function (calendarModel, ecModel, api) &#123; var group = this.group; group.removeAll(); var coordSys = calendarModel.coordinateSystem; var rangeData = coordSys.getRangeInfo(); var orient = coordSys.getOrient(); // 通过graphic.Rect来绘制day rect this._renderDayRect(calendarModel, rangeData, group); // 通过graphic.Polyline绘制分割线 this._renderLines(calendarModel, rangeData, orient, group); // 通过graphic.Text绘制year label this._renderYearText(calendarModel, rangeData, orient, group); // 通过graphic.Text绘制month label this._renderMonthText(calendarModel, orient, group); // 通过graphic.Text绘制week label this._renderWeekText(calendarModel, rangeData, orient, group);&#125; 问题在解读的过程中，我们需要带着问题去思考源码的实现，在这里我们来解决echarts是如何渲染展示坐标轴上的label数据这个问题。 存储首先考虑label data的存储过程，以直角坐标系为🌰，data存储的调用链如下所示： echarts.setOption() Global.setOption() Global.mergeOption() Component.optionUpdated() （Model） AxisModelCreator.optionUpdated()，将OrdinalMeta.createByAxisModel()返回的数据保存在this.__ordinalMeta中 OrdinalMeta.createByAxisModel()，主要代码如下： 123456789101112OrdinalMeta.createByAxisModel = function (axisModel) &#123; var option = axisModel.option; var data = option.data; var categories = data &amp;&amp; map(data, getName); return new OrdinalMeta(&#123; categories: categories, needCollect: !categories, // deduplication is default in axis. deduplication: option.dedplication !== false &#125;);&#125;; Grid.js中通过： 123456var axis = new Axis2D( axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition); 创建坐标轴，createScaleByModel方法获取保存在this.__ordinalMeta属性中的数据，并返回OrdinalScale对象，createScaleByModel方法主要代码如下所示： 1234567891011121314151617181920export function createScaleByModel(model, axisType) &#123; axisType = axisType || model.get('type'); if (axisType) &#123; switch (axisType) &#123; // Buildin scale case 'category': return new OrdinalScale( model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity] ); case 'value': return new IntervalScale(); // Extended scale, like time and log default: return (Scale.getClass(axisType) || IntervalScale).create(model); &#125; &#125;&#125; Grid创建坐标轴时将返回的OrdinalScale对象数据作为scale属性保存在axis中，主要代码如下： 12345678var Axis2D = function (dim, scale, coordExtent, axisType, position) &#123; Axis.call(this, dim, scale, coordExtent);&#125;var Axis = function (dim, scale, extent) &#123; ... this.scale = scale; ...&#125;; 获取获取 AxisBuilder axisTickLabel() AxisBuilder buildAxisLabel() labels = axis.getViewLabels() =&gt; coord/Axis.js getViewLabels() 调用createAxisLabels()，返回result.labels axisTickLabelBuilder createAxisLabels() 123456export function createAxisLabels(axis) &#123; // Only ordinal scale support tick interval return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);&#125; axisTickLabelBuilder makeCategoryLabels() 12345678function makeCategoryLabels(axis) &#123; var labelModel = axis.getLabelModel(); var result = makeCategoryLabelsActually(axis, labelModel); return (!labelModel.get('show') || axis.scale.isBlank()) ? &#123;labels: [], labelCategoryInterval: result.labelCategoryInterval&#125; : result;&#125; axisTickLabelBuilder makeCategoryLabelsActually() axisTickLabelBuilder makeLabelsByCustomizedCategoryInterval() 12345678910111213141516171819202122function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) &#123; // axis.scale是我们保存的OrdinalScale对象数据 var ordinalScale = axis.scale; var labelFormatter = makeLabelFormatter(axis); var result = []; zrUtil.each(ordinalScale.getTicks(), function (tickValue) &#123; var rawLabel = ordinalScale.getLabel(tickValue); if (categoryInterval(tickValue, rawLabel)) &#123; result.push(onlyTick ? tickValue : &#123; formattedLabel: labelFormatter(tickValue), rawLabel: rawLabel, tickValue: tickValue &#125; ); &#125; &#125;); return result;&#125; 渲染AxisBuilder通过axis.getViewLabels()获取labels数据后通过graphic.Text进行渲染，通过graphic.setStyle设置文本样式，主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637each(labels, function (labelItem, index) &#123; ... var textEl = new graphic.Text(&#123; // Id for animation anid: 'label_' + tickValue, position: pos, rotation: labelLayout.rotation, silent: silent, z2: 10 &#125;); graphic.setTextStyle(textEl.style, itemLabelModel, &#123; text: formattedLabel, textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign, textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign, textFill: typeof textColor === 'function' ? textColor( axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index ) : textColor &#125;); ... labelEls.push(textEl); axisBuilder.group.add(textEl); textEl.decomposeTransform();&#125;); 总结这篇博文很大，简单介绍了title、legend、axisPointer、坐标系以及坐标轴等组件的渲染细节，也探讨了坐标轴上label 数据的存储、获取以及渲染的过程。 希望能够跟小伙伴们一起进步呀！继续加油！！]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts源码解读《二》：echarts源码概要分析]]></title>
    <url>%2F2019%2F05%2F21%2Fecharts-2%2F</url>
    <content type="text"><![CDATA[继解读完zrender源码之后，我们便开始进入echarts源码解读，echarts是在zrender基础上进行开发的，在这篇博文中，我将会分析在使用echarts时，echarts的渲染过程，接下来系列博文中我将从echarts的Component以及View进行解读echarts如何实现图表绘制。 希望能够一起努力学习呀！！加油！！ 前言我们首先来看一个简单的echarts折线图Demo： 123456789101112131415const echartsInstance = echarts.init(document.getElementById("main"))const option = &#123; xAxis: &#123; type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] &#125;, yAxis: &#123; type: 'value' &#125;, series: [&#123; data: [820, 932, 901, 934, 1290, 1330, 1320], type: 'line' &#125;]&#125;;echartsInstance.setOption(option) 效果图如下： 上述代码，使用echarts实现了简单的折线图，那么echarts是如何根据用户设定的option进行图表绘制的呢？这也是我们今天需要探讨的问题。 Echarts解读echarts.js，定义了我们使用echarts时直接调用的init、setOption等方法。 初始化echarts实例在echarts.js文件中通过export init方法提供用户初始化echarts实例的接口，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748export function init(dom, theme, opts) &#123; if (__DEV__) &#123; // Check version if ((zrender.version.replace('.', '') - 0) &lt; (dependencies.zrender.replace('.', '') - 0)) &#123; throw new Error( 'zrender/src ' + zrender.version + ' is too old for ECharts ' + version + '. Current version need ZRender ' + dependencies.zrender + '+' ); &#125; if (!dom) &#123; throw new Error('Initialize failed: invalid dom.'); &#125; &#125; // 判断该DOM结构是否已经存在绑定的echarts实例 var existInstance = getInstanceByDom(dom); if (existInstance) &#123; if (__DEV__) &#123; console.warn('There is a chart instance already initialized on the dom.'); &#125; return existInstance; &#125; // 需要DOM结构设定特定的width以及height值 if (__DEV__) &#123; if (zrUtil.isDom(dom) &amp;&amp; dom.nodeName.toUpperCase() !== 'CANVAS' &amp;&amp; ( (!dom.clientWidth &amp;&amp; (!opts || opts.width == null)) || (!dom.clientHeight &amp;&amp; (!opts || opts.height == null)) ) ) &#123; console.warn('Can\'t get dom width or height'); &#125; &#125; // 新建Echarts实例 var chart = new ECharts(dom, theme, opts); chart.id = 'ec_' + idBase++; instances[chart.id] = chart; modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id); enableConnect(chart); return chart;&#125; ##Echarts对象 Echarts对象属性包括： this._zr(Zrender实例) this._dom(DOM) this._theme(主题) this._chartsViews&amp;this._chartsMap(保存View数据) this._componentsViews&amp;this._componentsMap(保存component数据) this._api(对外API数据) this._model(该echarts实例信息) … Echarts对象方法包括： getDom()：获取当前实例所挂载的DOM信息 getZr()：获取zrender实例 setOption()：设置echarts option（后续将着重讲解） setTheme()：设置echarts主题 getModel()：获取echarts实例 getOption()：获取option信息 getWidth()：this._zr.getWidth() =&gt; 通过zrender实例返回zrender中painter画布的大小 getHeight()：同getWidth() getRenderedCanvas()：this._zr.painter.getRenderedCanvas() =&gt; 获取画布中渲染的canvas元素 dispatchAction(): 触发action（后续将着重讲解） dispose()：销毁echarts实例 … setOptionsetOption()方法为用户使用echarts最直接的接口方法，用户通过setOption方法能够将设置好的option绑定至echarts图表中进行显示，那么echarts内部又是如何根据用户设定的option进行图表渲染的呢？ 首先，我们来分析Echarts中最基本的元素Model、OptionManager以及全局Model OptionManagerOptionManager为option管理器，对option进行了管理与处理，定义了setOption、mountOption等方法，包括对原生option的处理，原生option格式如下： 123456789101112131415161718192021222324252627282930var option = &#123; baseOption: &#123; title: &#123;...&#125;, legend: &#123;...&#125;, series: [ &#123;data: [...]&#125;, &#123;data: [...]&#125;, ... ] &#125;, timeline: &#123;...&#125;, options: [ &#123;title: &#123;...&#125;, series: &#123;data: [...]&#125;&#125;, &#123;title: &#123;...&#125;, series: &#123;data: [...]&#125;&#125;, ... ], media: [ &#123; query: &#123;maxWidth: 320&#125;, option: &#123;series: &#123;x: 20&#125;, visualMap: &#123;show: false&#125;&#125; &#125;, &#123; query: &#123;minWidth: 320, maxWidth: 720&#125;, option: &#123;series: &#123;x: 500&#125;, visualMap: &#123;show: true&#125;&#125; &#125;, &#123; option: &#123;series: &#123;x: 1200&#125;, visualMap: &#123;show: true&#125;&#125; &#125; ]&#125;; ModelModel是Echarts中最基本的元素，其定义了mergeOption等方法，混合了LineStyle、AraeStyle、ItemStyle以及TextStyle。是Component（后续介绍）以及GlobalModel等元素的基类。 GlobalModelGlobalModel扩展自Model，GlobalModel中定义了init方法，要求在初始化GloblaModel对象实例时需要传递OptionManager实例作为构造方法的参数，GlobalModel中定义了查找component、series(Views)，管理option等方法。 setOption()：通过optionManager.setOption()实现 resetOption()：通过optionManager.mountOption()实现 重写mergeOption() getComponent()：通过component的mainType获取component queryComponents()：除mainType外，将id、index、name也作为查询component的条件进行component的检索 findComponents()：与queryComponents类似，但echarts源码中有注释此方法更方便于内部使用 eachComponent()：遍历component getSeriesByName()：通过series name获取series getSeriesByIndex()：通过seriesIndex获取series getSeriesByType()：通过series subType获取series getSeries()：获取series数据 eachSeries()：遍历series filterSeries()：根据条件过滤series setOption调用后echarts操作流程回归setOption方法的调用，echarts.js的setOption方法的主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637echartsProto.setOption = function (option, notMerge, lazyUpdate) &#123; if (__DEV__) &#123; assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.'); &#125; var silent; if (isObject(notMerge)) &#123; lazyUpdate = notMerge.lazyUpdate; silent = notMerge.silent; notMerge = notMerge.notMerge; &#125; this[IN_MAIN_PROCESS] = true; if (!this._model || notMerge) &#123; var optionManager = new OptionManager(this._api); var theme = this._theme; // 初始化model var ecModel = this._model = new GlobalModel(null, null, theme, optionManager); ecModel.scheduler = this._scheduler; ecModel.init(null, null, theme, optionManager); &#125; // 调用GlobalModel中的setOption方法 this._model.setOption(option, optionPreprocessorFuncs); if (lazyUpdate) &#123; this[OPTION_UPDATED] = &#123;silent: silent&#125;; this[IN_MAIN_PROCESS] = false; &#125; else &#123; // 准备数据 prepare(this); // 更新视图 updateMethods.update.call(this); ... &#125;&#125;; 在调用globalModel.setOption方法之后，echarts通过调用 1updateMethods.update.call(this); 进行视图更新。 update()方法中调用了render方法进行视图渲染，render方法主要代码如下： 1234567891011121314151617function render(ecIns, ecModel, api, payload) &#123; renderComponents(ecIns, ecModel, api, payload); each(ecIns._chartsViews, function (chart) &#123; chart.__alive = false; &#125;); renderSeries(ecIns, ecModel, api, payload); // Remove groups of unrendered charts each(ecIns._chartsViews, function (chart) &#123; if (!chart.__alive) &#123; chart.remove(ecModel, api); &#125; &#125;);&#125; render方法分为renderComponents（渲染Component）以及renderSeries（渲染series）两大部分， renderComponents方法中通过each遍历调用component下的render方法 renderSeries方法在echarts3.0中也是通过each遍历调用series下的render方法，在4.0版本之后，便将控制渲染的逻辑交给了scheduler调度器进行处理，通过调用charts中的reset方法进而调用series下的render方法，主要代码如下： 1234567891011121314151617181920212223242526272829303132333435function renderTaskReset(context) &#123; var seriesModel = context.model; var ecModel = context.ecModel; var api = context.api; var payload = context.payload; // ???! remove updateView updateVisual var progressiveRender = seriesModel.pipelineContext.progressiveRender; var view = context.view; var updateMethod = payload &amp;&amp; inner(payload).updateMethod; var methodName = progressiveRender ? 'incrementalPrepareRender' : (updateMethod &amp;&amp; view[updateMethod]) ? updateMethod // `appendData` is also supported when data amount // is less than progressive threshold. : 'render'; if (methodName !== 'render') &#123; view[methodName](seriesModel, ecModel, api, payload); &#125; return progressMethodMap[methodName];&#125;var progressMethodMap = &#123; ... render: &#123; forceFirstProgress: true, progress: function (params, context) &#123; context.view.render( context.model, context.ecModel, context.api, context.payload ); &#125; &#125;&#125;; dispatchAction我们在使用echarts的过程中，经常会需要使用echarts对外提供的一些api，如： 12345echartsInstance.dispatchAction(&#123; type: 'updateAxisPointer', x: 20, y: 30&#125;); 那么echarts是怎么对这些api进行处理的呢？ 能够通过dispatchAction使用的api，首先必须通过registerAction注册api，举updateAxisPointer的🌰，注册dataZoom api的主要代码如下： 12345echarts.registerAction(&#123; type: 'updateAxisPointer', event: 'updateAxisPointer', update: ':updateAxisPointer'&#125;, axisTrigger); registerAction主要代码如下： 123456789101112131415161718192021222324export function registerAction(actionInfo, eventName, action) &#123; // 参数处理：将传递过来的trigger作为action进行保存 if (typeof eventName === 'function') &#123; action = eventName; eventName = ''; &#125; var actionType = isObject(actionInfo) ? actionInfo.type : ([actionInfo, actionInfo = &#123; event: eventName &#125;][0]); // Event name is all lowercase actionInfo.event = (actionInfo.event || actionType).toLowerCase(); eventName = actionInfo.event; // Validate action type and event name. assert(ACTION_REG.test(actionType) &amp;&amp; ACTION_REG.test(eventName)); // 将action信息保存至actions if (!actions[actionType]) &#123; actions[actionType] = &#123;action: action, actionInfo: actionInfo&#125;; &#125; eventActionMap[eventName] = actionType;&#125; 还是看updateAxisPointer这个🌰： 12345echartsInstance.dispatchAction(&#123; type: 'updateAxisPointer', x: 20, y: 30&#125;); dispatchAction的主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475echartsProto.dispatchAction = function (payload, opt) &#123; if (!isObject(opt)) &#123; opt = &#123;silent: !!opt&#125;; &#125; if (!actions[payload.type]) &#123; return; &#125; // Avoid dispatch action before setOption. Especially in `connect`. if (!this._model) &#123; return; &#125; // May dispatchAction in rendering procedure if (this[IN_MAIN_PROCESS]) &#123; this._pendingActions.push(payload); return; &#125; // 调用doDispatchAction doDispatchAction.call(this, payload, opt.silent); ...&#125;;function doDispatchAction(payload, silent) &#123; var payloadType = payload.type; var escapeConnect = payload.escapeConnect; // 根据paoload中的type信息，获取actions对应的action数据 var actionWrap = actions[payloadType]; var actionInfo = actionWrap.actionInfo; var cptType = (actionInfo.update || 'update').split(':'); var updateMethod = cptType.pop(); cptType = cptType[0] != null &amp;&amp; parseClassType(cptType[0]); this[IN_MAIN_PROCESS] = true; var payloads = [payload]; var batched = false; // Batch action if (payload.batch) &#123; batched = true; payloads = zrUtil.map(payload.batch, function (item) &#123; item = zrUtil.defaults(zrUtil.extend(&#123;&#125;, item), payload); item.batch = null; return item; &#125;); &#125; var eventObjBatch = []; var eventObj; var isHighDown = payloadType === 'highlight' || payloadType === 'downplay'; each(payloads, function (batchItem) &#123; // Action can specify the event by return it. // 触发action trigger eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside eventObj = eventObj || zrUtil.extend(&#123;&#125;, batchItem); // Convert type to eventType eventObj.type = actionInfo.event || eventObj.type; eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual. if (isHighDown) &#123; // method, payload, mainType, subType updateDirectly(this, updateMethod, batchItem, 'series'); &#125; else if (cptType) &#123; updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub); &#125; &#125;, this); ...&#125; 总结博文到这里就差不多结束了，在此博文中，我对echarts渲染视图的过程进行了简单的分析，并对setOption以及dispatchAction方法的实现过程进行了大致的分析。 接下来的文章将会深入Component以及Series中，解读echarts是如何使用zrender graphic渲染图表的，希望能帮助到大家～一起加油！！]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts源码解读《一》：zrender源码概要分析]]></title>
    <url>%2F2019%2F05%2F20%2Fecharts-1%2F</url>
    <content type="text"><![CDATA[2019年首次发博，不知道大家有没有出去过520呢？？我反正是脚伤了！哭 今天7月份我将入职腾讯，我的工作导师于3月份让我学习可视化，前段时间一直在忙毕设，也就耽搁下来了。 在echarts源码解读系列文章中，我将会记录我学习echarts源码时的过程，并对echarts的基本实现进行大致的解读，写博客是为了能够让自己对echarts有更好的了解，也希望能够通过博客帮助到需要学习解读echarts源码的小伙伴们，一起加油吧！！！ 前言由于echarts是基于zrender进行实现的，所以要解读echarts源码，首先要对zrender有大致的了解，在这篇文章中，我将对zrender的整体结构进行大致的解读。 介绍zrender是canvas的一个类库，也就是说zrender是基于canvas实现的，canvas API可以参考：W3CSchool Canvas 参考手册 在后续的解读中，我们会介绍zrender使用canvas api 的位置及用途。 目录介绍文件夹： animation 动画有关； contain 包含判断； container Group.js 元素组的概念； core 核心代码，包含一些工具（util.js）、事件（event.js）、唯一ID(guid.js)、矩阵运算有关（matrix.js）等； dom HandleProxy.js dom事件有关； graphic 图形有关，shape文件夹下就是各个图形的js文件； mixin 混入模式要混入的函数; tool 工具函数，包括颜色工具(color.js)，path工具(path.js)和转换工具（transformPath.js）; vml IE中的画笔，vml解释 全局的文件： config.js 配置文件 Element.js 元素文件作为zrender最基本的元素 Handle.js C层，控制层 Layer.js 图层管理 Painter.js V层，视图层 Storage.js M层，数据管理层 zrender.js 入口 zrender整体架构zrender采用了MVC封装，M为Model数据层，V为View视图层，C为Controller控制层： Storage(M)：Storage为zrender中的Model层，它主要进行图形数据的增删改查(CRUD)操作； Painter(V)：Painter为zrender中的View层，它主要对canvas元素的生命周期进行管理，渲染视图以及控制更新等。定义了addHover、setBackgroundColor等方法； Handler(C)：Handler为zrender中的Controller层，它主要实现事件交互处理，实现完整dom事件的模拟封装。 图形处于graphic文件夹下，zrender定义了一系列图形，供外界调用，包括圆形、矩形、心形、扇形、多边形、折线等，echarts通过调用zrender定义好的图形，可以很便捷地完成图表渲染。 DisplayableDisplayable.js为Path、Text等的基类，继承自Element，定义了setStyle、useStyle等方法， Text文本，继承自Displayable，调用了helper/text.js中的renderText方法进行绘制。主要代码如下： 12345export function renderText(hostEl, ctx, text, style, rect, prevEl) &#123; style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);&#125; 文本分为富文本以及普通文本进行分别渲染，它们均通过调用canvas的ctx.fillText或ctx.strokeText 等api进行文本渲染，具体实现可以查看helper/text.js文件。 Style图形的样式文件，定义了基本的样式属性，以及样式set、clone以及判断等方法。 Pathpath为图形的基类，继承自Displayable，定义了buildPath、getBoundingRect、setShape等方法，其包含this._style属性即为Style对象实例。 Shapeshape文件下存放着zrender定义的图形文件，扩展自Path。 Circle圆形，通过调用Path.extend方法进行扩展，重写了buildPath方法，buildPath调用了canvas api：ctx.arc进行圆形的绘制，主要实现代码如下： 123456buildPath: function (ctx, shape, inBundle) &#123; if (inBundle) &#123; ctx.moveTo(shape.cx + shape.r, shape.cy); &#125; ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);&#125; Arc弧形，通过调用Path.extend方法进行扩展，重写了buildPath方法，buildPath调用了canvas api：ctx.arc进行弧形的绘制，主要实现代码如下： 1234567891011121314buildPath: function (ctx, shape) &#123; var x = shape.cx; var y = shape.cy; var r = Math.max(shape.r, 0); var startAngle = shape.startAngle; var endAngle = shape.endAngle; var clockwise = shape.clockwise; var unitX = Math.cos(startAngle); var unitY = Math.sin(startAngle); ctx.moveTo(unitX * r + x, unitY * r + y); ctx.arc(x, y, r, startAngle, endAngle, !clockwise);&#125; Heart心形❤️，通过调用Path.extend方法进行扩展，重写了buildPath方法，buildPath调用了canvas api：ctx.bezierCurveTo进行弧形的绘制，主要实现代码如下： 1234567891011121314151617buildPath: function (ctx, shape) &#123; var x = shape.cx; var y = shape.cy; var a = shape.width; var b = shape.height; ctx.moveTo(x, y); ctx.bezierCurveTo( x + a / 2, y - b * 2 / 3, x + a * 2, y + b / 3, x, y + b ); ctx.bezierCurveTo( x - a * 2, y + b / 3, x - a / 2, y - b * 2 / 3, x, y );&#125; bezierCurveTo(控制点1x坐标, 控制点1y坐标, 控制点2x坐标, 控制点2y坐标, 结束点x坐标, 结束点y坐标) 三次被塞尔曲线绘制： P0为开始点，P1为控制点1，P2为控制点2，P3为结束点 取 P0P1 中点M 取 P1P2 中点M’ 取 MM’ 中点P 则 P 为曲线的必经点 具体绘制图如下： 同理，我们可以绘制出左半边心形： Droplet水滴形状💧，通过调用Path.extend方法进行扩展，重写了buildPath方法，buildPath调用了canvas api：ctx.bezierCurveTo进行弧形的绘制，贝塞尔曲线的绘制过程同心形绘制原理，主要实现代码如下： 12345678910111213141516171819202122232425buildPath: function (ctx, shape) &#123; var x = shape.cx; var y = shape.cy; var a = shape.width; var b = shape.height; ctx.moveTo(x, y + a); ctx.bezierCurveTo( x + a, y + a, x + a * 3 / 2, y - a / 3, x, y - b ); ctx.bezierCurveTo( x - a * 3 / 2, y - a / 3, x - a, y + a, x, y + a ); ctx.closePath();&#125; Ellipse椭圆，通过调用Path.extend方法进行扩展，重写了buildPath方法，buildPath调用了canvas api：ctx.bezierCurveTo进行弧形的绘制，贝塞尔曲线的绘制过程同心形绘制原理，主要实现代码如下： 12345678910111213141516buildPath: function (ctx, shape) &#123; var k = 0.5522848; var x = shape.cx; var y = shape.cy; var a = shape.rx; var b = shape.ry; var ox = a * k; // 水平控制点偏移量 var oy = b * k; // 垂直控制点偏移量 // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线 ctx.moveTo(x - a, y); ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b); ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y); ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b); ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y); ctx.closePath();&#125; Sector扇形，通过调用Path.extend方法进行扩展，重写了buildPath方法，buildPath调用了canvas api：ctx.arc以及arc.lineTo进行圆形的绘制，主要实现代码如下： 1234567891011121314151617181920212223242526272829buildPath: function (ctx, shape) &#123; var x = shape.cx; var y = shape.cy; var r0 = Math.max(shape.r0 || 0, 0); var r = Math.max(shape.r, 0); var startAngle = shape.startAngle; var endAngle = shape.endAngle; var clockwise = shape.clockwise; var unitX = Math.cos(startAngle); var unitY = Math.sin(startAngle); ctx.moveTo(unitX * r0 + x, unitY * r0 + y); ctx.lineTo(unitX * r + x, unitY * r + y); ctx.arc(x, y, r, startAngle, endAngle, !clockwise); ctx.lineTo( Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y ); if (r0 !== 0) &#123; ctx.arc(x, y, r0, endAngle, startAngle, clockwise); &#125; ctx.closePath();&#125; zrender还定义了Rect矩形、Isogon正多边形、Line直线、Polygon多边形、Polyline折线、Ring圆环、Rose玫瑰线、Star n角星等图形，其实现过程基本与上述图形上类似，都是基于canvas的lineTo、arc、bezierCurveTo等api进行绘制的，这边就不做一一介绍了。 总结zrender中封装了很多工具，在后续echarts源码解读中，我们可以看到echarts是基于zrender进行开发的。 希望这篇博文能够帮助大家对zrender及其实现的图形有大致的了解～]]></content>
      <categories>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>echarts源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器之后台运行]]></title>
    <url>%2F2018%2F05%2F29%2Fnohup-sh%2F</url>
    <content type="text"><![CDATA[最近在将项目部署到云服务器上，所以也写了好几篇博客，关于在部署项目时遇到的问题，此次我主要是记录如何将项目在后台运行，且不会因为断开与云服务器的连接而被终止，希望能对大家有所帮助～ 前言此篇博客是因为我在项目中使用了&amp;，让项目后台运行能够正常访问后，便使用logout命令断开了与云服务器的连接，断开后再次访问，却发现访问失败了，于是再次连接云服务器，通过jobs查看后台进程，发现刚刚在后台运行的项目已经被终止了。 后台运行进程因为我是运行express项目(example)，所以我先进入example目录，执行： 1vim test.sh 该命令以你在编辑环境中输入的内容(npm start)作为文件内容，在当前目录生成test.sh文件 1nohup ./test.sh &amp; 通过nohup执行该sh文件，则成功将进程放置在后台运行了，你可以看到在当前目录下生成了名为nohup.out的文件 终止进程首先通过执行以下命令查看后台运行的进程号 1netstat -lnp | grep 端口号 在通过执行以下命令来终止进程 1kill -9 进程号 总结很简单但很实用～希望能对大家有所帮助～]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器之代理]]></title>
    <url>%2F2018%2F05%2F28%2Fserver-proxy%2F</url>
    <content type="text"><![CDATA[今天想着要把自己做的那个Demo部署到服务器上，却发现在本地可以正常代理的请求，在经过打包部署后，api请求代理似乎已经失效了。花了很久的时间在解决这个问题，最后特别感谢某修给予的灵感以及学长的耐心解答，为了便于以后更方便地使用，我将之记录下来，也希望能够对大家有所帮助～ 前言在云服务器上，我使用了nginx作为我的web服务器，nginx 作为目前最流行的web服务器之一，可以很方便地实现反向代理。当在一台主机上部署了多个不同的web服务器，并且需要能在80端口同时访问这些web服务器时，可以使用 nginx 的反向代理功能: 用 nginx 在80端口监听所有请求，并依据转发规则(比较常见的是以 URI 来转发)转发到对应的web服务器上。在我的项目中，是因为所需要请求的API位于服务器上的不同端口，为了实现跨域请求，所以需要进行代理。 代理我的服务器域名为qq.qiuruolin.cn 不带URI的代理配置12345678http &#123; server &#123; server_name qq.qiuruolin.cn; location /api/ &#123; proxy_pass http://qq.qiuruolin.cn:3000; &#125; &#125;&#125; 以上的配置会 http://qq.qiuruolin.cn/api 下的请求( GET 和 POST 请求都会转发)转发到 http://qq.qiuruolin.cn:3000/ 需要注意的是，在以上的配置中，http://qq.qiuruolin.cn:3000是没有指定URI的。 如果代理服务器地址中是带有URI的，此URI会替换掉 location 所匹配的URI部分。 如果代理服务器地址中是不带有URI的，则会用完整的请求URL来转发到代理服务器。 带URI的代理配置12345678http &#123; server &#123; server_name qq.qiuruolin.cn; location /api/ &#123; proxy_pass http://qq.qiuruolin.cn:3000/uri/; &#125; &#125;&#125; 举🌰： 不带URIhttp://qq.qiuruolin.cn/api/user/register-&gt; http://qq.qiuruolin.cn:3000/api/user/register 带URIhttp://qq.qiuruolin.cn/api/user/register-&gt; http://qq.qiuruolin.cn:3000/uri/user/register 总结这次在服务器上的代理，开始的时候真的让我感觉到很混乱，以此博客纪念曾经混乱的自己～希望对大家有所帮助～继续努力！！！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之MySQL数据库常用操作]]></title>
    <url>%2F2018%2F05%2F28%2FLinux-mysql%2F</url>
    <content type="text"><![CDATA[因为最近在使用云服务器部署项目，所以也难免要在服务器上使用MySQL，所以就想把MySQL常使用记录下来，以便日后查看并熟悉～也希望能够对大家有所帮助～ 准备首先你需要在云服务器上下载安装MySQL，网上有很多大牛们都写了相关的博客，这里就不再重复啦～注意：MySQL 中每个命令后都要以分号;结尾。 显示数据库show databases;1show databases; Mysql 刚安装完有两个数据库：mysql 和test。mysql 库非常重要，它里面有MySQL 的系统信息，我们改密码和新增用户，实际上就是用这个库中的相关表进行操作。 建库：create database 库名; 例如：创建一个名字位node的库 1create database node; 建表：create table 表名 (字段设定列表); 例如：在刚创建的node库中建立表user, 表中有uid(序号, 自动增长), username(姓名), password(密码), email(邮箱)四个字段 12use node;create table user (uid int(4) auto_increment not null primary key, username varchar(255), password varchar(255), email varchar(255)); 显示数据库中的表show tables;12use node; //打开库show tables; 显示数据表的结构：describe 表名;1describe user; 增加记录例如：增加几条相关记录。 12insert into user(username, password, email) values('qiuqiu', 'qqq', 'qiw@qq.com');insert into user(username, password, email) values('hehe', '123456', 'wywu@qq.com'); 显示表中的记录：可以使用select * from 表名;来查看我们表中的数据 1select * from user; 修改记录例如：将qiuqiu的密码改为123 1update user set password='123' where username='qiuqiu'; 删除记录例如：删除qiuqiu的纪录。 1delete from user where username='qiuqiu'; 删库和删表drop database 库名; drop table 表名; 增加MySQL 用户grant select on 数据库.* to 用户名@登录主机 identified by “密码” 例1、增加一个用户user_1密码为123，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入MySQL ，然后键入以下命令： 1grant select, insert, update, delete on *.* to mailto:user_1@" " Identified by "123"; 备份与恢复备份例如：将上例创建的node库备份到文件back_node中 12# cd /home/data/mysql (进入到库目录)# mysqldump -u root -p –opt node &gt; back_node 恢复1# mysql -u root -p recover_node &lt; back_node 总结为了防止自己以后忘记，所以我在这里记录了一些通过命令而进行的一些常用的MySQL数据库操作，内容很简单，主要是为了便于自己以后查阅，也希望能够对大家有所帮助～]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React之组件生命周期]]></title>
    <url>%2F2018%2F05%2F27%2Freact-life-circle%2F</url>
    <content type="text"><![CDATA[在学习React时，有时候遇到数据更新，而界面却不能及时更新的问题，查了很多资料，大部分原因是因为对React组件的生命周期没有很好地理解，所以特地想把生命周期有关的知识记录下来，便于自己理解和学习，也希望能够对大家有一些帮助～ 前言React组件的生命周期状态可分为三种： Mounting: 已插入真实DOM Updating: 正在被重新渲染 Unmounting: 已移出真实DOM 组件挂载的经典图片： 接下来我将会详细说明一下这几个生命周期的意义 实例化首次调用组件时，有以下方法会被调用（注意顺序，从上到下先后执行）： getDefaultProps()：这个方法是用来设置组件默认的props，组件生命周期只会调用一次。这个方法在对象被创建之前执行，因此不能在方法内调用this.props。 getInitialState()：设置state初始值，在这个方法中你已经可以访问到this.props。 componentWillMount()：该方法会在组件首次渲染之前调用，这个是在render方法调用前可修改state的最后一次机会。 render()：调用render()方法时，首先检查this.props和this.state返回一个子元素，子元素可以是DOM组件或者其他自定义复合控件的虚拟实现 ，如果不想渲染可以返回null或者false。render()方法是很纯净的，这就意味着不要在这个方法里初始化组件的state，每次执行时返回相同的值，不会读写DOM或者与服务器交互。 componentDidMount()：在首次真实的DOM渲染后调用（仅此一次），只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 存在期实例化后，当props或者state发生变化时，下面方法依次被调用： componentWillReceiveProps()：在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate()：返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 可以在你确认不需要更新组件时使用。默认返回true。 componentWillUpdate()：在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 123void componentWillUpdate( object nextProps, object nextState) 在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中，紧接着这个函数，就会调用render()来更新界面了 render()：与实例化期相同 componentDidUpdate()：在组件完成更新后立即调用。在初始化时不会被调用。 销毁期销毁阶段，只有一个函数被调用： componentWillUnmount()：在组件从 DOM 中移除的时候立刻被调用。在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等 总结这篇博客查阅了很多网上大牛们的博客，结合了菜鸟教程上的文档，希望自己能够对React组件的生命周期有更好地理解，前路漫漫～一起加油哦～]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js 生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于React及Express项目的打包部署]]></title>
    <url>%2F2018%2F05%2F24%2Freact-express%2F</url>
    <content type="text"><![CDATA[最近为了7月份实习更加顺手，所以在学习公司比较流行的React，之前对Vue有过了解并做过项目练手，所以对React的思想也是比较好理解的，为了进一步提升自己，以及为后续学习使用Node搭建服务器端，我特地去腾讯云上买了自己的云服务器～这篇博客主要是介绍一下，一个使用React做前端，Express做后端的项目如何打包部署在云服务器上，希望对大家有所帮助～ 云服务器准备首先你需要有个已经备案过的域名，然后需要买个云服务器，将你的域名解析到服务器地址，我解析的域名为qq.qiuruolin.cn，具体步骤大家可以Google一下～因为我使用的是Mac，所以首先我在终端中使用ssh连接云服务器，配置nginx，并通过service nginx start启动服务，下载安装git，因为我们后面需要使用git来克隆express后端项目 React前端首先使用create-react-app创建React项目，使用npm install安装依赖包，通过npm start运行，成功后就可以开始编写你自己的项目了可以在项目中使用ajax去请求后端数据，但是要注意解决跨域问题：在package.json中添加12345"proxy": &#123; "/api": &#123; "target": "http://127.0.0.1: 3001" &#125;&#125;， http://127.0.0.1: 3000换成你需要代理的域名，最好是使用IP地址，上面的配置就是将本地所有以/api开头的请求转发到你配置的地址上在这个项目中，我们需要把请求代理到我们云服务器的express后端上 写完代码之后，接下来就是打包部署到云服务器上的工作了首先通过npm build对项目进行打包，生成名为build的文件夹将build文件夹通过scp命令上传到云服务器上注意：要上传至服务器的根目录下，默认为/root（可以在/etc/nginx/nginx.conf中配置）上传后通过service nginx restart重启，这时你试着可以访问qq.qiuruolin.cn/build/index.html，若页面出现则表示部署成功。 Express后端通过express来新创建一个express项目，前提是需要你全局安装express，新建项目之后使用npm install安装依赖包，使用npm start运行，出现Express欢迎页则说明项目创建成功了接着，你可以先编写一个简单的请求进行测试创建仓库配置git，并将项目push到git上连接云服务器，我们使用git克隆项目，并使用npm install安装依赖項，使用npm start，访问你解析的域名:3000/你的api，若成功则你的后端项目就在云服务器上部署成功了你可以使用npm start &amp;将项目放置后台运行，使用jobs查看运行的进程，fg和bg将进程在前后台切换 总结到这一步，整个项目基本都配置完了，其实这个并不是花时间最多的地方，花时间探索的是，我如何去构建一个完整前后端俱全的项目，学习的路上会遇到很多迷茫，只要积极探索，不气馁，不放弃，不骄躁，相信大家可以变得更好！希望对大家有所帮助～]]></content>
      <categories>
        <category>React.js</category>
      </categories>
      <tags>
        <tag>React.js Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记腾讯的一次前端面试经历（共四面，已拿实习Offer）]]></title>
    <url>%2F2018%2F05%2F23%2Finterview-experiences%2F</url>
    <content type="text"><![CDATA[因为我们专业要求大四一学年的实习，所以这段时间也就自然在做春招内推的各项准备，从开始找实习到获得腾讯实习Offer大约历经了一个多月的时间，这一个多月来压力很大，也很怕找不到好的实习，所以这个月也刷了很多大佬的面经，获得了很多帮助，也增长了很多前端知识。是在清明节前一天收到腾讯HR小哥哥的Offer电话，时隔这么久才想起要把腾讯面试的一些问题写成博客，或许会对大家有所帮助。 前言从准备春招以来，一共面试的公司有三家：京东、腾讯和CVTE，京东情况比较特殊应该不算是正式的春招，京东面试时问了很多有关CSS的知识，比如margin塌陷、CSS3新特性、背景透明的实现方法、清除浮动的方法以及垂直居中的方法等CVTE是唯一一个现场面试的，很多面试题目都很类似，印象最深的是三道手撕代码题， 第一道是写一程序遍历一个DOM结构， 第二道是算法题，要求给你一个字符串”I love dog”变成”dog love I” 第三道是实现某个种栅格布局 一面一面大概面了一个多小时，问了很多基础知识，涉及的方面也很广首先介绍实习经历，balabala讲了一下项目经验，然后大概说了一下什么时候开始学习前端，以下是我记得的一些问题： 1. 怎么使用dns缓存做优化DNS的优化， 当然是尽可能少的造成DNS查询开销，当用户在浏览器的地址栏中输入网址时，浏览器会首先通过访问的域名来定位到IP (DNS) 从而找到去哪里获取资源，浏览器会按浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;递归搜索依次进行查询，DNS优化就是需要我们尽可能少的域名解析。DNS预取就是在浏览器加载网页时， 对网页中的或者的href属性中的域名进行后台的预解析， 并且将解析结果缓存在浏览器端， 当用户在真正点击链接时， 省去在当下的DNS解析消耗， 把这个消耗过程转嫁到用户无法感知的浏览过程中去。我们可以通过以下方法来打开DNS预取： 可以通过用meta信息来告知浏览器， 当前页面要做DNS预取: 可以使用link标签来强制对DNS做预取: 2. ES6了解哪些？ES6中有很多知识点，比如Promise、Generator、箭头函数等，建议大家多熟悉一下 3. 知道哪些数组方法最常用的有方法有： join()——将数组元素组成一个字符串 push()和pop()——类似栈的操作 shift()和unshift()——删除数组第一项／添加元素至数组第一项 sort()——对数组进行排序 reverse()——反转数组項的顺序 concat() ——将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 slice()——返回从原数组中指定开始下标到结束下标之间的项组成的新数组。 splice()——很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。 indexOf()和lastIndexOf()——从数组的开头（位置 0）开始向后查找／从数组的末尾开始向前查找。 forEach()——对数组进行遍历循环，对数组中的每一项运行给定函数。 map()——对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 filter()——“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 every()——判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 some()——判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 reduce()和 reduceRight()——从数组的第一项开始，逐个遍历到最后／从数组的最后一项开始，向前遍历到第一项。两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 4. 将字符串转换为数字 parseInt()和parseFloat()，要注意方法的第二个参数，表示使用的基模式（二进制(2)、八进制(8)、十进制(10)、十六进制(16)） 强制类型转换：Number(value) js弱类型转换（不推荐）：var x = str-0; x = x*1; 5. cdn缓存的原理 推荐看CDN技术详解这篇博客，博主对于CDN的相关知识点确实讲解的比较到位了 6. 事件捕获和事件冒泡贴一张图大家感受一下 7. 阻止冒泡事件和默认事件event.stopPropagation()：这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开event.preventDefault()：这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；IE下：window.event.cancelBubble = true;//停止冒泡window.event.returnValue = false;//阻止事件的默认行为 8. 前端优化Web前端性能优化总结 9. CSS文件为什么要放在文档头部？js文件为什么放在底部？10. HTML5引入的新特性11. HTTP缓存机制彻底弄懂HTTP缓存机制及原理 12. cache-control的属性（no-cache和no-store的区别）浏览器缓存详解:expires,cache-control,last-modified,etag详细说明Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。Cache-Control: no-store：这个才是响应不被缓存的意思。 13. Http状态码（403、304是什么）常见的HTTP状态码(HTTP Status Code)说明 14. jsonp的实现原理简单透彻理解JSONP原理及使用 15. xss、cors？以及如何防范？sql注入？？ XSS：跨站脚本攻击它允许用户将恶意代码植入到提供给其他用户使用的页面中，可以简单的理解为一种javascript代码注入。XSS的防御措施： 过滤转义输入输出 避免使用eval、new Function等执行字符串的方法，除非确定字符串和用户输入无关 使用cookie的httpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的 使用innerHTML、document.write的时候，如果数据是用户输入的，那么需要对象关键字符进行过滤与转义 CSRF：跨站请求伪造其实就是网站中的一些提交行为，被黑客利用，在你访问黑客的网站的时候进行操作，会被操作到其他网站上CSRF防御措施： 检测http referer是否是同域名 避免登录的session长时间存储在客户端中 关键请求使用验证码或者token机制 16. setTimeout的执行原理以及什么时候回调函数会加入到任务队列中？与Promise执行机制上有什么不同？JS：事件循环机制、调用栈以及任务队列 17. postMessage的实现，跨域请求的实现八种方式实现跨域请求前端常见跨域解决方案 18. Web Storage的方法（setItem、getItem、removeItem、clear）HTML5本地存储之Web Storage篇 19. 页面重绘和重排，如何减少重排？如何减少对DOM的操作JS对DOM的操作优化法则 20. CSS有哪些选择器？优先级21. 如何添加元素，创建元素（除了createElement和createTextNode还有什么）js创建dom节点之最容易被忽略的createDocumentFragment()方法 22. 怎么选取DOM元素（DOM元素选择的方式）JS选取DOM元素的方法 23. call和apply的区别，bind方法javascript中call()、apply()、bind()的用法终于理解bind方法 24. 块级作用域及其应用场景块级作用域 25. let和var的区别（除了变量提升，还有什么）js中let和var定义变量的区别 26. HTTP2.0的特性HTTP 2.0带来哪些新特性 27. 对象复制（深浅拷贝）Object.assignjavascript对象的深浅拷贝浅析 28. innerHTML和outerHTML29. null和undefined的区别 undefined一般用于抛出异常 typeof null =&gt; object; typeof undefined =&gt; undefined Number(null) = 0; Number(undefined) = NaN 正确使用null，可以有效清除引用，用于垃圾回收 null instanceof Object // false 30. https为什么是安全的？SSL是怎么加密的？详解HTTPS是如何确保安全性的 31. 缓存过期时间的设置（除了expires和max-age还有什么）32. 什么是同源策略？怎样属于同源（同协议同域名同端口）33. vue-router对history的操作34. 对json方法的了解（son.stringify和json.parseJSON）35. 还有什么要问我的吗？二面二面时间不长，大概20分钟左右，因为是晚上下课后打来的电话，所以问的内容也不算多 1. http协议的请求头内容HTTP请求行、请求头、请求体详解 2. cache-control 是什么？以及它的取值有哪些3. http1.1有哪些不足HTTP/2.0 相比1.0有哪些重大改进？ 4. 快速排序的思想排序算法可以参考我上一篇博客算法之排序 5. 事件捕获和事件冒泡6. 怎么阻止事件冒泡？怎么在事件捕获阶段阻止事件冒泡7. 对ES6的了解我提了Promise，后来就一直问的是Promise的知识：Promise有哪几种状态(pending, fulfilled, rejected)，状态之间的转换new Promise(function(){ resolve();}).then(function(){ //问此处的then可不可以被执行})事件监听器在事件点击之后监听是无效的，Promise和它有什么区别？promise介绍–基础篇 8. 如果有一个箱子里有100个苹果，一次可以拿1或2个，问有多少种方法将100个苹果移到另一个箱子中三面三面是对我平时如何学习前端以及对我的学习兴趣做了进一步的了解 1. 平时是如何学习的2. 如何进行沟通，有没有自己的一套沟通方案3. 有没有好奇心？4. 平时写代码的时间有多少四面(HR面)四面就是腾讯云招聘经理来的面试电话，也就是HR面，了解了一下个人的发展方向，家庭情况之类的我觉得HR面其实也需要好好准备一下的，第一次HR面是在CVTE，挂了CVTE之后就对HR面有点阴影了，十分感谢我的老大在腾讯HR面前一天晚上顶着疲惫不堪的身心还特地打电话给我，教我如何回答得更理想～拿到口头Offer后就回家过清明节了～ 总结其实能够拿到腾讯实习Offer很大一部分是因为运气，希望小菜鸟的我和腾讯的缘分一直走下去～实习加油！！啰啰嗦嗦说了很多，希望对大家有所帮助！]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之排序]]></title>
    <url>%2F2018%2F02%2F17%2Falgorithm-sort%2F</url>
    <content type="text"><![CDATA[算法的学习总是断断续续的，总算看完了排序算法这一章节的内容，排序思想大概都已经能理解了，奈何编程水平恐怕不是很高，部分算法仍旧不能自己独立的去实现～怕是要继续增强自己的编程能力了～此篇博文主要是记录与排序算法相关的知识点，如果在某些地方表述不正确的，还希望大家能够指出，共同进步～ 基于比较思想的排序算法首先为了减少代码的重复性，抽离出实现代码中经常使用到的交换函数：12345public static void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp;&#125; 冒泡排序 1234567891011public int[] bubbleSort(int[] A, int n) &#123; //n表示数组长度 // write code here for(int i = n - 1; i &gt;= 0; i--)&#123; for(int j = 0; j &lt; i; j++)&#123; if(A[j] &gt; A[j + 1])&#123; swap(A, j, j + 1); &#125; &#125; &#125; return A;&#125; 主要思想：使用两层嵌套循环比较，内层循环比较相邻的元素，如果第一个比第二个大，则交换两个元素。一次内循环比较结束后，最大的元素将会被交换到n-1的位置上，缩小范围继续执行外循环，依次会将剩下元素中相对最大的元素置换到n-2、n-3 … 1的位置上，数组排序完成。冒泡排序因为使用了两层嵌套循环，所以其时间复杂度为O(N^2)。举个简单的例子：首先考察n-1范围比较相邻两个元素之间的大小，发现6比3大，则交换两个元素继续比较相邻元素经过一轮循环比较相邻元素后，最大的元素会被交换到n-1位置上接着将范围缩小至n-2重复上述比较过程，数组排序完毕。 选择排序123456789101112public int[] selectionSort(int[] A, int n) &#123; // write code here int index = 0; for(int i = 0; i &lt; n - 1; i++)&#123; index = i; for(int j = i + 1; j &lt; n; j++)&#123; index = A[index] &gt; A[j]? j : index; &#125; swap(A, i, index); &#125; return A;&#125; 主要思想：选择排序使用两层嵌套循环比较，外层循环记录结果元素需要放置的位置，内层循环选择剩下元素中相对最小的元素。经过一次内循环后选择出最小的元素与i为0位置上的元素交换，即作为第一个元素，一次进行下去，剩下元素中相对较小的元素就放在了1,2…n-1位置上，数组排序完成。选择排序因为使用了两层嵌套循环，所以其时间复杂度也为O(N^2)。举个简单的🌰：首先考察0～n-1范围在0～n-1范围内选出最小的元素，与数组中第一个元素交换继续考察1～n-1范围，在1～n-1范围内选出最小的元素，与数组中第二个元素交换重复上述比较过程，数组排序完毕。 插入排序1234567891011121314151617 public int[] insertionSort(int[] A, int n) &#123; // write code here int index = 0; for(int i = 1; i &lt; n; i++)&#123; index = i; while(index &gt; 0)&#123; if(A[index] &lt; A[index - 1])&#123; swap(A, index, index - 1); index--; &#125; else&#123; break; &#125; &#125; &#125; return A;&#125; 主要思想：使用两层嵌套循环比较，将数组中的每一个元素进行向前比较，如果该元素小于前一个元素，则两个元素交换位置index–，继续与前一个元素比较，知道index=0，该元素放在大小合适的位置上。依次循环比较数组中的每一个元素，直至i=n-1，数组排序完成。举个简单的🌰：首先考察数组的第二个元素，与第一个元素进行比较，5比6小，则交换两个元素接着考察数组中的第三个元素，先与第二个元素进行比较，小于则交换两个元素，接着再与第一个元素比较，小于则再交换两个元素。根据此过程依次考察数组中的所有元素，数组排序完毕。插入排序时间复杂度为O(N^2)。 归并排序12345678910111213141516171819202122232425262728293031323334353637383940public int[] mergeSort(int[] A, int n) &#123; // write code here if (A == null || n &lt; 2) &#123; return null; &#125; process(A, 0, n - 1); return A;&#125;public static void process(int[] arr, int left, int right) &#123; if (left == right) &#123; return; &#125; int mid = (left + right) / 2; process(arr, left, mid); process(arr, mid + 1, right); merge(arr, left, mid, right);&#125;public static void merge(int[] arr, int left, int mid, int right) &#123; int[] help = new int[right - left + 1]; int l = left; int r = mid + 1; int index = 0; while (l &lt;= mid &amp;&amp; r &lt;= right) &#123; if (arr[l] &lt;= arr[r]) &#123; help[index++] = arr[l++]; &#125; else &#123; help[index++] = arr[r++]; &#125; &#125; while (l &lt;= mid) &#123; help[index++] = arr[l++]; &#125; while (r &lt;= right) &#123; help[index++] = arr[r++]; &#125; for (int i = 0; i &lt; help.length; i++) &#123; arr[left + i] = help[i]; &#125;&#125; 主要思想：首先将数组划分为单位长度为1的有序区间，然后把相邻的长度为1的有序区间进行合并，得到最大长度为2的有序区间，接下来再把相邻长度的有序区间合并得到长度为4的有序区间，依次这样进行下去，直到让数组中所有的数合并为一个有序区间，数组排序完毕，过程结束。归并排序的过程：根据此过程直到让数组中所有的数合并为一个有序区间，数组排序完毕。归并排序时间复杂度为O(NlogN)。 快速排序12345678910111213141516171819202122232425262728public int[] quickSort(int[] arr, int n) &#123; // write code here if (arr == null || n &lt; 2) &#123; return null; &#125; process(arr, 0, n - 1); return arr;&#125;public static void process(int[] arr, int left, int right)&#123; if(left &lt; right)&#123; int random = left + (int) (Math.random() * (right - left + 1)); swap(arr, random, right); int mid = partition(arr, left, right); process(arr, left, mid - 1); process(arr, mid + 1, right); &#125;&#125;public static int partition(int[] arr, int left, int right)&#123; int pivot = left - 1; int index = left; while (index &lt;= right) &#123; if (arr[index] &lt;= arr[right]) &#123; swap(arr, ++pivot, index); &#125; index++; &#125; return pivot;&#125; 主要思想：随机选中一个划分值，将小于等于划分值的元素放在元素的左边，大于划分值的元素放在元素的右边，再对左右两部分分别递归地调用快速排序的过程，数组排序完毕，过程结束。快速排序的过程：一次划分过程，即选择一个划分值之后小于等于划分值的数是如何放在元素的左边，大于划分值的数如何放在元素的右边：首先令划分值放在数组最后的位置，然后我们设置一个小于等于的区间，区间的初始长度为0，放在整个数组的左边接下来从左到右遍历数组中的元素，如果当前元素大于划分值，则继续遍历下一个值如果当前元素小于等于划分值，则把当前数与小于等于区间的下一个数进行交换，然后令小于等于区间右扩一个长度在遍历完所有元素，直到最后的元素时，将最后的元素即划分值与小于等于区间的下一个数进行交换，这样就完成了一次完整的划分过程。快速排序时间复杂度为O(NlogN)。 堆排序123456789101112131415161718192021222324252627282930313233public int[] heapSort(int[] arr, int n) &#123; // write code here for (int i = 0; i &lt; n; i++) &#123; createMaxdHeap(arr, n - 1 - i); swap(arr, 0, n - 1 - i); &#125; return arr; &#125;public static void createMaxdHeap(int[] data, int lastIndex) &#123; for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; // 保存当前正在判断的节点 int k = i; // 若当前节点的子节点存在 while (2 * k + 1 &lt;= lastIndex) &#123; // biggerIndex总是记录较大节点的值,先赋值为当前判断节点的左子节点 int biggerIndex = 2 * k + 1; if (biggerIndex &lt; lastIndex) &#123; // 若右子节点存在，否则此时biggerIndex应该等于 lastIndex if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; // 若右子节点值比左子节点值大，则biggerIndex记录的是右子节点的值 biggerIndex++; &#125; &#125; if (data[k] &lt; data[biggerIndex]) &#123; // 若当前节点值比子节点最大值小，则交换2者得值，交换后将biggerIndex值赋值给k swap(data, k, biggerIndex); k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125; 主要思想：首先将数组中的n个数建成一个大小为n的大根堆，堆顶是整个数组中的最大值，将堆顶元素与堆的最后一个元素交换位置，然后将最大值脱离出堆的整个结构，放在数组最后的位置，接下来将n-1大小的堆进行大根堆的调整，调整出n-1大根堆的最大值放在堆顶，再把堆顶位置的值与整个堆的最后元素交换，将最大值脱离出堆的整个结构，放在数组相对最后的位置。依次重复步骤，直到堆的大小减为1为止，整个数组就变为有序数组，过程结束。堆排序的过程：堆排序时间复杂度为O(NlogN)。 希尔排序123456789101112131415161718192021222324public int[] shellSort(int[] arr, int n) &#123; // write code here if(arr == null || n &lt; 2)&#123; return null; &#125; int feet = n / 2; int index = 0; while(feet &gt; 0)&#123; for(int i = feet; i &lt; n; i++)&#123; index = i; while(index &gt;= feet)&#123; if(arr[index - feet] &gt; arr[index])&#123; swap(arr, index - feet, index); index -= feet; &#125; else&#123; break; &#125; &#125; &#125; feet /= 2; &#125; return arr;&#125; 主要思想：希尔排序是插入排序的一个改良算法，插入排序步长为1，希尔排序步长可调整。举个🌰来说明：初始步长为3时，数组前3个数6 5 3是不需要考虑的从1开始，1向前跳3位来到了6的数上，1和6进行比较发现1比6小，则两个元素交换位置接下来1就来到了位置0，往前跳3位，则已经越界，所以交换的过程停止，然后继续考察下一位数，直到数组末尾，步长为3的插入排序结束调整步长继续进行插入排序的过程，希尔排序最终都会以步长为1的情况结束希尔排序的关键是步长的选择，时间复杂度为O(NlogN)。 基于桶排序的排序算法计数排序12345678910111213141516171819202122 public int[] countingSort(int[] arr, int n)&#123; if (arr == null || n &lt; 2) &#123; return null; &#125; int min = arr[0]; int max = arr[0]; for (int i = 1; i &lt; n; i++) &#123; min = Math.min(arr[i], min); max = Math.max(arr[i], max); &#125; int[] countArr = new int[max - min + 1]; for (int i = 0; i &lt; n; i++) &#123; countArr[arr[i] - min]++; &#125; int index = 0; for (int i = 0; i &lt; countArr.length; i++) &#123; while (countArr[i]-- &gt; 0) &#123; arr[index++] = i + min; &#125; &#125; return arr;//将排序好的数组返回，完成排序 &#125; 主要思想：根据数组中的元素建桶，将数组中的元素依次放入对应的桶中，当所有元素进入桶之后，从最小的桶依次倒出桶中的元素，直到最大的桶号为止，此时，元素被倒出的顺序就是数组排序之后的顺序。上例实现中为了节省内存的开销，记录了数组元素中的最大值以及最小值，并以此来建立最大桶以及最小桶，要注意的是，要考虑存在相等元素的情况，因此要记录每个桶中的元素个数。举个简单的🌰：对员工身高进行排序，因为成年人的身高在100cm-300cm之间，所以将桶定义为100-300将员工身高放入相应的桶号中从100开始倒出元素，数组排序完毕。计数排序的时间复杂度为O(N)。 基数排序1234567891011121314151617181920212223242526272829303132public int[] radixSort(int[] array, int n)&#123; if (array == null || n &lt; 2) &#123; return null; &#125; int d = 10000; int m = 1;//代表位数对应的数：1,10,100... int k = 0;//保存每一位排序后的结果用于下一位的排序输入n int[][] bucket = new int[10][n];//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里 int[] order = new int[n];//用于保存每个桶里有多少个数字 while(m &lt; d) &#123; for(int num : array) //将数组array里的每个数字放在相应的桶里 &#123; int digit = (num / m) % 10; bucket[digit][order[digit]++] = num; &#125; for(int i = 0; i &lt; n; i++)//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果 &#123; if(order[i] &gt; 0)//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中 &#123; for(int j = 0;j &lt; order[i]; j++) &#123; array[k++] = bucket[i][j]; &#125; &#125; order[i] = 0;//将桶里计数器置0，用于下一次位排序 &#125; m *= 10; k = 0;//将k置0，用于下一轮保存位排序结果 &#125; return array;&#125; 举个简单的🌰来说明基数排序的主要思想：准备0-9号桶接下来根据每一个元素个位上的数字，将元素放入对应的桶号中所有元素进桶后再从9号桶至0号桶依次倒出桶内的元素，组成了一个新序列根据每一个元素十位上的数字，将新序列中元素放入对应的桶号中所有元素进桶后再从9号桶至0号桶依次倒出桶内的元素，组成了一个新序列根据每一个元素百位上的数字，将新序列中元素放入对应的桶号中所有元素进桶后再从9号桶至0号桶依次倒出桶内的元素，组成了一个新序列依次迭代下去，最后根据最高位数值选择进入对应的桶中，最后一次倒出的序列就是整个数组排序的结果，过程结束。基数排序的时间复杂度为O(N) 排序算法的比较稳定性：假定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序不变，则称这种排序算法是稳定的，否则称为不稳定的。 排序算法典型案例小范围排序已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。选择改进后的堆排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public int[] sortElement(int[] A, int n, int k) &#123; if (A == null || A.length == 0 || n &lt; k) &#123; return A; &#125; int[] heap = getKHeap(A, k); for(int i = k; i &lt; n; i++)&#123; A[i - k] = heap[0]; heap[0] = A[i]; heapify(heap, 0, k); &#125; for(int i = n - k; i &lt; n; i++)&#123; A[i] = heap[0]; heap[0] = heap[k - 1]; heapify(heap, 0, --k); &#125; return A; &#125; public int[] getKHeap(int[] A, int k)&#123; int[] heap = new int[k]; for(int i = 0; i &lt; k; i++)&#123; heapInsert(heap, A[i], i); &#125; return heap;&#125; public void heapInsert(int[]A, int value, int index)&#123; A[index] = value; while(index != 0)&#123; int parent = (index - 1) / 2; if(A[parent] &gt; A[index])&#123; swap(A, parent, index); index = parent; &#125; else&#123; break; &#125; &#125;&#125; public void heapify(int[] arr, int index, int heapSize) &#123; int left = index * 2 + 1; int right = index * 2 + 2; int smallest = index; while (left &lt; heapSize) &#123; if (arr[left] &lt; arr[index]) &#123; smallest = left; &#125; if (right &lt; heapSize &amp;&amp; arr[right] &lt; arr[smallest]) &#123; smallest = right; &#125; if (smallest != index) &#123; swap(arr, smallest, index); &#125; else &#123; break; &#125; index = smallest; left = index * 2 + 1; right = index * 2 + 2; &#125;&#125; 说明：整个数组的最小值肯定是在0~k-1这个区间内的将a[0]~a[k-1]建立小根堆，将栈顶元素放在数组的第一个位置上然后将元素组的下一个元素放入小根堆，并对小根堆进行调整将栈顶元素放在数组的第二个位置上依次重复步骤，数组排序完毕。时间复杂度为O(NlogK) 重复值判断请设计一个高效算法，判断数组中是否有重复值。必须保证额外空间复杂度为O(1)。如果没有空间复杂度的限制，用哈希表实现，此题采用先排序后判断的方法，采用非递归的堆排序实现排序。123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean checkDuplicate(int[] a, int n) &#123; // write code here a = heapSort(a, n); for(int i = 0; i &lt; n - 1; i++) &#123; if(a[i] == a[i + 1]) &#123; return true; &#125; &#125; return false;&#125;public int[] heapSort(int[] A, int n) &#123; // write code here for (int i = 0; i &lt; n; i++) &#123; createMaxdHeap(A, n - 1 - i); swap(A, 0, n - 1 - i); &#125; return A; &#125; public static void createMaxdHeap(int[] data, int lastIndex) &#123; for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; // 保存当前正在判断的节点 int k = i; // 若当前节点的子节点存在 while (2 * k + 1 &lt;= lastIndex) &#123; // biggerIndex总是记录较大节点的值,先赋值为当前判断节点的左子节点 int biggerIndex = 2 * k + 1; if (biggerIndex &lt; lastIndex) &#123; // 若右子节点存在，否则此时biggerIndex应该等于 lastIndex if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; // 若右子节点值比左子节点值大，则biggerIndex记录的是右子节点的值 biggerIndex++; &#125; &#125; if (data[k] &lt; data[biggerIndex]) &#123; // 若当前节点值比子节点最大值小，则交换2者得值，交换后将biggerIndex值赋值给k swap(data, k, biggerIndex); k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125; &#125; 有序数组合并有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。12345678910111213 public int[] mergeAB(int[] A, int[] B, int n, int m) &#123; // write code here while(m != 0)&#123; if(n == 0)&#123; A[m - 1] = B[m - 1]; m--; &#125; else&#123; A[m + n - 1] = A[n - 1] &gt; B[m - 1]? A[--n] : B[--m]; &#125; &#125; return A;&#125; 举个🌰来说明：首先比较数组A和数组B最后的元素发现6比5大，所以将6拷贝至数组A最后的位置接着比较数组A倒数第二个元素4和数组B最后一个元素5，发现5比4大，则将5拷贝至数组A倒数第二个位置依次比较所有的数，直到有序数组B完成拷贝至数组A中为止，那么数组A就是整个合并后的结果。关键在于从后往前覆盖数组A 三色排序有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。本题主要过程与快速排序划分过程类似123456789101112131415161718192021public int[] sortThreeColor(int[] A, int n) &#123; // write code here if (A == null || n &lt; 2) &#123; return A; &#125; int left = -1; int right = n; int index = 0; while(index &lt; right)&#123; if(A[index] == 0)&#123; swap(A, ++left, index++); &#125; else if(A[index] == 2)&#123; swap(A, index, ++right); &#125; else&#123; index++; &#125; &#125; return A;&#125; 举个🌰：因为此过程与快速排序划分过程很类似，这里就不做详细说明了 有序矩阵查找现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。123456789101112131415161718public boolean findX(int[][] mat, int n, int m, int x) &#123; int a = 0; int b = m - 1; while(a &lt; n &amp;&amp; b &gt;= 0)&#123; if (mat[a][b] == x) &#123; return true ; &#125; if (mat[a][b] &lt; x)&#123; a++ ; &#125; if (mat[a][b] &gt; x) &#123; b--; &#125; &#125; return false;&#125; 举个🌰来说明：从二维数组的右上角开始如果当前数大于需要找的数，因为整个二维数组中每一列都是有序的，所以当前数下面的所有数都比需要找的数大，此时向左移动如果当前数小于需要找的数，因为整个二维数组中每一行都是有序的，所以当前数左边的所有数都比需要找的数小，此时向下移动每一个当前数都根据以上的逻辑进行判断，如果在移动的过程中找到了我们需要找的数，返回true，整个过程结束，如果一直到越界还未找到，则返回false。 最短子数组对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。12345678910111213141516171819202122232425262728293031 public int shortestSubsequence(int[] A, int n) &#123; // write code here int max = A[0]; int min = A[n - 1]; int left = 0; int right = 0; for(int i = 1; i &lt; n; i++) &#123; if(A[i] &gt; max) &#123; max = A[i]; &#125; else if(A[i] &lt; max) &#123; right = i; &#125; &#125; for(int i = n - 2; i &gt;= 0; i--) &#123; if(A[i] &lt; min) &#123; min = A[i]; &#125; else if(A[i] &gt; min) &#123; left = i; &#125; &#125; return ((right-left) == 0) ? 0 : ((right - left) + 1);&#125; 举个🌰来说明：首先从左到右遍历整个数组，使用单独的变量来记录遍历过的元素的最大值，我们只关注于一种情况：遍历过部分的最大值大于当前数的情况，这种情况发生的时候，在真实的排序之后，最大值起码会在当前数的位置或者更右的位置。从左到右遍历的过程中，我们只记录发生这种情况的最右位置；接下来是从右往左遍历整个数组，使用单独的变量来记录遍历过的元素的最小值，我们依然只关注于一种情况：遍历过部分的最小值小于当前数的情况，这种情况发生的时候，在真实的排序之后，最小值起码会在当前数的位置或者更左的位置。从右到左遍历的过程中，我们只记录发生这种情况的最左位置；最左位置和最右位置中间的范围就是需要排序的最短子数组 相邻两数最大差值有一个整形数组A，请设计一个复杂度为O(n)的算法，算出排序后相邻两数的最大差值。来自桶排序思想1234567891011121314151617181920212223242526272829303132333435363738394041424344public int maxGap(int[] nums, int n) &#123; // write code here if (nums == null || n &lt; 2) &#123; return 0; &#125;n int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; min = Math.min(min, nums[i]); max = Math.max(max, nums[i]); &#125; if (min == max) &#123; return 0; &#125; boolean[] hasNum = new boolean[len + 1]; int[] maxs = new int[len + 1]; int[] mins = new int[len + 1]; int bid = 0; for (int i = 0; i &lt; n; i++) &#123; bid = bucket(nums[i], n, min, max); // 算出桶号 mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i]; maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i]; hasNum[bid] = true; &#125; int res = 0; int lastMax = 0; int i = 0; while (i &lt;= n) &#123; if (hasNum[i++]) &#123; // 找到第一个不空的桶 lastMax = maxs[i - 1]; break; &#125; &#125; for (; i &lt;= n; i++) &#123; if (hasNum[i]) &#123; res = Math.max(res, mins[i] - lastMax); lastMax = maxs[i]; &#125; &#125; return res;&#125;public int bucket(long num, long len, long min, long max) &#123; return (int) ((num - min) * len / (max - min));&#125; 说明： 首先遍历数组，找到数组的最小值和最大值，在最小值和最大值范围上等量地分成n个区间（n为整个数组的长度） 每个区间分别对应一个桶，每个数根据自己的对应区间进入相应的桶，将最大值单独放在n+1号桶中，桶的数量一共有n+1个，而数组元素只有n个，所以在中间必然会出现空桶 我们可以很容易知道，在同一个桶中相邻元素的差值不会大于桶区间，而来自空桶两侧的相邻数的最大差值肯定大于桶区间，所以我们只需考虑桶间相邻数的差值，也就是后一个桶的最小值减去前一个桶的最大值 接下来我们只需要考虑每一个桶中的最小值与上一个非空桶的最大值的差值，并记录下其中的最大差值，也就是整个数组在排序之后相邻两数的最大差值。 总结排序算法到这里算是告一段落了，最后的排序案例很是经典，我碰到过好几次，排序算法是算法中重要的一部分知识点，希望自己以后能够将所有的排序算法自主编程实现～继续加油～]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法 排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式之结构型设计模式]]></title>
    <url>%2F2018%2F02%2F06%2Fjs-structural-pattern%2F</url>
    <content type="text"><![CDATA[继上篇创建型设计模式之后，此篇博文主要记录结构型设计模式的学习过程，如果在某些地方表述不正确的，还希望大家能够指出，共同进步～ 结构型设计模式结构型设计模式是一类关注于如何将类或对象组合成更大、更复杂的结构的设计模式，主要应用于对象的组合。包括外观模式、适配器模式、代理模式、装饰者模式、桥接模式、组合模式以及享元模式。 外观模式外观模式，为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更加容易。 外观模式简化底层接口复杂性，比如可以用来简化我们事件的绑定 1234567891011function addEvent(dom, type, fn)&#123; if(dom.addEventListener)&#123; dom.addEventListener(type, fn, false); &#125; else if(dom.attachEvent)&#123; dom.attachEvent('on' + type, fn); &#125; else&#123; dom['on' + type] = fn; &#125;&#125; 可以实现小型代码库，通过使用外观模式来封装多个功能，简化底层操作方法。 12345678910111213141516171819var A = &#123; g: function(id)&#123; return document.getElementById(id); &#125;, css: function(id, key, value)&#123; document.getElementById(id).style[key] = value; &#125;, attr: function(id, key, value)&#123; document.getElementById(id)[key] = value; &#125;, html: function(id, html)&#123; document.getElementById(id).innerHTML = html; &#125;, on: function(id, type, fn)&#123; document.getElementById(id)['on' + type] = fn; &#125;&#125;// TestA.css('box', 'background', 'red'); 当一个复杂的系统提供一系列复杂的接口方法时，为系统的管理方便会造成接口方法的使用极其复杂，我们可以通过使用外观模式封装隐藏其复杂性，并简化其使用。 适配器模式适配器模式，将一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求。 适配异类框架 1234567891011121314151617181920212223242526//定义框架var A = A || &#123;&#125;;A.g = function(id)&#123; return document.getElementById(id);&#125;A.on = function(id, type, fn)&#123; var dom = typeof id === 'string'? this.g(id) : id; if(dom.addEventListener)&#123; dom.addEventListener(type, fn, false); &#125; else if(dom.attachEvent)&#123; dom.attachEvent('on' + type, fn); &#125; else&#123; dom['on' + type] = fn; &#125;&#125;//适配JQueryA.g = function(id)&#123; return $(id).get(0);&#125;A.on = function(id, type, fn)&#123; var dom = typeof id === 'string'? $('#' + id) : $(id); dom.on(type, fn);&#125; 参数适配器，用适配器来适配传入的参数对象 1234567891011121314// 适配参数function doSomeThing(obj)&#123; var _adapter = &#123; name: 'qiuqiu', title: 'js', age: '20', color: 'pink', size: 100, prize: 50 &#125; for(var i in _adapter)&#123; _adapter[i] = obj[i] || _adapter[i]; &#125;&#125; 数据适配，将数组转换为对象形式 123456789// 数据适配function arrToObjAdapter(arr)&#123; return &#123; name: arr[0], type: arr[1], title: arr[2], data: arr[3] &#125;&#125; 在JavaScipt中，适配器模式不仅仅可以适配两个类接口不兼容的问题，还可以用于适配两个代码库，适配前后端数据等。 代理模式代理模式，由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用。在JavaScript中，代理模式往往用于解决跨域请求问题。 装饰者模式装饰者模式，在不改变原对象的基础上，通过对其进行包装拓展（添加属性或者方法）使原有对象可以满足用户的更复杂需求。1234567891011121314151617181920// 装饰者模式// 装饰者var decorator = function(input, fn)&#123; var input = document.getElementById(input); if(typeof input.onclick === 'function')&#123; var oldClickFn = input.onclick; input.onclick = function()&#123; oldClickFn(); fn(); &#125; &#125; else&#123; input.onclick = fn; &#125;&#125;// Testdecorator('tel-input', function()&#123; document.getElementById('tel_demo_text').style.display = 'none';&#125;) 适配器方法是对原有对象适配，添加的方法与原有方法功能大致相似，装饰者模式提供的方法与原来的方法功能是有一定区别的，在装饰者模式中，不需要了解对象原有的功能就可以对功能进行拓展。装饰者模式对对象的拓展是一种良性拓展，不用了解其具体实现，只是在外部进行了一次封装，这又是对原有功能完整性的一种保护。 桥接模式桥接模式，在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。多维度：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 桥接模式// 运动单元function Speed(x, y)&#123; this.x = x; this.y = y;&#125;Speed.prototype.run = function()&#123; console.log("运动起来");&#125;// 着色单元function Color(cl)&#123; this.color = cl;&#125;Color.prototype.draw = function()&#123; console.log("绘制色彩");&#125;// 说话单元function Speak(wd)&#123; this.word = wd;&#125;Speak.prototype.say = function()&#123; console.log("书写字体");&#125;function Ball(x, y, c) &#123; this.speed = new Speed(x, y); this.color = new Color(c);&#125;Ball.prototype.init = function()&#123; this.speed.run(); this.color.draw();&#125;function People(x, y, f)&#123; this.speed = new Speed(x, y); this.speak = new Speak(f);&#125;People.prototype.init = function()&#123; this.speed.run(); this.speak.say();&#125;// Testvar ball = new Ball(2, 5, 'red');ball.init(); 桥接模式先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用。如我们创建实体Ball时，将需要的每个抽象动作单元Speed和Color通过桥接，链接在一起运作，这样它们之间不会相互影响并且该方式降低了它们之间的耦合。桥接模式最主要的特点是将实现层（如元素绑定的事件）与抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化。 组合模式组合模式，又称为部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// 组合模式// 寄生组合式继承：寄生式继承＋构造函数继承function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;// 处理的不是对象，而是类的原型function inheritPrototype(subClass, superClass)&#123; // 复制一份父类的原型副本保存在变量中 var p = new inheritObject(superClass.prototype); // 修正因为重写子类类型导致子类的constructor属性被修改 p.constructor = subClass; // 设置子类的原型 subClass.prototype = p;&#125;// 虚拟父类var News = function ()&#123; this.children = []; this.element = null;&#125;News.prototype = &#123; init: function()&#123; throw new Error("请重写你的方法"); &#125;, add: function()&#123; throw new Error("请重写你的方法"); &#125;, getElement: function()&#123; throw new Error("请重写你的方法"); &#125;&#125;// 容器类var Container = function(iid, parent)&#123; News.call(this); this.id = id; this.parent = parent; this.init();&#125;inheritPrototype(Container, News);Container.prototype.init = function()&#123; this.element = document.createElement('ul'); this.element.id = this.id; this.element.className = 'new-container';&#125;Container.prototype.add = function(child)&#123; this.children.push(child); // 插入当前组件元素树中 this.element.appendChild(child.getElement()); return this;&#125;Container.prototype.getElement = function()&#123; return this.element;&#125;Container.prototype.show = function()&#123; this.parent.appendChild(this.element);&#125;var Item = function(classname)&#123; News.call(this); this.classname = classname || ''; this.init();&#125;inheritPrototype(Item, News);Item.prototype.init = function()&#123; this.element = document.createElement('li'); this.element.className = this.classname;&#125;Item.prototype.add = function(child)&#123; this.children.push(child); // 插入当前组件元素树中 this.element.appendChild(child.getElement()); return this;&#125;Item.prototype.getElement = function()&#123; return this.element;&#125;// 叶子节点类var ImageNews = function (url, href, classname) &#123; News.call(this); this.url = url || ''; this.href = href || '#'; this.classname = classname || ''; this.init();&#125;inheritPrototype(ImageNews, News);ImageNews.prototype.init = function()&#123; this.element = document.createElement('a'); var img = new Image(); img.src = this.url; this.element.appendChild(img); this.element.className = 'image-news' + this.classname; this.element.href = this.href;&#125;ImageNews.prototype.add = function()&#123;&#125;ImageNews.prototype.getElement = function()&#123; return this.element;&#125;var IconNews = function (text, href, type) &#123; News.call(this); this.text = text || ''; this.href = href || '#'; this.type = type || 'video'; this.init();&#125;inheritPrototype(IconNews, News);IconNews.prototype.init = function()&#123; this.element = document.createElement('a'); this.element.innerHTML = this.text; this.element.className = 'icon' + this.type; this.element.href = this.href;&#125;IconNews.prototype.add = function()&#123;&#125;IconNews.prototype.getElement = function()&#123; return this.element;&#125;// Testvar news1 = new Container('news', document.body);news1.add( new Item('normal').add( new IconNews('lalala', '#', 'video') )).add( new Item('normal').add( new IconNews('aiaia', '#', 'live') )).add( new Item('normal').add( new ImageNews('img/test1.png', '#', 'small') )) 组合模式的约束要求是接口的统一，上面的例子中，我们让所有的新闻都继承了一个新闻虚拟父类News，其中在虚拟类的构造函数中定义了两个特权变量，是因为后面的所有继承子类都要声明这两个变量，为了简化子类我们也可以将这些共有的变量提前声明在父类中，相当于Java语言中protected关键字的作用。组合模式能够给我们提供一个清晰的组成结构，组合对象类通过继承同一个父类使其具有统一的方法，这样也方便了我们统一管理与使用。 享元模式享元模式，运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 享元模式// 通用享元类var FlyWeight = &#123; moveX: function(x)&#123; this.x = x; &#125;, moveY: function(y)&#123; this.y = y; &#125;&#125;var Player = function(x, y, c)&#123; this.x = x; this.y = y; this.c = c;&#125;Player.prototype = FlyWeight;Player.prototype.changeC = function(c)&#123; this.c = c;&#125;var Spirit = function(x, y, r)&#123; this.x = x; this.y = y; this.r = r;&#125;Spirit.prototype = FlyWeight;Spirit.prototype.changeR = function(r)&#123; this.r = r;&#125;// Testvar player = new Player(5, 6, 'red');console.log(player);player.moveX(6);player.moveY(8);player.changeC('green');console.log(player)var spirit = new Spirit(2, 3, 4);console.log(spirit);spirit.moveX(3);spirit.moveY(4);spirit.changeR(5);console.log(spirit) 我们将人物类Player以及精灵类Spirit中的内部方法（移动方法）提取出来，实现公有，减少其它类重写时造成的不必要的开销。享元模式主要是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法。 总结JavaScript设计模式之结构型设计模式到此也就告一段落了，因为其中有部分设计模式之前因为时间不足未曾深入学习，所以可能有些理解的不够透彻，如果有存在描述不当的地方，欢迎大家指出～共同进步～ 下一篇我将记录JavaScript设计模式中行为型设计模式的学习过程～加油加油～]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript之设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式之创建型设计模式]]></title>
    <url>%2F2018%2F01%2F31%2Fjs-creational-pattern%2F</url>
    <content type="text"><![CDATA[这段时间沉迷于学习JavaScript的设计模式，于是想着与之前所学的设计模式联系起来，对比学习。因为之前有了Java设计模式的部分基础，所以在学习JavaScript设计模式时会进行一些简单的比较记忆，主要的内容安排是模式的定义、模式对应的类图以及模式的简单实现。此篇博文主要记录创建型设计模式的学习过程，如果在某些地方表述不正确的，还希望大家能够指出，共同进步～ 创建型设计模式创建型设计模式是一类处理对象创建的设计模式，主要应用于创建对象。包括简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式以及单例模式。 简单工厂模式简单工厂模式，又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。 Java语言简单工厂模式的类图表达为：我们可以仿照Java语言的类图绘制类图为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 简单工厂模式var Ball = function()&#123;&#125;Ball.prototype = &#123; getMember: function()&#123; throw new Error("抽象方法不能调用") &#125;, getBallSize: function()&#123; console.log("抽象方法不能调用"); &#125;&#125;var Basketball = function()&#123; this.intro = "篮球盛行于美国";&#125;Basketball.prototype = new Ball();Basketball.prototype = &#123; getMember: function()&#123; console.log("每个队伍需要5名队员"); &#125;, getBallSize: function()&#123; console.log("篮球很大"); &#125;&#125;var Football = function()&#123; this.intro = "足球在世界范围内流行";&#125;Football.prototype = new Ball();Football.prototype = &#123; getMember: function()&#123; console.log("每个队伍需要11名队员"); &#125;, getBallSize: function()&#123; console.log("足球很大"); &#125;&#125;var Tennis = function()&#123; this.intro = "每年有很多网球系列赛";&#125;Tennis.prototype = new Ball();Tennis.prototype = &#123; getMember: function()&#123; console.log("每个队伍需要1名队员"); &#125;, getBallSize: function()&#123; console.log("网球很小"); &#125;&#125;// 运动工厂var SportsFactory = function()&#123;&#125;SportsFactory.prototype = &#123; getSport: function(name)&#123; switch(name)&#123; case 'NBA': return new Basketball(); case 'wordCup': return new Football(); case 'FrenchOpen': return new Tennis(); &#125; &#125;&#125;// Testvar factory = new SportsFactory();var footnall = factory.getSport("wordCup");console.log(footnall);console.log(footnall.intro);footnall.getMember(); 简单工厂模式最主要的是所创建的工厂对象SportsFactory，工厂函数getSport()根据传入参数的不同返回不同类的实例。在此例中Football、Basketball、Tennis都继承了抽象类Ball，Ball中定义了两个抽象方法getMember()和getBallSize()，在具体类中重写这两个方法，若子类为重写父类中的抽象方法则会抛出异常： 当然因为JavaScript的特性，我们可以不需要Ball类，在Java语言中引入抽象类，主要是在客户端使用过程中，可以使用父类对象来替代具体的子类对象（里氏代换原则），如：12Ball ball; ball = factory.getSport("wordCup"); 在JavaScript语言中，你还可以使用一个对象来代替多个类123456789101112131415161718192021222324252627// 寄生方式// 使用一个对象代替多个类，提取相似function createSports(type, intro, member, size)&#123; var o = new Object(); o.intro = intro; if(type == 'football')&#123; console.log("foolball") &#125; else if(type == 'basketball')&#123; console.log("basketball") &#125; else if(type == 'tennis')&#123; console.log("tennis") &#125; o.getMember = function()&#123; console.log(member); &#125; o.getBallSize = function()&#123; console.log(size); &#125; return o;&#125;// Testvar basketball = createSports("basketball", "This is a Basketball", "5", "big");console.log(basketball);console.log(basketball.intro);basketball.getMember(); 这种方式将相似的部分提出，不相似的部分进行针对性的处理。 这两种方式存在一定的差异，第一种方式是通过类实例化对象创建的，第二种方式是通过创建一个新对象然后包装增强其属性和功能来实现的。选择哪种工厂方式来实现你的需求还要看你是如何分析你的需求的。 工厂方法模式工厂方法模式，通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。Java语言工厂方法模式类图表示为：工厂方法模式让子类决定将哪一种产品实例化，让一个类的实例化延迟到其子类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 工厂方法模式// 使用安全模式创建工厂类var Factory = function(type, content)&#123; if(this instanceof Factory)&#123; var s = new this[type](content); return s; &#125; else&#123; return new Factory(type, content); &#125;&#125;// 工厂原型中设置创建所有类型数据对象的基类Factory.prototype = &#123; Java: function(content)&#123; // 具体创建产品的过程 console.log(content); &#125;, JavaScript: function(content)&#123; console.log(content); &#125;, UI: function(content)&#123; console.log(content); &#125;, PHP: function(content)&#123; console.log(content); &#125;&#125;// Testvar data = [ &#123; type: 'JavaScript', content: 'javascript' &#125;, &#123; type: 'Java', content: 'java' &#125;, &#123; type: 'UI', content: 'UI' &#125;, &#123; type: 'PHP', content: 'PHP' &#125;, &#123; type: 'JavaScript', content: 'other javascript' &#125;]for(var d of data)&#123; Factory(d.type, d.content)&#125; 在实现工厂方法模式时，采用了安全模式创建工厂类，安全模式可以避免用户使用类时缺少new关键词而导致的错误。JavaScript中使用安全模式创建工厂类，在工厂原型中创建所有类型数据对象的基类，通过使用时向工厂类传递数据类型和数据内容两个参数，来动态的实例化相应的产品类。使用工厂方法模式可以避免使用者和对象类之间的耦合。 抽象工厂模式抽象工厂模式，通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。JavaScript语言虽然保留abstract关键字，但目前来说还不能像Java语言那样轻松地创建。我们可以在类的方法中手动地抛出错误来模拟抽象类。抽象工厂模式涉及的对象比较多，使用UML类图可以表示为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// 抽象工厂模式var Vehicle = function(subType, superType)&#123; // 判断抽象产品类中是否有该抽象类 if(typeof Vehicle[superType] === 'function')&#123; function F()&#123;&#125;; // 继承父类的属性和方法 F.prototype = new Vehicle[superType](); // 将子类constructor属性指向子类 subType.constructor = subType; // 子类原型继承父类 subType.prototype = new F(); &#125; else&#123; throw new Error("未创建该抽象类") &#125;&#125;// 小汽车抽象类Vehicle.Car = function()&#123; this.type = 'car';&#125;Vehicle.Car.prototype = &#123; getPrice: function()&#123; return new Error("抽象方法不能调用") &#125;&#125;// 公共汽车抽象类Vehicle.Bus = function()&#123; this.type = 'bus';&#125;Vehicle.Bus.prototype = &#123; getPrice: function()&#123; return new Error("抽象方法不能调用") &#125;&#125;// 汽车具体类——宝马汽车var BMWCar = function(price)&#123; this.price = price;&#125;Vehicle(BMWCar, 'Car');BMWCar.prototype.getPrice = function()&#123; return this.price;&#125;// 汽车具体类——兰博基尼汽车var LamborghiniCar = function(price)&#123; this.price = price;&#125;Vehicle(LamborghiniCar, 'Car');LamborghiniCar.prototype.getPrice = function()&#123; return this.price;&#125;// 公共汽车具体类——宝马公共汽车var BMWBus = function(price)&#123; this.price = price;&#125;Vehicle(BMWBus, 'Bus');BMWBus.prototype.getPrice = function()&#123; return this.price;&#125;// 公共汽车具体类——兰博基尼公共汽车var LamborghiniBus = function(price)&#123; this.price = price;&#125;Vehicle(LamborghiniBus, 'Bus');LamborghiniBus.prototype.getPrice = function()&#123; return this.price;&#125;// 抽象工厂var VehicleFactory = function(subType, superType)&#123; // 判断抽象工厂中是否有该抽象类 if(typeof VehicleFactory[superType] === 'function')&#123; function F()&#123;&#125;; // 继承父类的属性和方法 F.prototype = new VehicleFactory[superType](); // 将子类constructor属性指向子类 subType.constructor = subType; // 子类原型继承父类 subType.prototype = new F(); &#125; else&#123; throw new Error("未创建该抽象类") &#125;&#125;// 宝马工厂VehicleFactory.BMW = function(type)&#123; this.factory = '宝马'&#125;VehicleFactory.BMW.prototype = &#123; create: function(type)&#123; return new Error("抽象方法不能调用") &#125;&#125;// 兰博基尼工厂VehicleFactory.Lamborghini = function(type)&#123; this.factory = '兰博基尼'&#125;VehicleFactory.Lamborghini.prototype = &#123; create: function(type)&#123; return new Error("抽象方法不能调用") &#125;&#125;// 具体工厂——宝马工厂var BMWFactory = function()&#123;&#125;VehicleFactory(BMWFactory, 'BMW');BMWFactory.prototype = &#123; create: function(type)&#123; console.log("宝马工厂生产" + type) &#125;&#125;// 具体工厂——兰博基尼工厂var LamborghiniFactory = function()&#123;&#125;VehicleFactory(LamborghiniFactory, 'Lamborghini');LamborghiniFactory.prototype = &#123; create: function(type)&#123; console.log("兰博基尼工厂生产" + type) &#125;&#125;// Testvar testCar = new BMWCar(10000);var testBus = new BMWBus(100);var testBMW = new BMWFactory();testBMW.create(testCar.type);testBMW.create(testBus.type) 首先定义了抽象汽车类Car和抽象公共汽车类Bus，创建了Car抽象汽车的具体产品汽车子类宝马汽车子类BMWCar和兰博基尼汽车子类LamborghiniCar，Bus抽象公共汽车的具体产品公共汽车子类宝马公共汽车子类BMWBus和兰博基尼公共汽车子类LamborghiniBus，然后定义了抽象工厂类VehicleFactory，创建了具体工厂子类宝马工厂BMWFactory和兰博基尼工厂VehicleFactory。一个工厂负责创建一个产品族中的产品，BMWCar和LamborghiniCar同属于Car的产品等级结构中，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象， 建造者模式建造者模式，将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。建造者模式关注的是对象创建的细节，使用UML类图表示类之间的关系如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 建造者模式——关心对象创建的整个过程// 应聘者类var Human = function(param)&#123; this.skill = param &amp;&amp; param.skill || '保密'; this.hobby = param &amp;&amp; param.hobby || '保密';&#125;Human.prototype = &#123; getSkill: function()&#123; return this.skill; &#125;, getHobby: function()&#123; return this.hobby; &#125;&#125;// 实例化姓名类var Named = function(name)&#123; var that = this; (function(name, that)&#123; that.wholeName = name; if(name.indexOf(' ' &gt; -1))&#123; that.firstName = name.slice(0, name.indexOf(' ')); that.secondName = name.slice(name.indexOf(' ') + 1); &#125; &#125;)(name, that);&#125;// 实例化职位类var Work = function(work)&#123; var that = this; (function(work, that)&#123; switch(work)&#123; case 'code': that.work = '工程师'; that.workDescript = '每天沉醉于编程'; break; case 'UE': that.work = '设计师'; that.workDescript = '设计更似一种艺术'; break; case 'teach': that.work = '教师'; that.workDescript = '分享也是一种快乐'; break; default: that.work = work; that.workDescript = 'not know'; break; &#125; &#125;)(work, that);&#125;Work.prototype = &#123; changeWork: function(work)&#123; this.work = work; &#125;, changeDescript: function(setence)&#123; this.workDescript = setence; &#125;&#125;// 应聘者建造者var Person = function(name, work)&#123; var _person = new Human(); _person.name = new Named(name); _person.work = new Work(work); return _person;&#125;// Testvar person = new Person('xiao ming', 'code');console.log(person.skill);console.log(person.name.firstName);console.log(person.name.secondName);console.log(person.work.work);console.log(person.work.workDescript);person.work.changeDescript('更改职位描述！');console.log(person.work.workDescript); 在事例代码中应聘者Human类充当UML类图中的Product类，应聘者建造者Person类充当UML类图中的ConcreteBUilder类，测试代码部分可以看作是UML类图中的Director类，实例化职位类Work和实例化姓名类Named是Human的创建过程。建造者模式可以看作是为一个对象添加新的信息后返回新对象的过程。 原型模式原型模式，用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。原型模式在于通过复制这个原型来创建新的对象，可以复制原型对象的属性及方法来创建。下例代码实现了使用原型模式来复制多个原型对象来对新对象的创建1234567891011121314151617181920212223242526272829303132333435363738// 对象复制方法function prototypeExtend()&#123; var F = function()&#123;&#125;, args = arguments, len = args.length, i = 0; for(; i &lt; len; i++)&#123; // 遍历每个模版对象中的属性 for(var j in args[i])&#123; // 将属性复制到缓存类原型中 F.prototype[j] = args[i][j]; &#125; &#125; return new F();&#125;// Testvar penguin = prototypeExtend( &#123; speed: 20, swim: function()&#123; console.log("游泳速度：" + this.speed); &#125; &#125;, &#123; run: function()&#123; console.log("奔跑速度：" + this.speed); &#125; &#125;, &#123; jump: function()&#123; console.log("跳跃动作"); &#125; &#125;)penguin.swim();penguin.run(10);penguin.jump(); 单例模式单例模式，又称为单体模式，是只允许实例化一次的对象类。 用途一： 定义命名空间，下例代码中Qiu即为命名空间，使用其中方法时需Qiu.xx() 123456789// 单例模式var Qiu = &#123; g: function(id)&#123; return document.getElementById(id); &#125;, css: function(id, key, value)&#123; this.g(id).style[key] = value; &#125;&#125; 用途二： 管理静态变量——只能访问不能修改 12345678910111213141516var Conf = (function()&#123; // 私有变量 var conf = &#123; MAX_NUM: 100, MIN_NUM: 1, COUNT: 1000 &#125; // 返回取值器对象 return &#123; get: function(name)&#123; return conf[name]? conf[name]: null; &#125; &#125;&#125;)();var count = Conf.get('COUNT');console.log(count); 用途三： 惰性单例12345678910111213141516171819// 惰性单例var LazySingle = (function()&#123; var _instance = null; function Single()&#123; // 定义私有属性和方法 return &#123; publicMethod: function()&#123;&#125;, publicProperty: '1.0' &#125; &#125; // 获取单例对象接口 return function()&#123; if(!_instance)&#123; _instance = Single(); &#125; return _instance; &#125;&#125;)();console.log(LazySingle().publicProperty); 总结JavaScript设计模式之创建型设计模式到此也就告一段落了，因为其中有部分设计模式之前因为时间不足未曾深入学习，所以可能有些理解的不够透彻，如果有存在描述不当的地方，欢迎大家指出～共同进步～ 下一篇我将记录JavaScript设计模式中结构型设计模式的学习过程～加油加油～]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript之设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之继承]]></title>
    <url>%2F2018%2F01%2F30%2Fjs-herit%2F</url>
    <content type="text"><![CDATA[这段时间主要学习了JavaScript的知识，不得不感慨js语言的强大与灵活。此次主要是对JavaScript中的继承进行学习记录与总结，但免不了涉及到面向对象编程、封装以及多态的相应知识。接下来我将先介绍什么是面向对象编程以及为什么要采用面向对象来进行编程，接着介绍一下面向对象中的重要特性——封装，然后介绍js实现继承的六种方法，最后简单介绍一下js实现多态的方式。此篇博文主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 面向对象编程什么是面向对象编程面向对象编程通俗来说，就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性）和动作（方法）。 在Java语言中通过class关键字就可以很方便地声明一个对象，但在JavaScript语言中因为没有通过class实现类封装的方法，所以通常是通过一些特性模仿实现的，但这也带来了极高的灵活性，使我们编写的代码更自由。 为什么要引入面向对象的思想由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护，代码复用性强，能够在很大程度上促进团队的协同合作。 前置要点在JavaScript中创建一个类很容易，首先声明一个函数保存在一个变量中，然后在函数（类）的内部通过对this变量添加属性或者方法来实现对类添加属性或者方法，例如：12345var Book = function(id, bookName, price)&#123; this.id = id; this.bookName = bookName; this.price = price;&#125; 因为类是一个对象，有一个原型prototype用于指向其继承的属性和方法，所以也可以通过在类的原型上添加属性或方法。但通过this定义的属性和方法是该对象自身拥有的属性和方法，而prototype指向的是其继承的属性和方法123Book.prototype.display = function()&#123; //展示这本书&#125; 或12345Book.prototype = &#123; display: function()&#123; //展示这本书 &#125;&#125; 但两种方式不要混用。当创建一个函数或者对象时都会为其创建一个原型对象prototype，在prototype中又会像创建this一样创建一个constructor属性，指向拥有整个原型对象的函数或对象，也就是🌰中的Book对象。 封装封装（Encapsulation）是面向对象方法的重要特性，就是把对象的属性和方法结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过此特性即可创建类的私有变量以及私有方法。 在函数内部通过this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到，因此可以通过this创建对象的公有属性和公有方法。 通过this创建的方法，不但可以访问这些对象的公有属性和公有方法，还可以访问到其私有属性和私有方法，所以又称这些方法为特权方法 类外面通过点语法定义的属性以及方法被称为类的静态公有属性和类的静态公有方法 123456789101112131415161718192021222324252627var Book = function(id, name, price)&#123; // 私有属性 var num = 1; // 私有方法 function checkId()&#123;&#125; // 特权方法 this.getName = function()&#123;&#125;; this.getPrice = function()&#123;&#125;; this.setName = function()&#123;&#125;; this.setPrice = function()&#123;&#125;; // 对象公有属性 this.id = id; // 对象公有方法 this.copy = function()&#123; console.log(num) &#125;; // 构造器 this.setName(name); this.setPrice(price);&#125;// 类静态公有属性（对象不能访问）Book.isChinese = true;// 类静态公有方法（对象不能访问）Book.resetTime = function()&#123; console.log('new time');&#125; 测试代码：12345678var book = new Book(11, 'JavaScript 设计模式', 50);console.log(book.num);book.copy();console.log(book.id);console.log(book.isJSBook);console.log(book.isChinese);console.log(Book.isChinese);Book.resetTime(); 运行结果为： 继承继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。JavaScript中并没有实现继承的现有机制，接下来我将会介绍JavaScript中实现继承的几种方法。 方法一： 类式继承12345678910111213141516171819202122232425// 类式继承function SuperClass()&#123; this.superValue = true; this.book = ['JavaScrpt', 'html', 'css'];&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;function SubClass()&#123; this.subValue = false;&#125;// 继承父类SubClass.prototype = new SuperClass();//继承之后再添加子类公有方法SubClass.prototype.getSubValue = function()&#123; return this.subValue;&#125;var instance = new SubClass();console.log(instance.getSubValue());console.log(instance.getSuperValue()); 类式继承中实现继承的主要方法是SubClass.prototype = new SuperClass();SubClass的原型被赋予了SuperClass的实例，因而SubClass的原型继承了SuperClass。类式继承存在两个缺点： 由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的公有属性要是引用类型，就会在子类中被所有实例共用，因此一个子类的实例更改子类原型从父类构造函数中继承来的公有属性就会直接影响到其他子类。12345var instance1 = new SubClass();var instance2 = new SubClass();console.log(instance2.book);instance1.book.push('设计模式');console.log(instance2.book); 由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。 因为类式继承存在的两个缺点，所以引出了第二种继承方法——构造函数继承 方法二： 构造函数继承1234567891011121314151617181920212223// 构造函数继承function SuperClass(id)&#123; this.id = id; this.books = ['JavaScrpt', 'html', 'css'];&#125;SuperClass.prototype.showBooks = function()&#123; console.log(this.books);&#125;function SubClass(id)&#123; // 构造函数继承，使用call来更改函数的作用环境 SuperClass.call(this, id);&#125;var instance1 = new SubClass(10);var instance2 = new SubClass(20);instance1.books.push("Java");console.log(instance1.id);console.log(instance1.books);console.log(instance2.id)console.log(instance2.books); SuperClass.call(this, id);这条语句是构造函数继承的精华，call方法可以更改函数的执行环境，因此在子类中，对SuperClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然就继承了父类的公有属性。由于构造函数继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承。1instance1.showBooks(); 因而引出了第三种继承方法——组合继承 方法三： 组合继承组合继承是将类式继承和构造函数继承组合起来实现继承的一种方式。1234567891011121314151617181920212223242526272829303132333435363738// 组合继承function SuperClass(name)&#123; this.name = name; this.books = ['JavaScrpt', 'html', 'css'];&#125;SuperClass.prototype= &#123; getName: function()&#123; console.log(this.name); &#125;, showBooks: function()&#123; console.log(this.books); &#125;&#125;function SubClass(name, time)&#123; // 调用父类构造函数 SuperClass.call(this, name); this.time = time;&#125;SubClass.prototype = new SuperClass();SubClass.prototype.getTime = function()&#123; console.log(this.time);&#125;var instance1 = new SubClass('js book', 2010);// 调用父类构造函数instance1.books.push("Java");instance1.showBooks();instance1.getName();instance1.getTime();var instance2 = new SubClass('css book', 2021);instance2.showBooks();instance2.getName();instance2.getTime(); 组合继承解决了类式继承和构造函数继承存在的问题，但仍然不是完美的继承方法，因为在组合继承中调用了两次父类构造函数，在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。 最完美的继承方法是——寄生组合式继承，在学习寄生组合式继承之前，我们需要了解原型式继承、寄生式继承方法的实现。 方法四： 原型式继承1234567891011121314151617181920212223242526272829// 原型式继承function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;var book = &#123; name: "js book", alikeBook: ["css book", "html book"]&#125;var newBook = inheritObject(book);newBook.name = "ajax book";newBook.alikeBook.push("xml book");var otherBook = inheritObject(book);otherBook.name = "flash book";otherBook.alikeBook.push("as book");// 存在同类式继承一样的问题：共享属性console.log(newBook.name);console.log(newBook.alikeBook);console.log(otherBook.name);console.log(otherBook.alikeBook);console.log(book.name);console.log(book.alikeBook); 原型式继承引入一个过渡对象，通过过渡对象的原型继承父对象，返回过渡对象的实例来实现继承。原型式继承是对类式继承的一次封装，所以类式继承的问题在原型式继承中也会出现。 方法五： 寄生式继承12345678910111213141516171819202122232425262728293031// 寄生式继承——对原型继承的第二次封装function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;var book = &#123; name: "js book", alikeBook: ["css book", "html book"]&#125;// 二次封装 优点：对继承的对象进行了拓展function createBook(obj)&#123; var o = new inheritObject(obj); // 拓展新对象 o.getName = function()&#123; console.log(this.name); &#125;; // 返回拓展后的新对象 return o;&#125;var newBook = createBook(book);var otherBook = createBook(book);newBook.getName();console.log(newBook.alikeBook);newBook.alikeBook.push('Java');console.log(otherBook.alikeBook); 寄生式继承是对原型式继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展。仍然存在属性共享的问题。 方法六： 终极继承者——寄生组合式继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 寄生组合式继承：寄生式继承＋构造函数继承function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;// 处理的不是对象，而是类的原型function inheritPrototype(subClass, superClass)&#123; // 复制一份父类的原型副本保存在变量中 var p = new inheritObject(superClass.prototype); // 修正因为重写子类类型导致子类的constructor属性被修改 p.constructor = subClass; // 设置子类的原型 subClass.prototype = p;&#125;function SuperClass(name)&#123; this.name = name; this.colors = ["red", "green", "yellow"]&#125;SuperClass.prototype.getName = function()&#123; console.log(this.name);&#125;function SubClass(name, time)&#123; SuperClass.call(this, name); this.time = time;&#125;inheritObject(SubClass, SuperClass);SubClass.prototype.getTime = function()&#123; console.log(this.time);&#125;// Testvar instance1 = new SubClass('js book', 2014);var instance2 = new SubClass('css book', 2020);instance1.colors.push("grown");console.log(instance1.colors);console.log(instance2.colors);instance1.getTime();instance2.getTime(); 寄生组合式继承是将寄生式继承和构造函数继承组合在一起的继承方法。 通过寄生式继承重新继承父类的原型。我们继承的仅仅是父类的原型，不再需要调用父类的构造函数。因为在构造函数继承中我们已经调用了父类的构造函数，所以我们需要的就是父类的原型对象的一个副本，而这个副本我们通过原型继承，即inheritObject()方法便可得到。因为对父类原型对象复制得到的复制对象p中的constructor指向的不是subClass子类对象，因此寄生式继承中要对复制对象p做一次增强，修复constructor指向不正确的问题，最后将得到的复制对象p赋值给子类的原型，这样，子类的原型就继承了父类的原型并且没有执行父类的构造函数。 寄生组合式继承是JavaScript实现继承的终极继承方式，也就是说，使用寄生组合式继承可以解决类式继承共享属性的问题、构造函数继承无法继承原型prototype上的属性的问题以及组合继承调用两次父类构造函数的问题。但是寄生组合式继承也比较不好理解，我已经在代码部分都写上了注释，供大家参考理解～ 多继承当前流行的用于继承单对象属性的extends方法，是通过对对象中属性的复制来实现的。JavaScript也可以使用属性复制的方式来实现多继承：123456789101112// 多继承——对对象中的属性的一个复制过程Object.prototype.mix = function()&#123; var i = 0, len = arguments.length, arg; for(; i &lt; len; i++)&#123; arg = arguments[i]; for(var property in arg)&#123; this[property] = arg[property]; &#125; &#125;&#125; 多态多态通俗来说就是同一个方法多种调用方式。在JavaScript中通过对传入的参数进行判断来实现多种调用方式。如：123456789101112131415161718// 多态function add()&#123; var arg = arguments, len = arg.length; switch(len)&#123; case 0: return 10; case 1: return 10 + arg[0]; case 2: return arg[0] + arg[1]; &#125;&#125;// Testconsole.log(add());console.log(add(5));console.log(add(1, 7)); 总结封装、继承与多态是面向对象中的重要特性，从JavaScript的角度上实现这三个特性，让我感受到JavaScript的灵活与强大。因为本学期上了伟帅的设计模式的课，对设计模式颇有兴趣，接下来我将会学习JavaScript中的设计模式，并将学习过程记录下来～]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript之继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack，一个广泛应用的模块打包器（二）——资源管理模块]]></title>
    <url>%2F2017%2F11%2F20%2Fwebpack-guide%2F</url>
    <content type="text"><![CDATA[继上一篇博文webpack，一个广泛应用的模块打包器（一）——概念篇完成之后，时隔一段时间没有学习webpack了，主要是最近有点小忙耽搁了。此篇博文主要是作为webpack的学习指南，理解和掌握webpack提供的各种工具和特性，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 安装首先需要你下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装，在使用webpack的过程中我们需要大量的使用node中的npm包管理工具，npm主要的使用场景有： 用户可以在npm服务器上下载别人编写的第三方包到本地使用; 用户可以在npm服务器上下载并安装别人编写的命令行程序到本地使用; 还可以将自己编写的包或命令行程序上传到npm服务器供他人使用。 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 全局安装1npm install --global webpack 全局安装将使webpack在全局环境下可用，但不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 本地安装1npm install --save-dev webpack 对于大多数项目，我们建议本地安装。这可以使我们在引入破坏式变更的依赖时，更容易分别升级项目。通常，webpack 通过运行一个或多个 npm scripts，会在本地 node_modules 目录中查找安装的 webpack。 起步为了后续更好的进行知识点的演示，我们先进行简单的项目准备。我在常用的工作目录下新建了一个名为webpack-blog的文件夹。命令行进入webpack-blog的工作目录执行1234//初始化并创建package.json文件$ npm init //在项目中安装webpack依赖包$ cnpm install --save-dev webpack 在根目录下创建名为webpack.config.js的文件以及我们的入口文件/src/main.js文件，webpack.config.js是我们这次主要的文件，是webpack的配置文件。构建好工作目录后，我们来根据上一节简述过的webpack核心知识来简单使用一下webpack。首先，我们在src目录下的main.js文件中编写简单的js代码：1console.log("Welcome to your first webpack test!"); 接着，我们来到webpack.config.js文件，并设置webpack打包所需的入口起点以及输出文件配置：12345678910var path = require('path');var webpack = require('webpack');module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;&#125; 简单介绍一下上述代码，entry是模块打包的入口起点，它指示webpack根据src目录下的main.js文件来构建工程的依赖图；require()是node.js中常用的一个导入模块的操作，path.resolve()是获取绝对路径的方法，__dirname 用于获取当前文件所在目录的完整目录名。此代码用于查找dist文件夹，如果目录下没有dist文件夹则新建，并将通过打包创建后的webpack.bundle.js文件放入dist文件夹中。 接着，我们执行1$ webpack 命令，对工程进行打包构建，执行成功后，我们可以在根目录下看到新建的dist文件夹下有一个新建的webpack.bundle.js文件，有点绕～ 最后，我们在src目录下新建一个名为index.html的文件，并以script标签的形式引入生成的webpack.bundle.js文件，在浏览器中打开index.html，你会发现页面上空空如也，什么都没有～别着急，打开浏览器的控制台，你可以看到在控制台中输出了“Welcome to your first webpack test!”，我们对webpack的第一次简单应用就成功啦。 当然这只是一个超简单的例子，接下来我们将对这个例子进行扩充，进而展示webpack强大的功能。 管理资源加载CSS为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：1$ cnpm install --save-dev style-loader css-loader 安装成功后可以在package.json文件中的devDependencies项中看到新安装的style-loader和css-loader模块。接着，我们在webpack.config.js文件中配置模块的使用规则：12345678module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ]&#125; 简单介绍以上代码，test用于识别出应该被对应的loader进行转换的文件，以上代码表示loader需要识别.css为后缀的文件，use属性转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）。 下一步，我们尝试一下在项目src目录下添加style.css文件，并将其导入我们的入口文件main.js中我们修改main,js文件中的内容，以便于在页面中更直观地看到效果。1234var element = document.createElement('div');element.setAttribute("class", "hello");element.innerHTML = "Welcome to your first webpack test!";document.body.appendChild(element); 此时经过$ webpack命令打包后，在浏览器打开index.html文件可以看到，页面结构为页面效果为： 接下来我们在创建的style.css文件中写入简单的样式来验证webpack加载CSS的功能123.hello&#123; color: red;&#125; 在main.js文件中引入style.css文件1import './style.css'; 再次使用$ webpack命令打包后，我们在浏览器中打开index.html文件，我们可以看到Welcome to your first webpack test!输出为红色。 查看页面的head标签，可以发现页面已经包含了我们在main.js文件中导入的style.css文件。 加载图片使用 file-loader，我们可以轻松地将页面中需要的背景图片或者图标混合到 CSS 中，首先还是要安装模块依赖包：1$ cnpm install --save-dev file-loader 同样的，我们需要在webpack.config.js文件中配置应用规则： 此段规则表明程序可以加载以.png .svg .jpg .gif为后缀名的文件。我们可以直接在style.css文件中添加background样式来引入图片，为了让背景图片完整地显示出来，我们为hello这个div设置了300px的高度12345.hello&#123; height: 300px; color: red; background: url('./logo.png');&#125; 重新执行$ webpack命令，我们可以看到页面效果为： 图片稀缺，就拿了一张之前工程中现有的vue框架的logo来用～如果你检查img元素，你将看到实际的文件名已更改为像 82b9c7a5a3f405032b1db71a25f67021.png 一样。这意味着 webpack 在 src 文件夹中找到我们的文件，并成功处理过它了！ 加载字体 加载字体与加载图片相同，也使用的是file-loader来加载字体文件，加载字体使用的正则规则如：1test: /\.(woff|woff2|eot|ttf|otf)$/ 与加载图片文件相同，加载字体需要在css文件中引入字体文件，可以通过一个 @font-face 声明引入。用法如下： 加载数据在我们实际运用中，不仅仅要加载图片及字体文件，还可能需要加载有用的资源还有数据，如 JSON 文件，CSV、TSV 和 XML。JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。而要导入 CSV、TSV 和 XML类型的数据，就需要我们安装csv-loader和xml-loader模块来进行加载数据。首先，我们还是需要在项目中安装相关模块：1$ cnpm install --save-dev csv-loader xml-loader 接着，我们同样需要在webpack.config.js文件中配置相关的应用规则，规则如下：12345678 &#123; test: /\.(csv|tsv)$/, use: ['csv-loader']&#125;,&#123; test: /\.xml$/, use: ['xml-loader']&#125; 接下来，我们在src目录下添加名为data.xml的数据文件，data.xml内容如下： 我们在main.js文件中解析data.xml文件中的数据，主要增加以下两行代码：12import Data from './data.xml';console.log(Data); 再次执行$ webpack命令后，再次在浏览器上打开index.html文件，我们可以在控制台输出了data.xml文件解析后的数据： 开发Source Map当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。这并通常没有太多帮助，因为你可能需要准确地知道错误来自于哪个源文件。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。我们只需要在webpack.config.js文件中写入以下代码：1devtool: 'inline-source-map' 就可以追踪源文件中错误和警告的功能。 使用观察模式根据此博文一步一步构建下来的萌友会发现，每次修改源文件后，都要重新使用$ webpack命令对文件重新进行打包构建，这在一定程度上增加了我们的重复工作。使用观察模式，你可以指示 webpack “watch” 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。你需要在package.json文件中引入执行命令： 接着，你可以在命令行中执行1$ npm run watch 执行成功后，你会看到 webpack 编译代码，然而却不会退出命令行。这是因为 script 脚本还在观察文件，此时修改main.js文件的内容，你会发现不需要重新手动构建程序，代码已经被重新编译了。 使用webpack-dev-serverwebpack-dev-server 提供了一个简单的 web 服务器，能够实时重新加载。首先，我们需要下载安装模块1$ cnpm install --save-dev webpack-dev-server 安装成功后，我们需要在webpack.config.js文件中告诉开发服务器，去哪里加载文件123devServer: &#123; contentBase: './dist'&#125; 以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。 接着，让我们在package.json文件中添加一个 script 脚本，可以直接运行开发服务器： 1"start": "webpack-dev-server --open" 现在，我们在命令行中运行$ npm start，就会看到浏览器自动加载页面。如果现在修改和保存任意源文件，web 服务器就会自动重新加载编译后的代码。 总结webpack的学习时间跨度很长，webpack要学习的东西很多，继续加油吧～]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack，一个广泛应用的模块打包器（一）——概念篇]]></title>
    <url>%2F2017%2F11%2F03%2Fwebpack%2F</url>
    <content type="text"><![CDATA[鉴于我在学习的过程使用webpack的频率较高，所以想着要记录一下webpack的一些核心的知识点，此博文涉及的知识点可能不深，但涵盖了webpack的主要内容，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 概念篇核心概念webpack 是一个现代JavaScript应用程序的模块打包器。当webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的bundle - 通常只有一个，由浏览器加载。在开始之前，我们需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 入口(Entry)webpack创建应用程序所依赖的关系图时，图的起点就是我们的入口起点。入口起点告诉webpack从哪里开始，可以认为是app的第一个启动文件。 单入口语法，用法：entry: string|Array 123module.exports = &#123; entry: '.src/app.js' //将src目录下的app.js文件作为入口文件&#125; 对象语法，用法：entry: {[entryChunkName: string]: string|Array}对象语法常用于：多页面应用程序，如 1234567module.exports = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125; 表面上告诉我们，webpack需要创建3个依赖图，这些依赖图彼此之间完成分离，互相独立的。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。 出口(Output)将所有文件归拢后，我们需要告诉webpack如何处理这些归拢在一起的文件。123456789const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;&#125;; 多个入口起点：出口处应该使用占位符来确保每个文件具有唯一的名称。12345678910module.exports = &#123; entry: &#123; app: __dirname + '.src/app.js', search: __dirname + './src/search.js' &#125;, output: &#123; path: __dirname + '/dist', filename: 'bundle-[name].js' //dist目录下将生成"bundle-app.js"和"bundle-search.js"文件 &#125;&#125;; 我们通过output.filename和output.path属性，来告诉输出文件的名称以及路径。 Loaderwebpack把每个文件(.css, .html, .less, .scss, .jpg等)都作为模块处理，然而 webpack 自身只理解 JavaScript。loader 可以使你在 import 或”加载”模块时预处理文件。loader在文件被添加到依赖图中时，将文件转换为模块。 识别出应该被对应的loader进行转换的文件。(test属性) 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）。(use属性) 在使用前，我们需要提前安装相对应的loader，如：1$ cnpm install --save-dev vue-loader 1234567891011121314const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.vue$/,loader: 'vue-loader' &#125; //用来解析vue后缀的文件 ] &#125;&#125;; 在应用程序中，我们有三种使用loader的方法： 配置（推荐）：在webpack.config.js文件中指定loader。 内联：在每个 import 语句中显式指定 loader，如： 1import Styles from 'style-loader!css-loader?modules!./styles.css'; CLI：在 shell 命令中指定它们，如： 1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 插件(Plugins)由于loader仅在每个文件的基础上执行转换，而插件更常用于（但不限于）在打包模块的 “compilation” 和 “chunk” 生命周期执行操作和自定义功能。想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中，多数插件可以通过选项(option)自定义。插件目的在于解决loader无法实现的其他事。由于插件可以携带参数/选项，你必须在webpack配置中，向plugins属性传入 new 实例。1234567891011121314151617181920const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.vue$/,loader: 'vue-loader' &#125; //用来解析vue后缀的文件 ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; 模块(Modules)在模块化编程中，开发者将程序分解成离散功能块，并称之为模块，每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。对比Node.js模块，webpack模块能够以各种方式表达它们的依赖关系，如： ES2015 import语句 CommonJS require()语句 AMD define和require语句 css/sass/less 文件中的 @import 语句 样式(url(…))或 HTML 文件img标签中的图片链接 webpack 通过 loader 可以支持各种语言和预处理器编写模块。 模块解析resolver是一个库，用于帮助找到模块的绝对路径。使用enhanced-resolve，webpack 能够解析三种文件路径： 绝对路径1import "C:\\Users\\user\\file"; 由于我们已经取得了文件的绝对路径，因此不需要进一步在做解析。 相对路径1import "../src/file1"; 在这种情况下，使用import或require的资源文件所在的目录被认为是上下文目录，在import/require中给定的相对路径，会添加此上下文路径，以产生模块的绝对路径。 模块路径1import "module/lib/file"; 模块将在resolve.modules中指定的所有目录内搜索。 构建目标(Targets)因为服务器和浏览器代码都可以用JavaScript编写，所以webpack提供了多种构建目标。123module.exports = &#123; target: 'node' //webpack会编译为用于「类Node.js」环境&#125;; 多个Target：尽管webpack不支持向target传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：1234567891011121314151617181920const path = require('path');const serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;const clientConfig = &#123; target: 'web', // 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ]; 上面的例子将在你的dist文件夹下创建lib.js和lib.node.js文件。 模块热替换模块热替换功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 总结webpack概念篇就差不多结束啦，其中包含webpack中核心的几个概念以及各自的用法，接下来我将继续记录webpack管理资源的相关知识点，希望能对大家有所帮助～]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel，一个广泛使用的转码器]]></title>
    <url>%2F2017%2F11%2F01%2Fbabel%2F</url>
    <content type="text"><![CDATA[随着JavaScript的飞速发展，浏览器的发展速度却不能与之相匹配，为了能够在现有的浏览器上使用js新的语法和新的数据类型，这时我们便需要一个转码器。Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码。Babel能将最新标准的JavaScript代码向下编译成浏览器普遍支持的版本，实现了“源码到源码”编译。比如，Babel能将新的ES2015的箭头函数语法：1const area = n =&gt; n * n; 转译为123const area = function area(n)&#123; return n * n;&#125;; 因为在学习Vue等过程中涉及到Babel的一些知识点，所以想着大概了解一下Babel的主要内容以及基本用法，文章内容涉及不深，如果在理解和用法上有偏差的话，还请大家不吝赐教～ 前期准备初始化项目在习惯的工作目录下新建一个文件夹，我取名为babel-blog，使用命令行进入babel-blog的工作目录，执行1$ npm init // 初始化并创建package.json文件 可以看到在babel-blog项目的根目录下创建了名为package.json的文件。 安装Babel命令行工具安装babel的命令行工具的目的是为了在命令行中使用babel。babel命令行工具可以全局安装也可以本地安装，官方文档推荐本地安装，原因有2点： 本地安装不同的项目可以使用不同版本的babel，你也可以单独对某个项目的babel进行升级等操作 每个项目单独安装的意味着对计算机环境没有依赖，便于移植 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来我们在babel-blog项目中安装babel命令行工具1$ cnpm install --save-dev babel-cli 安装成功后，可以在package.json文件中看到名为babel-cli的依赖包 本地安装的babel是不能够在直接命令行中运行的，为了在命令行中运行babel，我们可以配置package.json文件下的script选项1"build": "babel src -d lib" 配置成功后，当我们在终端运行npm run build时就会在命令行执行babel src -d lib，这也意味着我们要创建一个名为src的文件夹（ps：如果现在执行的话，项目会报错，它会提示我们src不存在，因为我们除了安装了babel-cli其他都还没有做呢～） .babelrc配置文件Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下：1234&#123; "presets": [], "plugins": []&#125; presets字段设定转码规则，在这里我们需要在项目中安装ES2015的转码规则12# ES2015转码规则$ cnpm install --save-dev babel-preset-es2015 然后将安装的规则加入.babelrc文件中1234&#123; "presets": ["es2015"], "plugins": [] &#125; 接下来我们在项目根目录下创建名为src的文件夹，其中创建一个名为index.js文件，我们就拿最开始的area箭头函数来进行演示：123const area = n =&gt; n * n;console.log(area(4)); 接下来，你就可以在命令行执行npm run build命令了，执行成功后你可以发现，在根目录下生成了一个名为lib的文件夹，其中有一个index.js文件，内容就是src下index.js通过babel转码生成的代码 到这里我们就已经学会了使用babel来进行简单的转码功能。是不是觉得很简单呢～ Babel扩展Babel中有很多包，常用的包有babel-node, babel-register, babel-core, babel-polyfill等，这些在实际应用中用的频率都是很高的。 babel-nodebable-node是babel-cli自带的命令，提供了一个支持ES6的REPL环境，它支持node的REPL环境的所有功能，而且可以直接运行ES6代码。首先我们需要全局安装babel-cli。1$ cnpm install --save-dev -g babel-cli 安装成功后，输入babel-node,PEPL环境或者直接执行js文件1$ babel-node 文件路径/文件名.后缀 babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。1$ cnpm install --save-dev babel-register 为了方便，我直接在刚刚新建的babel-blog项目中src文件夹下新建一个register.js文件1console.log("Hello babel-register!"); 如果我们用 node register.js 来运行它是不会使用 Babel 来编译的。所以我们需要设置 babel-register，我们在项目的根目录下创建一个名为console.js的文件，并引入babel-register以及register.js文件12require("babel-register");require("./src/register"); 此时执行1$ node console.js 可以发现命令行输出了register.js文件中的内容 “Hello babel-register!”。这样做可以把 Babel 注册到 Node 的模块系统中并开始编译其中 require 的所有文件。 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。借用阮一峰老师的例子：(字符串转码)transform方法的第一个参数是一个字符串，表示需要转换的ES6代码，第二个参数是转换的配置对象。 babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，为了解决这个问题，必须要使用babel-polyfill，为当前环境提供一个垫片。 Babel与其他工具集成Babel可以与很多构建工具（如 Browserify、Grunt、Gulp、Webpack等）进行集成。关于babel与Webpack构建工具的集成，在我使用webpack搭建vue项目——入门博客中就有使用到。 集成Webpack babel-preset-env，转译器，最常用的转译器。通过在.babelrc中配置env选项，可以让代码兼容不同版本的浏览器或者node。 这里我将使用原先的babel-blog项目，并将lib文件夹，src文件夹下的文件删除仅保留开始的index.js文件，当前目录结构如下： 进入项目工作目录，安装webpack，babel-preset-env和babel-loader123$ cnpm install --save-dev webpack$ cnpm install --save-dev babel-preset-env$ cnpm install --save-dev babel-loader 安装成功后，可以在package.json文件中看到相应的依赖包。 接下来在根目录下创建webpack.config.js文件 entry为入口文件，我们选择当前目录下，src文件夹下的index.js文件作为入口。output为输出选项，path为输出的目录，filename为输出文件名。感兴趣的朋友们可以戳戳Webpack中文文档进行学习哦～ 最重要的一点：我们要记得在.babelrc文件中设定相应的转码规则哦 在命令行执行1$ webpack 运行成功后，可以发现在根目录下创建了名为public文件夹，以及名为index.output.js输出文件 通过集成webpack构建工具，可以将转码后的文件打包。 总结写这篇博文的逻辑性可能不是很强，主要是边学习边记录，把Babel主要的知识点记录下来，作为Babel的一篇学习笔记，以便后续的深入学习，这里推荐一下阮一峰老师的 Babel入门推荐教程，这篇博文里面很多知识点都来自阮一峰老师的推荐课程～ 希望能对大家有所帮助～]]></content>
      <categories>
        <category>转码工具</category>
      </categories>
      <tags>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用iconfont创建项目图标]]></title>
    <url>%2F2017%2F10%2F31%2Ficonfont%2F</url>
    <content type="text"><![CDATA[在学习他人网站代码时，我常常会发现前端开发人员习惯使用1&lt;i class="iconfont icon-time"&gt;&lt;/i&gt; 来生成页面的图标，这打破了我们传统的方式——将icon图标以png等图片的形式下载下来，然后通过img标签引入页面中。在刚开始接触到这种方式时，我感到不解，想要试图在css文件中找到相应类的样式设置，认为是在css中设置了背景图，找寻无果…最近想要充实一下个人博客，也就想着要把这次学习的心路历程记录下来，以供后续的深入学习。初次学习可能有些地方讲解的不是很细致，还请各位不吝赐教～ 使用Iconfont的优点Iconfont其实就是指用字体文件取代图片文件，来展示图标、特殊字体等元素的一种方法。主要有以下4个优点 加载文件体积小，提高加载速度 可以直接通过css的font-size，color修改它的大小和颜色，可以缩放多个尺寸的图标，提高图标的可复用性 支持一些css3对文字的效果，例如：阴影、旋转、透明度等 兼容低版本浏览器相对于我们传统的将icon下载为图片的形式，使用iconfont确实方便不少。当我们项目要修改主色调时，iconfont只需要修改css中颜色属性即可，而传统模式则需要你重新下载，这样不仅增加了我们的开发时间，而且会让前端开发工作变得枯燥无味。 Iconfont使用流程在这里我们需要使用到第三方Iconfont在线服务（例如： 阿里巴巴Iconfont平台 ），个人比较偏向于阿里巴巴Iconfont平台，而在此文中也是在阿里巴巴Iconfont平台上进行操作的。 首先，我们打开阿里巴巴Iconfont平台（ps:使用阿里巴巴Iconfont平台需要你有github账号或者微博账号） 接下来，我们搜索我们想要的图标，建议使用英文搜索，匹配的icon可能更多哦～ 回车以后，你会看到很多有关于time的icon图标，选择你需要的那个，并添加至购物车中（如未登录的话，此时会要求你先登录）加入成功后你可以在右上角购物车处看到你所添加的icon 依此，你可以在项目中添加很多icon图标，这里就不一一演示了 接下来，我们将购物车中所有的icon图标打包在一个新建的项目中添加成功后，你可以看到你创建的项目中有你所添加的所有icon图标 建议使用：生成在线链接并在css文件中通过1@import url('链接地址') 引入资源也可以通过点击下载至本地，将zip文件解压后其中的文件如下 接下来，就是如何在项目中使用了在原来的html中我使用的是传统方式，将icon以图片的形式引入可以看到的效果如下 ———– 下载至本地需要进行的 ———–将刚刚解压的文件放置在项目的根目录下，可以对文件进行重命名，为了方便我重命名为icon-fonts，当前项目目录如下 接下来我们在头部引入icon-fonts中的iconfont.css文件 ———– 华丽丽的分割线 ———– 并使用i标签来替换传统方式 其中iconfont是必须的类名，icon-time是你在阿里巴巴Iconfont平台创建的项目中图标所对应的类名，如下图img是我自己创建的用来定位的css类你会发现icon已经成功的被我们引入了，并且替换了传统的img标签 你可以在css中任意设置icon图标的大小以及颜色，如下： 总结写到这里，也差不多结束了，在这篇文章里我简单介绍了iconfont在项目中的使用，在实际运用中，你可以把项目中所需要的图标都以这种方式引入，这样在用户要求更换icon主色调时，就仅需要统一修改icon图标的颜色即可，而不需要重新下载icon图片，这样也就在一定程度上减少了项目的开发时间，提高了项目的开发质量，更重要的是前端开发人员不会因为重复无用功儿感觉枯燥无味。 这些只是一些小小的应用，希望能对大家有所帮助～]]></content>
      <categories>
        <category>iconfont图标</category>
      </categories>
      <tags>
        <tag>iconfont 项目图标icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webpack搭建vue项目——入门]]></title>
    <url>%2F2017%2F10%2F25%2Fwebpack-vue%2F</url>
    <content type="text"><![CDATA[vue以数据为驱动，是近年来比较火的一个轻量级的前后端分离的框架，前段时间学习了vue的一些基本知识，明白了vue中指令等的使用，个人觉得较难的一部分当属于使用vue进行组件化开发，在vue.js专业中文开发者社区上有不少大牛们使用vue重构的一些例子，比如豆瓣，饿了么等，大家可以clone下来自己重构一下，建议初学者在豆瓣和饿了么两个中先选择豆瓣的例子，豆瓣的例子会相对简单直观一些。我在刚学习使用vue进行组件化开发时，常常会使用 1$ vue init webpack project-name 来初始化一个vue项目，接着在这个初始化完成的项目中进行vue的组件化开发。我们可能明白每一个配置文件以及文件夹中的相关内容，但使用webpack构建vue项目的过程又是怎样的？这就不得而知了。随着后来的学习，我开始自己慢慢使用webpack从零构建vue项目，踩了很多坑，可能也不是很深入，但是总想着能把这次过程写下来，以便后续的深入学习，初次学习可能理解以及步骤上会有偏差，还请各位不吝赐教～ webpack构建vue项目流程安装 首先需要你已下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装在你习惯使用的工作目录下新建文件夹，在这里我新建了一个名为webpack-vue-blog的文件夹（ps:项目名称中不可以含有空格，这在初始化时会报错的～大家注意一下，建议使用-或_代替），打开你的终端，进入到webpack-vue-blog的工作目录，使用1$ npm init //初始化并自动创建package.json文件，npm是node.js的命令 接下来是一些项目的相关信息，一路按enter键就可以了，之后你可以在package.json文件中看到项目的相关信息 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来就要安装vue webpack等相关的模块，在这里先大致介绍一下相关的命令 使用npm安装插件：命令提示符执行npm(cnpm) install [-g] [–save-dev] -g：全局安装 –save：将保存配置信息至package.json（package.json是nodejs项目配置文件） -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点 12345678910//安装vue$ cnpm install --save vue //安装webpack以及webpack测试服务器，默认安装是1.0版本的，所以必须指定版本号$ cnpm install --save-dev webpack@^2.1.0-beta.25 webpack-dev-server@^2.1.0-beta.9 //安装babel，一般的浏览器是不认识es6语法的，babel的作用是将ES6代码转为ES5代码，从而编译成浏览器认识的语法$ cnpm install --save-dev babel-core babel-loader babel-preset-es2015//用来解析vue的组件，.vue后缀的文件$ cnpm install --save-dev vue-loader vue-template-compiler//用来解析css$ cnpm install --save-dev css-loader file-loader 需要用到的模块我们已经安装完之后，就可以开始在package.json看到我们所安装的依赖包，在webpack-vue-blog目录下也会生成名为node_modules的文件夹 编码安装了这么多的依赖包，终于要进入编码的阶段了，打开你的编辑器，这里我使用的是VS Code工具进行编码，这个工具比较小，但是要安装相关的插件，我这里不详细介绍了哈，感兴趣的萌友们可以安装使用一下。现在我们的webpack-vue-blog工程目录下只有node_modules文件夹以及package.json文件接下来我们在根目录下新建src文件夹用来存放我们项目的源码，在src目录下新建App.vue以及main.js文件，其中App.vue是我们的入口页面，main.js是应用初始化入口文件1234567891011121314151617181920//App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 'This is your first webpack-vue project!' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789//main.jsimport Vue from 'vue'import App from './App.vue' // 将同目录下的App.vue导入/* 实例化一个vue */new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) render函数是渲染一个视图，然后提供给el挂载，如果没有render那页面什么都不会出来 Vue2.0的渲染过程： Vue实例选项对象的 render 方法作为一个函数，接受传入的参数 h 函数，返回 h(App) 的函数调用结果 Vue 在创建 Vue 实例时，通过调用 render 方法来渲染实例的 DOM 树 Vue 在调用 render 方法时，会传入一个 createElement 函数作为参数，也就是这里的 h 的实参是 createElement 函数，然后 createElement 会以 APP 为参数进行调用 [官方文档]:123456render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name 标签名称 this.$slots.default // 子组件中的阵列 )&#125; 接下来我们将进入webpack部分 戳进来学习webpack中文文档，在根目录下新建名为webpack.config.js的文件，用来进行相关的配置 webpack入口出口等核心概念中文文档 123456789101112131415161718192021222324252627282930313233//webpack.config.jsvar path = require('path');var webpack = require('webpack');module.exports = &#123; /* 入口文件 */ entry: './src/main.js', /* 输出 */ output: &#123; /* 输出目录，没有则新建 通过__dirname获得当前文件所在目录的完整目录名：*/ path: path.resolve(__dirname, './dist'), /* 静态目录，可以直接从这里取文件 */ publicPath: '/dist/', /* 文件名 */ filename: 'build.js' &#125;, module: &#123; rules: [ /* 用来解析vue后缀的文件 */ &#123; test: /\.vue$/, loader: 'vue-loader' &#125;, /* 用babel来解析js文件并把es6的语法转换成浏览器认识的语法 */ &#123; test: /\.js$/, loader: 'babel-loader', /* 排除模块安装目录的文件 */ exclude: /node_modules/ &#125; ] &#125;&#125; 我们当前的项目目录为：接下来我们将进行webpack的核心功能——模块打包1$ cnpm install -g webpack@^2.1.0-beta.25 //全局安装webpack，以便使用webpack命令进行打包等 进入webpack-vue-blog目录下并运行命令1$ webpack 执行完毕后你可以发现在根目录下新增了一个名为dist的文件夹，其中有个build.js文件，而这输出的文件夹名及文件名正是我们在webpack.config.js中配置好的。这么久还不能看效果，急死人了，不要着急，已经快要接近尾声啦！！接下来，我们在根目录下新建名为index.html的文件，并引入我们刚刚生成的build.js文件12345678910111213//index.html&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0"&gt; &lt;title&gt;webpack-vue-blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./dist/build.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接下来运行命令1$ webpack-dev-server 稍微等待一会，就会提示你已经运行成功啦，并且可以通过访问localhost:8080来访问我们的第一个使用webpack构建的vue项目。这样我们的使用webpack构建的vue项目也算是搭建完成了。 结语这是自搭建个人博客网站以来着手写的第一篇博客，当然，这只是一个很简单的项目，在后续深入学习中，你会发现程序员们会将babel的相关配置保存在.babelrc配置文件中，比如：相信大家在学习babel相关教程时会了解到 Babel入门推荐教程 希望能对萌友们有所帮助～]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
