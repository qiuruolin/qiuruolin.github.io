<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript设计模式之创建型设计模式]]></title>
    <url>%2F2018%2F01%2F31%2Fjs-creational-pattern%2F</url>
    <content type="text"><![CDATA[这段时间沉迷于学习JavaScript的设计模式，于是想着与之前所学的设计模式联系起来，对比学习。因为之前有了Java设计模式的部分基础，所以在学习JavaScript设计模式时会进行一些简单的比较记忆，主要的内容安排是模式的定义、模式对应的类图以及模式的简单实现。此篇博文主要记录创建型设计模式的学习过程，如果在某些地方表述不正确的，还希望大家能够指出，共同进步～ 创建型设计模式创建型设计模式是一类处理对象创建的设计模式，主要应用于创建对象。包括简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式以及单例模式。 简单工厂模式简单工厂模式，又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。Java语言简单工厂模式的类图表达为：我们可以仿照Java语言的类图绘制类图为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 简单工厂模式var Ball = function()&#123;&#125;Ball.prototype = &#123; getMember: function()&#123; throw new Error("抽象方法不能调用") &#125;, getBallSize: function()&#123; console.log("抽象方法不能调用"); &#125;&#125;var Basketball = function()&#123; this.intro = "篮球盛行于美国";&#125;Basketball.prototype = new Ball();Basketball.prototype = &#123; getMember: function()&#123; console.log("每个队伍需要5名队员"); &#125;, getBallSize: function()&#123; console.log("篮球很大"); &#125;&#125;var Football = function()&#123; this.intro = "足球在世界范围内流行";&#125;Football.prototype = new Ball();Football.prototype = &#123; getMember: function()&#123; console.log("每个队伍需要11名队员"); &#125;, getBallSize: function()&#123; console.log("足球很大"); &#125;&#125;var Tennis = function()&#123; this.intro = "每年有很多网球系列赛";&#125;Tennis.prototype = new Ball();Tennis.prototype = &#123; getMember: function()&#123; console.log("每个队伍需要1名队员"); &#125;, getBallSize: function()&#123; console.log("网球很小"); &#125;&#125;// 运动工厂var SportsFactory = function()&#123;&#125;SportsFactory.prototype = &#123; getSport: function(name)&#123; switch(name)&#123; case 'NBA': return new Basketball(); case 'wordCup': return new Football(); case 'FrenchOpen': return new Tennis(); &#125; &#125;&#125;// Testvar factory = new SportsFactory();var footnall = factory.getSport("wordCup");console.log(footnall);console.log(footnall.intro);footnall.getMember(); 简单工厂模式最主要的是所创建的工厂对象SportsFactory，工厂函数getSport()根据传入参数的不同返回不同类的实例。在此例中Football、Basketball、Tennis都继承了抽象类Ball，Ball中定义了两个抽象方法getMember()和getBallSize()，在具体类中重写这两个方法，若子类为重写父类中的抽象方法则会抛出异常： 当然因为JavaScript的特性，我们可以不需要Ball类，在Java语言中引入抽象类，主要是在客户端使用过程中，可以使用父类对象来替代具体的子类对象（里氏代换原则），如：12Ball ball; ball = factory.getSport("wordCup"); 在JavaScript语言中，你还可以使用一个对象来代替多个类123456789101112131415161718192021222324252627// 寄生方式// 使用一个对象代替多个类，提取相似function createSports(type, intro, member, size)&#123; var o = new Object(); o.intro = intro; if(type == 'football')&#123; console.log("foolball") &#125; else if(type == 'basketball')&#123; console.log("basketball") &#125; else if(type == 'tennis')&#123; console.log("tennis") &#125; o.getMember = function()&#123; console.log(member); &#125; o.getBallSize = function()&#123; console.log(size); &#125; return o;&#125;// Testvar basketball = createSports("basketball", "This is a Basketball", "5", "big");console.log(basketball);console.log(basketball.intro);basketball.getMember(); 这种方式将相似的部分提出，不相似的部分进行针对性的处理。 这两种方式存在一定的差异，第一种方式是通过类实例化对象创建的，第二种方式是通过创建一个新对象然后包装增强其属性和功能来实现的。选择哪种工厂方式来实现你的需求还要看你是如何分析你的需求的。 工厂方法模式工厂方法模式，通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。Java语言工厂方法模式类图表示为：工厂方法模式让子类决定将哪一种产品实例化，让一个类的实例化延迟到其子类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 工厂方法模式// 使用安全模式创建工厂类var Factory = function(type, content)&#123; if(this instanceof Factory)&#123; var s = new this[type](content); return s; &#125; else&#123; return new Factory(type, content); &#125;&#125;// 工厂原型中设置创建所有类型数据对象的基类Factory.prototype = &#123; Java: function(content)&#123; // 具体创建产品的过程 console.log(content); &#125;, JavaScript: function(content)&#123; console.log(content); &#125;, UI: function(content)&#123; console.log(content); &#125;, PHP: function(content)&#123; console.log(content); &#125;&#125;// Testvar data = [ &#123; type: 'JavaScript', content: 'javascript' &#125;, &#123; type: 'Java', content: 'java' &#125;, &#123; type: 'UI', content: 'UI' &#125;, &#123; type: 'PHP', content: 'PHP' &#125;, &#123; type: 'JavaScript', content: 'other javascript' &#125;]for(var d of data)&#123; Factory(d.type, d.content)&#125; 在实现工厂方法模式时，采用了安全模式创建工厂类，安全模式可以避免用户使用类时缺少new关键词而导致的错误。JavaScript中使用安全模式创建工厂类，在工厂原型中创建所有类型数据对象的基类，通过使用时向工厂类传递数据类型和数据内容两个参数，来动态的实例化相应的产品类。使用工厂方法模式可以避免使用者和对象类之间的耦合。 抽象工厂模式抽象工厂模式，通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。JavaScript语言虽然保留abstract关键字，但目前来说还不能像Java语言那样轻松地创建。我们可以在类的方法中手动地抛出错误来模拟抽象类。抽象工厂模式涉及的对象比较多，使用UML类图可以表示为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134// 抽象工厂模式var Vehicle = function(subType, superType)&#123; // 判断抽象产品类中是否有该抽象类 if(typeof Vehicle[superType] === 'function')&#123; function F()&#123;&#125;; // 继承父类的属性和方法 F.prototype = new Vehicle[superType](); // 将子类constructor属性指向子类 subType.constructor = subType; // 子类原型继承父类 subType.prototype = new F(); &#125; else&#123; throw new Error("未创建该抽象类") &#125;&#125;// 小汽车抽象类Vehicle.Car = function()&#123; this.type = 'car';&#125;Vehicle.Car.prototype = &#123; getPrice: function()&#123; return new Error("抽象方法不能调用") &#125;&#125;// 公共汽车抽象类Vehicle.Bus = function()&#123; this.type = 'bus';&#125;Vehicle.Bus.prototype = &#123; getPrice: function()&#123; return new Error("抽象方法不能调用") &#125;&#125;// 汽车具体类——宝马汽车var BMWCar = function(price)&#123; this.price = price;&#125;Vehicle(BMWCar, 'Car');BMWCar.prototype.getPrice = function()&#123; return this.price;&#125;// 汽车具体类——兰博基尼汽车var LamborghiniCar = function(price)&#123; this.price = price;&#125;Vehicle(LamborghiniCar, 'Car');LamborghiniCar.prototype.getPrice = function()&#123; return this.price;&#125;// 公共汽车具体类——宝马公共汽车var BMWBus = function(price)&#123; this.price = price;&#125;Vehicle(BMWBus, 'Bus');BMWBus.prototype.getPrice = function()&#123; return this.price;&#125;// 公共汽车具体类——兰博基尼公共汽车var LamborghiniBus = function(price)&#123; this.price = price;&#125;Vehicle(LamborghiniBus, 'Bus');LamborghiniBus.prototype.getPrice = function()&#123; return this.price;&#125;// 抽象工厂var VehicleFactory = function(subType, superType)&#123; // 判断抽象工厂中是否有该抽象类 if(typeof VehicleFactory[superType] === 'function')&#123; function F()&#123;&#125;; // 继承父类的属性和方法 F.prototype = new VehicleFactory[superType](); // 将子类constructor属性指向子类 subType.constructor = subType; // 子类原型继承父类 subType.prototype = new F(); &#125; else&#123; throw new Error("未创建该抽象类") &#125;&#125;// 宝马工厂VehicleFactory.BMW = function(type)&#123; this.factory = '宝马'&#125;VehicleFactory.BMW.prototype = &#123; create: function(type)&#123; return new Error("抽象方法不能调用") &#125;&#125;// 兰博基尼工厂VehicleFactory.Lamborghini = function(type)&#123; this.factory = '兰博基尼'&#125;VehicleFactory.Lamborghini.prototype = &#123; create: function(type)&#123; return new Error("抽象方法不能调用") &#125;&#125;// 具体工厂——宝马工厂var BMWFactory = function()&#123;&#125;VehicleFactory(BMWFactory, 'BMW');BMWFactory.prototype = &#123; create: function(type)&#123; console.log("宝马工厂生产" + type) &#125;&#125;// 具体工厂——兰博基尼工厂var LamborghiniFactory = function()&#123;&#125;VehicleFactory(LamborghiniFactory, 'Lamborghini');LamborghiniFactory.prototype = &#123; create: function(type)&#123; console.log("兰博基尼工厂生产" + type) &#125;&#125;// Testvar testCar = new BMWCar(10000);var testBus = new BMWBus(100);var testBMW = new BMWFactory();testBMW.create(testCar.type);testBMW.create(testBus.type) 首先定义了抽象汽车类Car和抽象公共汽车类Bus，创建了Car抽象汽车的具体产品汽车子类宝马汽车子类BMWCar和兰博基尼汽车子类LamborghiniCar，Bus抽象公共汽车的具体产品公共汽车子类宝马公共汽车子类BMWBus和兰博基尼公共汽车子类LamborghiniBus，然后定义了抽象工厂类VehicleFactory，创建了具体工厂子类宝马工厂BMWFactory和兰博基尼工厂VehicleFactory。一个工厂负责创建一个产品族中的产品，BMWCar和LamborghiniCar同属于Car的产品等级结构中，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象， 建造者模式建造者模式，将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。建造者模式关注的是对象创建的细节，使用UML类图表示类之间的关系如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 建造者模式——关心对象创建的整个过程// 应聘者类var Human = function(param)&#123; this.skill = param &amp;&amp; param.skill || '保密'; this.hobby = param &amp;&amp; param.hobby || '保密';&#125;Human.prototype = &#123; getSkill: function()&#123; return this.skill; &#125;, getHobby: function()&#123; return this.hobby; &#125;&#125;// 实例化姓名类var Named = function(name)&#123; var that = this; (function(name, that)&#123; that.wholeName = name; if(name.indexOf(' ' &gt; -1))&#123; that.firstName = name.slice(0, name.indexOf(' ')); that.secondName = name.slice(name.indexOf(' ') + 1); &#125; &#125;)(name, that);&#125;// 实例化职位类var Work = function(work)&#123; var that = this; (function(work, that)&#123; switch(work)&#123; case 'code': that.work = '工程师'; that.workDescript = '每天沉醉于编程'; break; case 'UE': that.work = '设计师'; that.workDescript = '设计更似一种艺术'; break; case 'teach': that.work = '教师'; that.workDescript = '分享也是一种快乐'; break; default: that.work = work; that.workDescript = 'not know'; break; &#125; &#125;)(work, that);&#125;Work.prototype = &#123; changeWork: function(work)&#123; this.work = work; &#125;, changeDescript: function(setence)&#123; this.workDescript = setence; &#125;&#125;// 应聘者建造者var Person = function(name, work)&#123; var _person = new Human(); _person.name = new Named(name); _person.work = new Work(work); return _person;&#125;// Testvar person = new Person('xiao ming', 'code');console.log(person.skill);console.log(person.name.firstName);console.log(person.name.secondName);console.log(person.work.work);console.log(person.work.workDescript);person.work.changeDescript('更改职位描述！');console.log(person.work.workDescript); 在事例代码中应聘者Human类充当UML类图中的Product类，应聘者建造者Person类充当UML类图中的ConcreteBUilder类，测试代码部分可以看作是UML类图中的Director类，实例化职位类Work和实例化姓名类Named是Human的创建过程。建造者模式可以看作是为一个对象添加新的信息后返回新对象的过程。 原型模式原型模式，用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。原型模式在于通过复制这个原型来创建新的对象，可以复制原型对象的属性及方法来创建。下例代码实现了使用原型模式来复制多个原型对象来对新对象的创建1234567891011121314151617181920212223242526272829303132333435363738// 对象复制方法function prototypeExtend()&#123; var F = function()&#123;&#125;, args = arguments, len = args.length, i = 0; for(; i &lt; len; i++)&#123; // 遍历每个模版对象中的属性 for(var j in args[i])&#123; // 将属性复制到缓存类原型中 F.prototype[j] = args[i][j]; &#125; &#125; return new F();&#125;// Testvar penguin = prototypeExtend( &#123; speed: 20, swim: function()&#123; console.log("游泳速度：" + this.speed); &#125; &#125;, &#123; run: function()&#123; console.log("奔跑速度：" + this.speed); &#125; &#125;, &#123; jump: function()&#123; console.log("跳跃动作"); &#125; &#125;)penguin.swim();penguin.run(10);penguin.jump(); 单例模式单例模式，又称为单体模式，是只允许实例化一次的对象类。 用途一： 定义命名空间，下例代码中Qiu即为命名空间，使用其中方法时需Qiu.xx() 123456789// 单例模式var Qiu = &#123; g: function(id)&#123; return document.getElementById(id); &#125;, css: function(id, key, value)&#123; this.g(id).style[key] = value; &#125;&#125; 用途二： 管理静态变量——只能访问不能修改 12345678910111213141516var Conf = (function()&#123; // 私有变量 var conf = &#123; MAX_NUM: 100, MIN_NUM: 1, COUNT: 1000 &#125; // 返回取值器对象 return &#123; get: function(name)&#123; return conf[name]? conf[name]: null; &#125; &#125;&#125;)();var count = Conf.get('COUNT');console.log(count); 用途三： 惰性单例12345678910111213141516171819// 惰性单例var LazySingle = (function()&#123; var _instance = null; function Single()&#123; // 定义私有属性和方法 return &#123; publicMethod: function()&#123;&#125;, publicProperty: '1.0' &#125; &#125; // 获取单例对象接口 return function()&#123; if(!_instance)&#123; _instance = Single(); &#125; return _instance; &#125;&#125;)();console.log(LazySingle().publicProperty); 总结JavaScript设计模式之创建型设计模式到此也就告一段落了，因为其中有部分设计模式之前因为时间不足未曾深入学习，所以可能有些理解的不够透彻，如果有存在描述不当的地方，欢迎大家指出～共同进步～ 下一篇我将记录JavaScript设计模式中结构型设计模式的学习过程～加油加油～]]></content>
      <tags>
        <tag>简单工厂模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之继承]]></title>
    <url>%2F2018%2F01%2F30%2Fjs-herit%2F</url>
    <content type="text"><![CDATA[这段时间主要学习了JavaScript的知识，不得不感慨js语言的强大与灵活。此次主要是对JavaScript中的继承进行学习记录与总结，但免不了涉及到面向对象编程、封装以及多态的相应知识。接下来我将先介绍什么是面向对象编程以及为什么要采用面向对象来进行编程，接着介绍一下面向对象中的重要特性——封装，然后介绍js实现继承的六种方法，最后简单介绍一下js实现多态的方式。此篇博文主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 面向对象编程什么是面向对象编程面向对象编程通俗来说，就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性）和动作（方法）。 在Java语言中通过class关键字就可以很方便地声明一个对象，但在JavaScript语言中因为没有通过class实现类封装的方法，所以通常是通过一些特性模仿实现的，但这也带来了极高的灵活性，使我们编写的代码更自由。 为什么要引入面向对象的思想由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护，代码复用性强，能够在很大程度上促进团队的协同合作。 前置要点在JavaScript中创建一个类很容易，首先声明一个函数保存在一个变量中，然后在函数（类）的内部通过对this变量添加属性或者方法来实现对类添加属性或者方法，例如：12345var Book = function(id, bookName, price)&#123; this.id = id; this.bookName = bookName; this.price = price;&#125; 因为类是一个对象，有一个原型prototype用于指向其继承的属性和方法，所以也可以通过在类的原型上添加属性或方法。但通过this定义的属性和方法是该对象自身拥有的属性和方法，而prototype指向的是其继承的属性和方法123Book.prototype.display = function()&#123; //展示这本书&#125; 或12345Book.prototype = &#123; display: function()&#123; //展示这本书 &#125;&#125; 但两种方式不要混用。当创建一个函数或者对象时都会为其创建一个原型对象prototype，在prototype中又会像创建this一样创建一个constructor属性，指向拥有整个原型对象的函数或对象，也就是🌰中的Book对象。 封装封装（Encapsulation）是面向对象方法的重要特性，就是把对象的属性和方法结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过此特性即可创建类的私有变量以及私有方法。 在函数内部通过this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到，因此可以通过this创建对象的公有属性和公有方法。 通过this创建的方法，不但可以访问这些对象的公有属性和公有方法，还可以访问到其私有属性和私有方法，所以又称这些方法为特权方法 类外面通过点语法定义的属性以及方法被称为类的静态公有属性和类的静态公有方法 123456789101112131415161718192021222324252627var Book = function(id, name, price)&#123; // 私有属性 var num = 1; // 私有方法 function checkId()&#123;&#125; // 特权方法 this.getName = function()&#123;&#125;; this.getPrice = function()&#123;&#125;; this.setName = function()&#123;&#125;; this.setPrice = function()&#123;&#125;; // 对象公有属性 this.id = id; // 对象公有方法 this.copy = function()&#123; console.log(num) &#125;; // 构造器 this.setName(name); this.setPrice(price);&#125;// 类静态公有属性（对象不能访问）Book.isChinese = true;// 类静态公有方法（对象不能访问）Book.resetTime = function()&#123; console.log('new time');&#125; 测试代码：12345678var book = new Book(11, 'JavaScript 设计模式', 50);console.log(book.num);book.copy();console.log(book.id);console.log(book.isJSBook);console.log(book.isChinese);console.log(Book.isChinese);Book.resetTime(); 运行结果为： 继承继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。JavaScript中并没有实现继承的现有机制，接下来我将会介绍JavaScript中实现继承的几种方法。 方法一： 类式继承12345678910111213141516171819202122232425// 类式继承function SuperClass()&#123; this.superValue = true; this.book = ['JavaScrpt', 'html', 'css'];&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;function SubClass()&#123; this.subValue = false;&#125;// 继承父类SubClass.prototype = new SuperClass();//继承之后再添加子类公有方法SubClass.prototype.getSubValue = function()&#123; return this.subValue;&#125;var instance = new SubClass();console.log(instance.getSubValue());console.log(instance.getSuperValue()); 类式继承中实现继承的主要方法是SubClass.prototype = new SuperClass();SubClass的原型被赋予了SuperClass的实例，因而SubClass的原型继承了SuperClass。类式继承存在两个缺点： 由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的公有属性要是引用类型，就会在子类中被所有实例共用，因此一个子类的实例更改子类原型从父类构造函数中继承来的公有属性就会直接影响到其他子类。12345var instance1 = new SubClass();var instance2 = new SubClass();console.log(instance2.book);instance1.book.push('设计模式');console.log(instance2.book); 由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。 因为类式继承存在的两个缺点，所以引出了第二种继承方法——构造函数继承 方法二： 构造函数继承1234567891011121314151617181920212223// 构造函数继承function SuperClass(id)&#123; this.id = id; this.books = ['JavaScrpt', 'html', 'css'];&#125;SuperClass.prototype.showBooks = function()&#123; console.log(this.books);&#125;function SubClass(id)&#123; // 构造函数继承，使用call来更改函数的作用环境 SuperClass.call(this, id);&#125;var instance1 = new SubClass(10);var instance2 = new SubClass(20);instance1.books.push("Java");console.log(instance1.id);console.log(instance1.books);console.log(instance2.id)console.log(instance2.books); SuperClass.call(this, id);这条语句是构造函数继承的精华，call方法可以更改函数的执行环境，因此在子类中，对SuperClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然就继承了父类的公有属性。由于构造函数继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承。1instance1.showBooks(); 因而引出了第三种继承方法——组合继承 方法三： 组合继承组合继承是将类式继承和构造函数继承组合起来实现继承的一种方式。1234567891011121314151617181920212223242526272829303132333435363738// 组合继承function SuperClass(name)&#123; this.name = name; this.books = ['JavaScrpt', 'html', 'css'];&#125;SuperClass.prototype= &#123; getName: function()&#123; console.log(this.name); &#125;, showBooks: function()&#123; console.log(this.books); &#125;&#125;function SubClass(name, time)&#123; // 调用父类构造函数 SuperClass.call(this, name); this.time = time;&#125;SubClass.prototype = new SuperClass();SubClass.prototype.getTime = function()&#123; console.log(this.time);&#125;var instance1 = new SubClass('js book', 2010);// 调用父类构造函数instance1.books.push("Java");instance1.showBooks();instance1.getName();instance1.getTime();var instance2 = new SubClass('css book', 2021);instance2.showBooks();instance2.getName();instance2.getTime(); 组合继承解决了类式继承和构造函数继承存在的问题，但仍然不是完美的继承方法，因为在组合继承中调用了两次父类构造函数，在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。 最完美的继承方法是——寄生组合式继承，在学习寄生组合式继承之前，我们需要了解原型式继承、寄生式继承方法的实现。 方法四： 原型式继承1234567891011121314151617181920212223242526272829// 原型式继承function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;var book = &#123; name: "js book", alikeBook: ["css book", "html book"]&#125;var newBook = inheritObject(book);newBook.name = "ajax book";newBook.alikeBook.push("xml book");var otherBook = inheritObject(book);otherBook.name = "flash book";otherBook.alikeBook.push("as book");// 存在同类式继承一样的问题：共享属性console.log(newBook.name);console.log(newBook.alikeBook);console.log(otherBook.name);console.log(otherBook.alikeBook);console.log(book.name);console.log(book.alikeBook); 原型式继承引入一个过渡对象，通过过渡对象的原型继承父对象，返回过渡对象的实例来实现继承。原型式继承是对类式继承的一次封装，所以类式继承的问题在原型式继承中也会出现。 方法五： 寄生式继承12345678910111213141516171819202122232425262728293031// 寄生式继承——对原型继承的第二次封装function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;var book = &#123; name: "js book", alikeBook: ["css book", "html book"]&#125;// 二次封装 优点：对继承的对象进行了拓展function createBook(obj)&#123; var o = new inheritObject(obj); // 拓展新对象 o.getName = function()&#123; console.log(this.name); &#125;; // 返回拓展后的新对象 return o;&#125;var newBook = createBook(book);var otherBook = createBook(book);newBook.getName();console.log(newBook.alikeBook);newBook.alikeBook.push('Java');console.log(otherBook.alikeBook); 寄生式继承是对原型式继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展。仍然存在属性共享的问题。 方法六： 终极继承者——寄生组合式继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 寄生组合式继承：寄生式继承＋构造函数继承function inheritObject(o)&#123; // 声明一个过渡对象 function F()&#123;&#125;; // 过渡对象的原型继承父对象 F.prototype = o; // 返回过渡对象的实例，该实例的原型继承了父对象 return new F();&#125;// 处理的不是对象，而是类的原型function inheritPrototype(subClass, superClass)&#123; // 复制一份父类的原型副本保存在变量中 var p = new inheritObject(superClass.prototype); // 修正因为重写子类类型导致子类的constructor属性被修改 p.constructor = subClass; // 设置子类的原型 subClass.prototype = p;&#125;function SuperClass(name)&#123; this.name = name; this.colors = ["red", "green", "yellow"]&#125;SuperClass.prototype.getName = function()&#123; console.log(this.name);&#125;function SubClass(name, time)&#123; SuperClass.call(this, name); this.time = time;&#125;inheritObject(SubClass, SuperClass);SubClass.prototype.getTime = function()&#123; console.log(this.time);&#125;// Testvar instance1 = new SubClass('js book', 2014);var instance2 = new SubClass('css book', 2020);instance1.colors.push("grown");console.log(instance1.colors);console.log(instance2.colors);instance1.getTime();instance2.getTime(); 寄生组合式继承是将寄生式继承和构造函数继承组合在一起的继承方法。 通过寄生式继承重新继承父类的原型。我们继承的仅仅是父类的原型，不再需要调用父类的构造函数。因为在构造函数继承中我们已经调用了父类的构造函数，所以我们需要的就是父类的原型对象的一个副本，而这个副本我们通过原型继承，即inheritObject()方法便可得到。因为对父类原型对象复制得到的复制对象p中的constructor指向的不是subClass子类对象，因此寄生式继承中要对复制对象p做一次增强，修复constructor指向不正确的问题，最后将得到的复制对象p赋值给子类的原型，这样，子类的原型就继承了父类的原型并且没有执行父类的构造函数。 寄生组合式继承是JavaScript实现继承的终极继承方式，也就是说，使用寄生组合式继承可以解决类式继承共享属性的问题、构造函数继承无法继承原型prototype上的属性的问题以及组合继承调用两次父类构造函数的问题。但是寄生组合式继承也比较不好理解，我已经在代码部分都写上了注释，供大家参考理解～ 多继承当前流行的用于继承单对象属性的extends方法，是通过对对象中属性的复制来实现的。JavaScript也可以使用属性复制的方式来实现多继承：123456789101112// 多继承——对对象中的属性的一个复制过程Object.prototype.mix = function()&#123; var i = 0, len = arguments.length, arg; for(; i &lt; len; i++)&#123; arg = arguments[i]; for(var property in arg)&#123; this[property] = arg[property]; &#125; &#125;&#125; 多态多态通俗来说就是同一个方法多种调用方式。在JavaScript中通过对传入的参数进行判断来实现多种调用方式。如：123456789101112131415161718// 多态function add()&#123; var arg = arguments, len = arg.length; switch(len)&#123; case 0: return 10; case 1: return 10 + arg[0]; case 2: return arg[0] + arg[1]; &#125;&#125;// Testconsole.log(add());console.log(add(5));console.log(add(1, 7)); 总结封装、继承与多态是面向对象中的重要特性，从JavaScript的角度上实现这三个特性，让我感受到JavaScript的灵活与强大。因为本学期上了伟帅的设计模式的课，对设计模式颇有兴趣，接下来我将会学习JavaScript中的设计模式，并将学习过程记录下来～]]></content>
      <tags>
        <tag>js 继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack，一个广泛应用的模块打包器（二）——资源管理模块]]></title>
    <url>%2F2017%2F11%2F20%2Fwebpack-guide%2F</url>
    <content type="text"><![CDATA[继上一篇博文webpack，一个广泛应用的模块打包器（一）——概念篇完成之后，时隔一段时间没有学习webpack了，主要是最近有点小忙耽搁了。此篇博文主要是作为webpack的学习指南，理解和掌握webpack提供的各种工具和特性，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 安装首先需要你下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装，在使用webpack的过程中我们需要大量的使用node中的npm包管理工具，npm主要的使用场景有： 用户可以在npm服务器上下载别人编写的第三方包到本地使用; 用户可以在npm服务器上下载并安装别人编写的命令行程序到本地使用; 还可以将自己编写的包或命令行程序上传到npm服务器供他人使用。 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 全局安装1npm install --global webpack 全局安装将使webpack在全局环境下可用，但不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 本地安装1npm install --save-dev webpack 对于大多数项目，我们建议本地安装。这可以使我们在引入破坏式变更的依赖时，更容易分别升级项目。通常，webpack 通过运行一个或多个 npm scripts，会在本地 node_modules 目录中查找安装的 webpack。 起步为了后续更好的进行知识点的演示，我们先进行简单的项目准备。我在常用的工作目录下新建了一个名为webpack-blog的文件夹。命令行进入webpack-blog的工作目录执行1234//初始化并创建package.json文件$ npm init //在项目中安装webpack依赖包$ cnpm install --save-dev webpack 在根目录下创建名为webpack.config.js的文件以及我们的入口文件/src/main.js文件，webpack.config.js是我们这次主要的文件，是webpack的配置文件。构建好工作目录后，我们来根据上一节简述过的webpack核心知识来简单使用一下webpack。首先，我们在src目录下的main.js文件中编写简单的js代码：1console.log("Welcome to your first webpack test!"); 接着，我们来到webpack.config.js文件，并设置webpack打包所需的入口起点以及输出文件配置：12345678910var path = require('path');var webpack = require('webpack');module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;&#125; 简单介绍一下上述代码，entry是模块打包的入口起点，它指示webpack根据src目录下的main.js文件来构建工程的依赖图；require()是node.js中常用的一个导入模块的操作，path.resolve()是获取绝对路径的方法，__dirname 用于获取当前文件所在目录的完整目录名。此代码用于查找dist文件夹，如果目录下没有dist文件夹则新建，并将通过打包创建后的webpack.bundle.js文件放入dist文件夹中。 接着，我们执行1$ webpack 命令，对工程进行打包构建，执行成功后，我们可以在根目录下看到新建的dist文件夹下有一个新建的webpack.bundle.js文件，有点绕～ 最后，我们在src目录下新建一个名为index.html的文件，并以script标签的形式引入生成的webpack.bundle.js文件，在浏览器中打开index.html，你会发现页面上空空如也，什么都没有～别着急，打开浏览器的控制台，你可以看到在控制台中输出了“Welcome to your first webpack test!”，我们对webpack的第一次简单应用就成功啦。 当然这只是一个超简单的例子，接下来我们将对这个例子进行扩充，进而展示webpack强大的功能。 管理资源加载CSS为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：1$ cnpm install --save-dev style-loader css-loader 安装成功后可以在package.json文件中的devDependencies项中看到新安装的style-loader和css-loader模块。接着，我们在webpack.config.js文件中配置模块的使用规则：12345678module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ]&#125; 简单介绍以上代码，test用于识别出应该被对应的loader进行转换的文件，以上代码表示loader需要识别.css为后缀的文件，use属性转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）。 下一步，我们尝试一下在项目src目录下添加style.css文件，并将其导入我们的入口文件main.js中我们修改main,js文件中的内容，以便于在页面中更直观地看到效果。1234var element = document.createElement('div');element.setAttribute("class", "hello");element.innerHTML = "Welcome to your first webpack test!";document.body.appendChild(element); 此时经过$ webpack命令打包后，在浏览器打开index.html文件可以看到，页面结构为页面效果为： 接下来我们在创建的style.css文件中写入简单的样式来验证webpack加载CSS的功能123.hello&#123; color: red;&#125; 在main.js文件中引入style.css文件1import './style.css'; 再次使用$ webpack命令打包后，我们在浏览器中打开index.html文件，我们可以看到Welcome to your first webpack test!输出为红色。 查看页面的head标签，可以发现页面已经包含了我们在main.js文件中导入的style.css文件。 加载图片使用 file-loader，我们可以轻松地将页面中需要的背景图片或者图标混合到 CSS 中，首先还是要安装模块依赖包：1$ cnpm install --save-dev file-loader 同样的，我们需要在webpack.config.js文件中配置应用规则： 此段规则表明程序可以加载以.png .svg .jpg .gif为后缀名的文件。我们可以直接在style.css文件中添加background样式来引入图片，为了让背景图片完整地显示出来，我们为hello这个div设置了300px的高度12345.hello&#123; height: 300px; color: red; background: url('./logo.png');&#125; 重新执行$ webpack命令，我们可以看到页面效果为： 图片稀缺，就拿了一张之前工程中现有的vue框架的logo来用～如果你检查img元素，你将看到实际的文件名已更改为像 82b9c7a5a3f405032b1db71a25f67021.png 一样。这意味着 webpack 在 src 文件夹中找到我们的文件，并成功处理过它了！ 加载字体 加载字体与加载图片相同，也使用的是file-loader来加载字体文件，加载字体使用的正则规则如：1test: /\.(woff|woff2|eot|ttf|otf)$/ 与加载图片文件相同，加载字体需要在css文件中引入字体文件，可以通过一个 @font-face 声明引入。用法如下： 加载数据在我们实际运用中，不仅仅要加载图片及字体文件，还可能需要加载有用的资源还有数据，如 JSON 文件，CSV、TSV 和 XML。JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。而要导入 CSV、TSV 和 XML类型的数据，就需要我们安装csv-loader和xml-loader模块来进行加载数据。首先，我们还是需要在项目中安装相关模块：1$ cnpm install --save-dev csv-loader xml-loader 接着，我们同样需要在webpack.config.js文件中配置相关的应用规则，规则如下：12345678 &#123; test: /\.(csv|tsv)$/, use: ['csv-loader']&#125;,&#123; test: /\.xml$/, use: ['xml-loader']&#125; 接下来，我们在src目录下添加名为data.xml的数据文件，data.xml内容如下： 我们在main.js文件中解析data.xml文件中的数据，主要增加以下两行代码：12import Data from './data.xml';console.log(Data); 再次执行$ webpack命令后，再次在浏览器上打开index.html文件，我们可以在控制台输出了data.xml文件解析后的数据： 开发Source Map当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。这并通常没有太多帮助，因为你可能需要准确地知道错误来自于哪个源文件。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。我们只需要在webpack.config.js文件中写入以下代码：1devtool: 'inline-source-map' 就可以追踪源文件中错误和警告的功能。 使用观察模式根据此博文一步一步构建下来的萌友会发现，每次修改源文件后，都要重新使用$ webpack命令对文件重新进行打包构建，这在一定程度上增加了我们的重复工作。使用观察模式，你可以指示 webpack “watch” 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。你需要在package.json文件中引入执行命令： 接着，你可以在命令行中执行1$ npm run watch 执行成功后，你会看到 webpack 编译代码，然而却不会退出命令行。这是因为 script 脚本还在观察文件，此时修改main.js文件的内容，你会发现不需要重新手动构建程序，代码已经被重新编译了。 使用webpack-dev-serverwebpack-dev-server 提供了一个简单的 web 服务器，能够实时重新加载。首先，我们需要下载安装模块1$ cnpm install --save-dev webpack-dev-server 安装成功后，我们需要在webpack.config.js文件中告诉开发服务器，去哪里加载文件123devServer: &#123; contentBase: './dist'&#125; 以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。 接着，让我们在package.json文件中添加一个 script 脚本，可以直接运行开发服务器： 1"start": "webpack-dev-server --open" 现在，我们在命令行中运行$ npm start，就会看到浏览器自动加载页面。如果现在修改和保存任意源文件，web 服务器就会自动重新加载编译后的代码。 总结webpack的学习时间跨度很长，webpack要学习的东西很多，继续加油吧～]]></content>
      <tags>
        <tag>webpack 学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack，一个广泛应用的模块打包器（一）——概念篇]]></title>
    <url>%2F2017%2F11%2F03%2Fwebpack%2F</url>
    <content type="text"><![CDATA[鉴于我在学习的过程使用webpack的频率较高，所以想着要记录一下webpack的一些核心的知识点，此博文涉及的知识点可能不深，但涵盖了webpack的主要内容，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 概念篇核心概念webpack 是一个现代JavaScript应用程序的模块打包器。当webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的bundle - 通常只有一个，由浏览器加载。在开始之前，我们需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 入口(Entry)webpack创建应用程序所依赖的关系图时，图的起点就是我们的入口起点。入口起点告诉webpack从哪里开始，可以认为是app的第一个启动文件。 单入口语法，用法：entry: string|Array 123module.exports = &#123; entry: '.src/app.js' //将src目录下的app.js文件作为入口文件&#125; 对象语法，用法：entry: {[entryChunkName: string]: string|Array}对象语法常用于：多页面应用程序，如 1234567module.exports = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125; 表面上告诉我们，webpack需要创建3个依赖图，这些依赖图彼此之间完成分离，互相独立的。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。 出口(Output)将所有文件归拢后，我们需要告诉webpack如何处理这些归拢在一起的文件。123456789const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;&#125;; 多个入口起点：出口处应该使用占位符来确保每个文件具有唯一的名称。12345678910module.exports = &#123; entry: &#123; app: __dirname + '.src/app.js', search: __dirname + './src/search.js' &#125;, output: &#123; path: __dirname + '/dist', filename: 'bundle-[name].js' //dist目录下将生成"bundle-app.js"和"bundle-search.js"文件 &#125;&#125;; 我们通过output.filename和output.path属性，来告诉输出文件的名称以及路径。 Loaderwebpack把每个文件(.css, .html, .less, .scss, .jpg等)都作为模块处理，然而 webpack 自身只理解 JavaScript。loader 可以使你在 import 或”加载”模块时预处理文件。loader在文件被添加到依赖图中时，将文件转换为模块。 识别出应该被对应的loader进行转换的文件。(test属性) 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）。(use属性) 在使用前，我们需要提前安装相对应的loader，如：1$ cnpm install --save-dev vue-loader 1234567891011121314const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.vue$/,loader: 'vue-loader' &#125; //用来解析vue后缀的文件 ] &#125;&#125;; 在应用程序中，我们有三种使用loader的方法： 配置（推荐）：在webpack.config.js文件中指定loader。 内联：在每个 import 语句中显式指定 loader，如： 1import Styles from 'style-loader!css-loader?modules!./styles.css'; CLI：在 shell 命令中指定它们，如： 1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 插件(Plugins)由于loader仅在每个文件的基础上执行转换，而插件更常用于（但不限于）在打包模块的 “compilation” 和 “chunk” 生命周期执行操作和自定义功能。想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中，多数插件可以通过选项(option)自定义。插件目的在于解决loader无法实现的其他事。由于插件可以携带参数/选项，你必须在webpack配置中，向plugins属性传入 new 实例。1234567891011121314151617181920const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.vue$/,loader: 'vue-loader' &#125; //用来解析vue后缀的文件 ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; 模块(Modules)在模块化编程中，开发者将程序分解成离散功能块，并称之为模块，每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。对比Node.js模块，webpack模块能够以各种方式表达它们的依赖关系，如： ES2015 import语句 CommonJS require()语句 AMD define和require语句 css/sass/less 文件中的 @import 语句 样式(url(…))或 HTML 文件img标签中的图片链接 webpack 通过 loader 可以支持各种语言和预处理器编写模块。 模块解析resolver是一个库，用于帮助找到模块的绝对路径。使用enhanced-resolve，webpack 能够解析三种文件路径： 绝对路径1import "C:\\Users\\user\\file"; 由于我们已经取得了文件的绝对路径，因此不需要进一步在做解析。 相对路径1import "../src/file1"; 在这种情况下，使用import或require的资源文件所在的目录被认为是上下文目录，在import/require中给定的相对路径，会添加此上下文路径，以产生模块的绝对路径。 模块路径1import "module/lib/file"; 模块将在resolve.modules中指定的所有目录内搜索。 构建目标(Targets)因为服务器和浏览器代码都可以用JavaScript编写，所以webpack提供了多种构建目标。123module.exports = &#123; target: 'node' //webpack会编译为用于「类Node.js」环境&#125;; 多个Target：尽管webpack不支持向target传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：1234567891011121314151617181920const path = require('path');const serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;const clientConfig = &#123; target: 'web', // 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ]; 上面的例子将在你的dist文件夹下创建lib.js和lib.node.js文件。 模块热替换模块热替换功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 总结webpack概念篇就差不多结束啦，其中包含webpack中核心的几个概念以及各自的用法，接下来我将继续记录webpack管理资源的相关知识点，希望能对大家有所帮助～]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel，一个广泛使用的转码器]]></title>
    <url>%2F2017%2F11%2F01%2Fbabel%2F</url>
    <content type="text"><![CDATA[随着JavaScript的飞速发展，浏览器的发展速度却不能与之相匹配，为了能够在现有的浏览器上使用js新的语法和新的数据类型，这时我们便需要一个转码器。Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码。Babel能将最新标准的JavaScript代码向下编译成浏览器普遍支持的版本，实现了“源码到源码”编译。比如，Babel能将新的ES2015的箭头函数语法：1const area = n =&gt; n * n; 转译为123const area = function area(n)&#123; return n * n;&#125;; 因为在学习Vue等过程中涉及到Babel的一些知识点，所以想着大概了解一下Babel的主要内容以及基本用法，文章内容涉及不深，如果在理解和用法上有偏差的话，还请大家不吝赐教～ 前期准备初始化项目在习惯的工作目录下新建一个文件夹，我取名为babel-blog，使用命令行进入babel-blog的工作目录，执行1$ npm init // 初始化并创建package.json文件 可以看到在babel-blog项目的根目录下创建了名为package.json的文件。 安装Babel命令行工具安装babel的命令行工具的目的是为了在命令行中使用babel。babel命令行工具可以全局安装也可以本地安装，官方文档推荐本地安装，原因有2点： 本地安装不同的项目可以使用不同版本的babel，你也可以单独对某个项目的babel进行升级等操作 每个项目单独安装的意味着对计算机环境没有依赖，便于移植 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来我们在babel-blog项目中安装babel命令行工具1$ cnpm install --save-dev babel-cli 安装成功后，可以在package.json文件中看到名为babel-cli的依赖包 本地安装的babel是不能够在直接命令行中运行的，为了在命令行中运行babel，我们可以配置package.json文件下的script选项1"build": "babel src -d lib" 配置成功后，当我们在终端运行npm run build时就会在命令行执行babel src -d lib，这也意味着我们要创建一个名为src的文件夹（ps：如果现在执行的话，项目会报错，它会提示我们src不存在，因为我们除了安装了babel-cli其他都还没有做呢～） .babelrc配置文件Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下：1234&#123; "presets": [], "plugins": []&#125; presets字段设定转码规则，在这里我们需要在项目中安装ES2015的转码规则12# ES2015转码规则$ cnpm install --save-dev babel-preset-es2015 然后将安装的规则加入.babelrc文件中1234&#123; "presets": ["es2015"], "plugins": [] &#125; 接下来我们在项目根目录下创建名为src的文件夹，其中创建一个名为index.js文件，我们就拿最开始的area箭头函数来进行演示：123const area = n =&gt; n * n;console.log(area(4)); 接下来，你就可以在命令行执行npm run build命令了，执行成功后你可以发现，在根目录下生成了一个名为lib的文件夹，其中有一个index.js文件，内容就是src下index.js通过babel转码生成的代码 到这里我们就已经学会了使用babel来进行简单的转码功能。是不是觉得很简单呢～ Babel扩展Babel中有很多包，常用的包有babel-node, babel-register, babel-core, babel-polyfill等，这些在实际应用中用的频率都是很高的。 babel-nodebable-node是babel-cli自带的命令，提供了一个支持ES6的REPL环境，它支持node的REPL环境的所有功能，而且可以直接运行ES6代码。首先我们需要全局安装babel-cli。1$ cnpm install --save-dev -g babel-cli 安装成功后，输入babel-node,PEPL环境或者直接执行js文件1$ babel-node 文件路径/文件名.后缀 babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。1$ cnpm install --save-dev babel-register 为了方便，我直接在刚刚新建的babel-blog项目中src文件夹下新建一个register.js文件1console.log("Hello babel-register!"); 如果我们用 node register.js 来运行它是不会使用 Babel 来编译的。所以我们需要设置 babel-register，我们在项目的根目录下创建一个名为console.js的文件，并引入babel-register以及register.js文件12require("babel-register");require("./src/register"); 此时执行1$ node console.js 可以发现命令行输出了register.js文件中的内容 “Hello babel-register!”。这样做可以把 Babel 注册到 Node 的模块系统中并开始编译其中 require 的所有文件。 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。借用阮一峰老师的例子：(字符串转码)transform方法的第一个参数是一个字符串，表示需要转换的ES6代码，第二个参数是转换的配置对象。 babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，为了解决这个问题，必须要使用babel-polyfill，为当前环境提供一个垫片。 Babel与其他工具集成Babel可以与很多构建工具（如 Browserify、Grunt、Gulp、Webpack等）进行集成。关于babel与Webpack构建工具的集成，在我使用webpack搭建vue项目——入门博客中就有使用到。 集成Webpack babel-preset-env，转译器，最常用的转译器。通过在.babelrc中配置env选项，可以让代码兼容不同版本的浏览器或者node。 这里我将使用原先的babel-blog项目，并将lib文件夹，src文件夹下的文件删除仅保留开始的index.js文件，当前目录结构如下： 进入项目工作目录，安装webpack，babel-preset-env和babel-loader123$ cnpm install --save-dev webpack$ cnpm install --save-dev babel-preset-env$ cnpm install --save-dev babel-loader 安装成功后，可以在package.json文件中看到相应的依赖包。 接下来在根目录下创建webpack.config.js文件 entry为入口文件，我们选择当前目录下，src文件夹下的index.js文件作为入口。output为输出选项，path为输出的目录，filename为输出文件名。感兴趣的朋友们可以戳戳Webpack中文文档进行学习哦～ 最重要的一点：我们要记得在.babelrc文件中设定相应的转码规则哦 在命令行执行1$ webpack 运行成功后，可以发现在根目录下创建了名为public文件夹，以及名为index.output.js输出文件 通过集成webpack构建工具，可以将转码后的文件打包。 总结写这篇博文的逻辑性可能不是很强，主要是边学习边记录，把Babel主要的知识点记录下来，作为Babel的一篇学习笔记，以便后续的深入学习，这里推荐一下阮一峰老师的 Babel入门推荐教程，这篇博文里面很多知识点都来自阮一峰老师的推荐课程～ 希望能对大家有所帮助～]]></content>
      <tags>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用iconfont创建项目图标]]></title>
    <url>%2F2017%2F10%2F31%2Ficonfont%2F</url>
    <content type="text"><![CDATA[在学习他人网站代码时，我常常会发现前端开发人员习惯使用1&lt;i class="iconfont icon-time"&gt;&lt;/i&gt; 来生成页面的图标，这打破了我们传统的方式——将icon图标以png等图片的形式下载下来，然后通过img标签引入页面中。在刚开始接触到这种方式时，我感到不解，想要试图在css文件中找到相应类的样式设置，认为是在css中设置了背景图，找寻无果…最近想要充实一下个人博客，也就想着要把这次学习的心路历程记录下来，以供后续的深入学习。初次学习可能有些地方讲解的不是很细致，还请各位不吝赐教～ 使用Iconfont的优点Iconfont其实就是指用字体文件取代图片文件，来展示图标、特殊字体等元素的一种方法。主要有以下4个优点 加载文件体积小，提高加载速度 可以直接通过css的font-size，color修改它的大小和颜色，可以缩放多个尺寸的图标，提高图标的可复用性 支持一些css3对文字的效果，例如：阴影、旋转、透明度等 兼容低版本浏览器相对于我们传统的将icon下载为图片的形式，使用iconfont确实方便不少。当我们项目要修改主色调时，iconfont只需要修改css中颜色属性即可，而传统模式则需要你重新下载，这样不仅增加了我们的开发时间，而且会让前端开发工作变得枯燥无味。 Iconfont使用流程在这里我们需要使用到第三方Iconfont在线服务（例如： 阿里巴巴Iconfont平台 ），个人比较偏向于阿里巴巴Iconfont平台，而在此文中也是在阿里巴巴Iconfont平台上进行操作的。 首先，我们打开阿里巴巴Iconfont平台（ps:使用阿里巴巴Iconfont平台需要你有github账号或者微博账号） 接下来，我们搜索我们想要的图标，建议使用英文搜索，匹配的icon可能更多哦～ 回车以后，你会看到很多有关于time的icon图标，选择你需要的那个，并添加至购物车中（如未登录的话，此时会要求你先登录）加入成功后你可以在右上角购物车处看到你所添加的icon 依此，你可以在项目中添加很多icon图标，这里就不一一演示了 接下来，我们将购物车中所有的icon图标打包在一个新建的项目中添加成功后，你可以看到你创建的项目中有你所添加的所有icon图标点击下载至本地，将zip文件解压后其中的文件如下 接下来，就是如何在项目中使用了在原来的html中我使用的是传统方式，将icon以图片的形式引入可以看到的效果如下将刚刚解压的文件放置在项目的根目录下，可以对文件进行重命名，为了方便我重命名为icon-fonts，当前项目目录如下 接下来我们在头部引入icon-fonts中的iconfont.css文件并使用i标签来替换传统方式 其中iconfont是必须的类名，icon-time是你在阿里巴巴Iconfont平台创建的项目中图标所对应的类名，如下图img是我自己创建的用来定位的css类你会发现icon已经成功的被我们引入了，并且替换了传统的img标签 你可以在css中任意设置icon图标的大小以及颜色，如下： 总结写到这里，也差不多结束了，在这篇文章里我简单介绍了iconfont在项目中的使用，在实际运用中，你可以把项目中所需要的图标都以这种方式引入，这样在用户要求更换icon主色调时，就仅需要统一修改icon图标的颜色即可，而不需要重新下载icon图片，这样也就在一定程度上减少了项目的开发时间，提高了项目的开发质量，更重要的是前端开发人员不会因为重复无用功儿感觉枯燥无味。 这些只是一些小小的应用，希望能对大家有所帮助～]]></content>
      <tags>
        <tag>iconfont 项目图标icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webpack搭建vue项目——入门]]></title>
    <url>%2F2017%2F10%2F25%2Fwebpack-vue%2F</url>
    <content type="text"><![CDATA[vue以数据为驱动，是近年来比较火的一个轻量级的前后端分离的框架，前段时间学习了vue的一些基本知识，明白了vue中指令等的使用，个人觉得较难的一部分当属于使用vue进行组件化开发，在vue.js专业中文开发者社区上有不少大牛们使用vue重构的一些例子，比如豆瓣，饿了么等，大家可以clone下来自己重构一下，建议初学者在豆瓣和饿了么两个中先选择豆瓣的例子，豆瓣的例子会相对简单直观一些。我在刚学习使用vue进行组件化开发时，常常会使用 1$ vue init webpack project-name 来初始化一个vue项目，接着在这个初始化完成的项目中进行vue的组件化开发。我们可能明白每一个配置文件以及文件夹中的相关内容，但使用webpack构建vue项目的过程又是怎样的？这就不得而知了。随着后来的学习，我开始自己慢慢使用webpack从零构建vue项目，踩了很多坑，可能也不是很深入，但是总想着能把这次过程写下来，以便后续的深入学习，初次学习可能理解以及步骤上会有偏差，还请各位不吝赐教～ webpack构建vue项目流程安装 首先需要你已下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装在你习惯使用的工作目录下新建文件夹，在这里我新建了一个名为webpack-vue-blog的文件夹（ps:项目名称中不可以含有空格，这在初始化时会报错的～大家注意一下，建议使用-或_代替），打开你的终端，进入到webpack-vue-blog的工作目录，使用1$ npm init //初始化并自动创建package.json文件，npm是node.js的命令 接下来是一些项目的相关信息，一路按enter键就可以了，之后你可以在package.json文件中看到项目的相关信息 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来就要安装vue webpack等相关的模块，在这里先大致介绍一下相关的命令 使用npm安装插件：命令提示符执行npm(cnpm) install [-g] [–save-dev] -g：全局安装 –save：将保存配置信息至package.json（package.json是nodejs项目配置文件） -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点 12345678910//安装vue$ cnpm install --save vue //安装webpack以及webpack测试服务器，默认安装是1.0版本的，所以必须指定版本号$ cnpm install --save-dev webpack@^2.1.0-beta.25 webpack-dev-server@^2.1.0-beta.9 //安装babel，一般的浏览器是不认识es6语法的，babel的作用是将ES6代码转为ES5代码，从而编译成浏览器认识的语法$ cnpm install --save-dev babel-core babel-loader babel-preset-es2015//用来解析vue的组件，.vue后缀的文件$ cnpm install --save-dev vue-loader vue-template-compiler//用来解析css$ cnpm install --save-dev css-loader file-loader 需要用到的模块我们已经安装完之后，就可以开始在package.json看到我们所安装的依赖包，在webpack-vue-blog目录下也会生成名为node_modules的文件夹 编码安装了这么多的依赖包，终于要进入编码的阶段了，打开你的编辑器，这里我使用的是VS Code工具进行编码，这个工具比较小，但是要安装相关的插件，我这里不详细介绍了哈，感兴趣的萌友们可以安装使用一下。现在我们的webpack-vue-blog工程目录下只有node_modules文件夹以及package.json文件接下来我们在根目录下新建src文件夹用来存放我们项目的源码，在src目录下新建App.vue以及main.js文件，其中App.vue是我们的入口页面，main.js是应用初始化入口文件1234567891011121314151617181920//App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 'This is your first webpack-vue project!' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789//main.jsimport Vue from 'vue'import App from './App.vue' // 将同目录下的App.vue导入/* 实例化一个vue */new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) render函数是渲染一个视图，然后提供给el挂载，如果没有render那页面什么都不会出来 Vue2.0的渲染过程： Vue实例选项对象的 render 方法作为一个函数，接受传入的参数 h 函数，返回 h(App) 的函数调用结果 Vue 在创建 Vue 实例时，通过调用 render 方法来渲染实例的 DOM 树 Vue 在调用 render 方法时，会传入一个 createElement 函数作为参数，也就是这里的 h 的实参是 createElement 函数，然后 createElement 会以 APP 为参数进行调用 [官方文档]:123456render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name 标签名称 this.$slots.default // 子组件中的阵列 )&#125; 接下来我们将进入webpack部分 戳进来学习webpack中文文档，在根目录下新建名为webpack.config.js的文件，用来进行相关的配置 webpack入口出口等核心概念中文文档 123456789101112131415161718192021222324252627282930313233//webpack.config.jsvar path = require('path');var webpack = require('webpack');module.exports = &#123; /* 入口文件 */ entry: './src/main.js', /* 输出 */ output: &#123; /* 输出目录，没有则新建 通过__dirname获得当前文件所在目录的完整目录名：*/ path: path.resolve(__dirname, './dist'), /* 静态目录，可以直接从这里取文件 */ publicPath: '/dist/', /* 文件名 */ filename: 'build.js' &#125;, module: &#123; rules: [ /* 用来解析vue后缀的文件 */ &#123; test: /\.vue$/, loader: 'vue-loader' &#125;, /* 用babel来解析js文件并把es6的语法转换成浏览器认识的语法 */ &#123; test: /\.js$/, loader: 'babel-loader', /* 排除模块安装目录的文件 */ exclude: /node_modules/ &#125; ] &#125;&#125; 我们当前的项目目录为：接下来我们将进行webpack的核心功能——模块打包1$ cnpm install -g webpack@^2.1.0-beta.25 //全局安装webpack，以便使用webpack命令进行打包等 进入webpack-vue-blog目录下并运行命令1$ webpack 执行完毕后你可以发现在根目录下新增了一个名为dist的文件夹，其中有个build.js文件，而这输出的文件夹名及文件名正是我们在webpack.config.js中配置好的。这么久还不能看效果，急死人了，不要着急，已经快要接近尾声啦！！接下来，我们在根目录下新建名为index.html的文件，并引入我们刚刚生成的build.js文件12345678910111213//index.html&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0"&gt; &lt;title&gt;webpack-vue-blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./dist/build.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接下来运行命令1$ webpack-dev-server 稍微等待一会，就会提示你已经运行成功啦，并且可以通过访问localhost:8080来访问我们的第一个使用webpack构建的vue项目。这样我们的使用webpack构建的vue项目也算是搭建完成了。 结语这是自搭建个人博客网站以来着手写的第一篇博客，当然，这只是一个很简单的项目，在后续深入学习中，你会发现程序员们会将babel的相关配置保存在.babelrc配置文件中，比如：相信大家在学习babel相关教程时会了解到 Babel入门推荐教程 希望能对萌友们有所帮助～]]></content>
      <tags>
        <tag>webpack vue</tag>
      </tags>
  </entry>
</search>
