{"meta":{"title":"邱邱邱邱的个人博客","subtitle":null,"description":null,"author":"萌萌哒的邱邱邱邱","url":"https://qiuruolin.github.io"},"pages":[],"posts":[{"title":"webpack，一个广泛应用的模块打包器（二）——资源管理模块","slug":"webpack-guide","date":"2017-11-19T16:07:24.000Z","updated":"2018-01-16T05:18:25.000Z","comments":true,"path":"2017/11/20/webpack-guide/","link":"","permalink":"https://qiuruolin.github.io/2017/11/20/webpack-guide/","excerpt":"继上一篇博文webpack，一个广泛应用的模块打包器（一）——概念篇完成之后，时隔一段时间没有学习webpack了，主要是最近有点小忙耽搁了。此篇博文主要是作为webpack的学习指南，理解和掌握webpack提供的各种工具和特性，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 安装首先需要你下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装，在使用webpack的过程中我们需要大量的使用node中的npm包管理工具，npm主要的使用场景有： 用户可以在npm服务器上下载别人编写的第三方包到本地使用; 用户可以在npm服务器上下载并安装别人编写的命令行程序到本地使用; 还可以将自己编写的包或命令行程序上传到npm服务器供他人使用。","text":"继上一篇博文webpack，一个广泛应用的模块打包器（一）——概念篇完成之后，时隔一段时间没有学习webpack了，主要是最近有点小忙耽搁了。此篇博文主要是作为webpack的学习指南，理解和掌握webpack提供的各种工具和特性，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 安装首先需要你下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装，在使用webpack的过程中我们需要大量的使用node中的npm包管理工具，npm主要的使用场景有： 用户可以在npm服务器上下载别人编写的第三方包到本地使用; 用户可以在npm服务器上下载并安装别人编写的命令行程序到本地使用; 还可以将自己编写的包或命令行程序上传到npm服务器供他人使用。 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 全局安装1npm install --global webpack 全局安装将使webpack在全局环境下可用，但不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。 本地安装1npm install --save-dev webpack 对于大多数项目，我们建议本地安装。这可以使我们在引入破坏式变更的依赖时，更容易分别升级项目。通常，webpack 通过运行一个或多个 npm scripts，会在本地 node_modules 目录中查找安装的 webpack。 起步为了后续更好的进行知识点的演示，我们先进行简单的项目准备。我在常用的工作目录下新建了一个名为webpack-blog的文件夹。命令行进入webpack-blog的工作目录执行1234//初始化并创建package.json文件$ npm init //在项目中安装webpack依赖包$ cnpm install --save-dev webpack 在根目录下创建名为webpack.config.js的文件以及我们的入口文件/src/main.js文件，webpack.config.js是我们这次主要的文件，是webpack的配置文件。构建好工作目录后，我们来根据上一节简述过的webpack核心知识来简单使用一下webpack。首先，我们在src目录下的main.js文件中编写简单的js代码：1console.log(\"Welcome to your first webpack test!\"); 接着，我们来到webpack.config.js文件，并设置webpack打包所需的入口起点以及输出文件配置：12345678910var path = require('path');var webpack = require('webpack');module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;&#125; 简单介绍一下上述代码，entry是模块打包的入口起点，它指示webpack根据src目录下的main.js文件来构建工程的依赖图；require()是node.js中常用的一个导入模块的操作，path.resolve()是获取绝对路径的方法，__dirname 用于获取当前文件所在目录的完整目录名。此代码用于查找dist文件夹，如果目录下没有dist文件夹则新建，并将通过打包创建后的webpack.bundle.js文件放入dist文件夹中。 接着，我们执行1$ webpack 命令，对工程进行打包构建，执行成功后，我们可以在根目录下看到新建的dist文件夹下有一个新建的webpack.bundle.js文件，有点绕～ 最后，我们在src目录下新建一个名为index.html的文件，并以script标签的形式引入生成的webpack.bundle.js文件，在浏览器中打开index.html，你会发现页面上空空如也，什么都没有～别着急，打开浏览器的控制台，你可以看到在控制台中输出了“Welcome to your first webpack test!”，我们对webpack的第一次简单应用就成功啦。 当然这只是一个超简单的例子，接下来我们将对这个例子进行扩充，进而展示webpack强大的功能。 管理资源加载CSS为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：1$ cnpm install --save-dev style-loader css-loader 安装成功后可以在package.json文件中的devDependencies项中看到新安装的style-loader和css-loader模块。接着，我们在webpack.config.js文件中配置模块的使用规则：12345678module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ]&#125; 简单介绍以上代码，test用于识别出应该被对应的loader进行转换的文件，以上代码表示loader需要识别.css为后缀的文件，use属性转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）。 下一步，我们尝试一下在项目src目录下添加style.css文件，并将其导入我们的入口文件main.js中我们修改main,js文件中的内容，以便于在页面中更直观地看到效果。1234var element = document.createElement('div');element.setAttribute(\"class\", \"hello\");element.innerHTML = \"Welcome to your first webpack test!\";document.body.appendChild(element); 此时经过$ webpack命令打包后，在浏览器打开index.html文件可以看到，页面结构为页面效果为： 接下来我们在创建的style.css文件中写入简单的样式来验证webpack加载CSS的功能123.hello&#123; color: red;&#125; 在main.js文件中引入style.css文件1import './style.css'; 再次使用$ webpack命令打包后，我们在浏览器中打开index.html文件，我们可以看到Welcome to your first webpack test!输出为红色。 查看页面的head标签，可以发现页面已经包含了我们在main.js文件中导入的style.css文件。 加载图片使用 file-loader，我们可以轻松地将页面中需要的背景图片或者图标混合到 CSS 中，首先还是要安装模块依赖包：1$ cnpm install --save-dev file-loader 同样的，我们需要在webpack.config.js文件中配置应用规则： 此段规则表明程序可以加载以.png .svg .jpg .gif为后缀名的文件。我们可以直接在style.css文件中添加background样式来引入图片，为了让背景图片完整地显示出来，我们为hello这个div设置了300px的高度12345.hello&#123; height: 300px; color: red; background: url('./logo.png');&#125; 重新执行$ webpack命令，我们可以看到页面效果为： 图片稀缺，就拿了一张之前工程中现有的vue框架的logo来用～如果你检查img元素，你将看到实际的文件名已更改为像 82b9c7a5a3f405032b1db71a25f67021.png 一样。这意味着 webpack 在 src 文件夹中找到我们的文件，并成功处理过它了！ 加载字体 加载字体与加载图片相同，也使用的是file-loader来加载字体文件，加载字体使用的正则规则如：1test: /\\.(woff|woff2|eot|ttf|otf)$/ 与加载图片文件相同，加载字体需要在css文件中引入字体文件，可以通过一个 @font-face 声明引入。用法如下： 加载数据在我们实际运用中，不仅仅要加载图片及字体文件，还可能需要加载有用的资源还有数据，如 JSON 文件，CSV、TSV 和 XML。JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。而要导入 CSV、TSV 和 XML类型的数据，就需要我们安装csv-loader和xml-loader模块来进行加载数据。首先，我们还是需要在项目中安装相关模块：1$ cnpm install --save-dev csv-loader xml-loader 接着，我们同样需要在webpack.config.js文件中配置相关的应用规则，规则如下：12345678 &#123; test: /\\.(csv|tsv)$/, use: ['csv-loader']&#125;,&#123; test: /\\.xml$/, use: ['xml-loader']&#125; 接下来，我们在src目录下添加名为data.xml的数据文件，data.xml内容如下： 我们在main.js文件中解析data.xml文件中的数据，主要增加以下两行代码：12import Data from './data.xml';console.log(Data); 再次执行$ webpack命令后，再次在浏览器上打开index.html文件，我们可以在控制台输出了data.xml文件解析后的数据： 开发Source Map当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。这并通常没有太多帮助，因为你可能需要准确地知道错误来自于哪个源文件。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。我们只需要在webpack.config.js文件中写入以下代码：1devtool: 'inline-source-map' 就可以追踪源文件中错误和警告的功能。 使用观察模式根据此博文一步一步构建下来的萌友会发现，每次修改源文件后，都要重新使用$ webpack命令对文件重新进行打包构建，这在一定程度上增加了我们的重复工作。使用观察模式，你可以指示 webpack “watch” 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。你需要在package.json文件中引入执行命令： 接着，你可以在命令行中执行1$ npm run watch 执行成功后，你会看到 webpack 编译代码，然而却不会退出命令行。这是因为 script 脚本还在观察文件，此时修改main.js文件的内容，你会发现不需要重新手动构建程序，代码已经被重新编译了。 使用webpack-dev-serverwebpack-dev-server 提供了一个简单的 web 服务器，能够实时重新加载。首先，我们需要下载安装模块1$ cnpm install --save-dev webpack-dev-server 安装成功后，我们需要在webpack.config.js文件中告诉开发服务器，去哪里加载文件123devServer: &#123; contentBase: './dist'&#125; 以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。 接着，让我们在package.json文件中添加一个 script 脚本，可以直接运行开发服务器： 1\"start\": \"webpack-dev-server --open\" 现在，我们在命令行中运行$ npm start，就会看到浏览器自动加载页面。如果现在修改和保存任意源文件，web 服务器就会自动重新加载编译后的代码。 总结webpack的学习时间跨度很长，webpack要学习的东西很多，继续加油吧～","categories":[],"tags":[{"name":"webpack 学习指南","slug":"webpack-学习指南","permalink":"https://qiuruolin.github.io/tags/webpack-学习指南/"}]},{"title":"webpack，一个广泛应用的模块打包器（一）——概念篇","slug":"webpack","date":"2017-11-03T13:12:38.000Z","updated":"2018-01-16T05:17:28.000Z","comments":true,"path":"2017/11/03/webpack/","link":"","permalink":"https://qiuruolin.github.io/2017/11/03/webpack/","excerpt":"鉴于我在学习的过程使用webpack的频率较高，所以想着要记录一下webpack的一些核心的知识点，此博文涉及的知识点可能不深，但涵盖了webpack的主要内容，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 概念篇核心概念webpack 是一个现代JavaScript应用程序的模块打包器。当webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的bundle - 通常只有一个，由浏览器加载。在开始之前，我们需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。","text":"鉴于我在学习的过程使用webpack的频率较高，所以想着要记录一下webpack的一些核心的知识点，此博文涉及的知识点可能不深，但涵盖了webpack的主要内容，主要目的是想将此次的学习过程记录下来，以便进行后续的深入学习，如果在理解上有偏差的话，还请大家不吝赐教～ 概念篇核心概念webpack 是一个现代JavaScript应用程序的模块打包器。当webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的bundle - 通常只有一个，由浏览器加载。在开始之前，我们需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 入口(Entry)webpack创建应用程序所依赖的关系图时，图的起点就是我们的入口起点。入口起点告诉webpack从哪里开始，可以认为是app的第一个启动文件。 单入口语法，用法：entry: string|Array 123module.exports = &#123; entry: '.src/app.js' //将src目录下的app.js文件作为入口文件&#125; 对象语法，用法：entry: {[entryChunkName: string]: string|Array}对象语法常用于：多页面应用程序，如 1234567module.exports = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125; 表面上告诉我们，webpack需要创建3个依赖图，这些依赖图彼此之间完成分离，互相独立的。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。 出口(Output)将所有文件归拢后，我们需要告诉webpack如何处理这些归拢在一起的文件。123456789const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;&#125;; 多个入口起点：出口处应该使用占位符来确保每个文件具有唯一的名称。12345678910module.exports = &#123; entry: &#123; app: __dirname + '.src/app.js', search: __dirname + './src/search.js' &#125;, output: &#123; path: __dirname + '/dist', filename: 'bundle-[name].js' //dist目录下将生成\"bundle-app.js\"和\"bundle-search.js\"文件 &#125;&#125;; 我们通过output.filename和output.path属性，来告诉输出文件的名称以及路径。 Loaderwebpack把每个文件(.css, .html, .less, .scss, .jpg等)都作为模块处理，然而 webpack 自身只理解 JavaScript。loader 可以使你在 import 或”加载”模块时预处理文件。loader在文件被添加到依赖图中时，将文件转换为模块。 识别出应该被对应的loader进行转换的文件。(test属性) 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）。(use属性) 在使用前，我们需要提前安装相对应的loader，如：1$ cnpm install --save-dev vue-loader 1234567891011121314const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/,loader: 'vue-loader' &#125; //用来解析vue后缀的文件 ] &#125;&#125;; 在应用程序中，我们有三种使用loader的方法： 配置（推荐）：在webpack.config.js文件中指定loader。 内联：在每个 import 语句中显式指定 loader，如： 1import Styles from 'style-loader!css-loader?modules!./styles.css'; CLI：在 shell 命令中指定它们，如： 1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 插件(Plugins)由于loader仅在每个文件的基础上执行转换，而插件更常用于（但不限于）在打包模块的 “compilation” 和 “chunk” 生命周期执行操作和自定义功能。想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中，多数插件可以通过选项(option)自定义。插件目的在于解决loader无法实现的其他事。由于插件可以携带参数/选项，你必须在webpack配置中，向plugins属性传入 new 实例。1234567891011121314151617181920const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path'); //引入path对象module.exports = &#123; entry: '.src/app.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/,loader: 'vue-loader' &#125; //用来解析vue后缀的文件 ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;; 模块(Modules)在模块化编程中，开发者将程序分解成离散功能块，并称之为模块，每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。对比Node.js模块，webpack模块能够以各种方式表达它们的依赖关系，如： ES2015 import语句 CommonJS require()语句 AMD define和require语句 css/sass/less 文件中的 @import 语句 样式(url(…))或 HTML 文件img标签中的图片链接 webpack 通过 loader 可以支持各种语言和预处理器编写模块。 模块解析resolver是一个库，用于帮助找到模块的绝对路径。使用enhanced-resolve，webpack 能够解析三种文件路径： 绝对路径1import \"C:\\\\Users\\\\user\\\\file\"; 由于我们已经取得了文件的绝对路径，因此不需要进一步在做解析。 相对路径1import \"../src/file1\"; 在这种情况下，使用import或require的资源文件所在的目录被认为是上下文目录，在import/require中给定的相对路径，会添加此上下文路径，以产生模块的绝对路径。 模块路径1import \"module/lib/file\"; 模块将在resolve.modules中指定的所有目录内搜索。 构建目标(Targets)因为服务器和浏览器代码都可以用JavaScript编写，所以webpack提供了多种构建目标。123module.exports = &#123; target: 'node' //webpack会编译为用于「类Node.js」环境&#125;; 多个Target：尽管webpack不支持向target传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：1234567891011121314151617181920const path = require('path');const serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;const clientConfig = &#123; target: 'web', // 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ]; 上面的例子将在你的dist文件夹下创建lib.js和lib.node.js文件。 模块热替换模块热替换功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 总结webpack概念篇就差不多结束啦，其中包含webpack中核心的几个概念以及各自的用法，接下来我将继续记录webpack管理资源的相关知识点，希望能对大家有所帮助～","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://qiuruolin.github.io/tags/webpack/"}]},{"title":"babel，一个广泛使用的转码器","slug":"babel","date":"2017-11-01T15:57:24.000Z","updated":"2017-11-02T08:30:10.000Z","comments":true,"path":"2017/11/01/babel/","link":"","permalink":"https://qiuruolin.github.io/2017/11/01/babel/","excerpt":"随着JavaScript的飞速发展，浏览器的发展速度却不能与之相匹配，为了能够在现有的浏览器上使用js新的语法和新的数据类型，这时我们便需要一个转码器。Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码。Babel能将最新标准的JavaScript代码向下编译成浏览器普遍支持的版本，实现了“源码到源码”编译。比如，Babel能将新的ES2015的箭头函数语法：1const area = n =&gt; n * n; 转译为123const area = function area(n)&#123; return n * n;&#125;; 因为在学习Vue等过程中涉及到Babel的一些知识点，所以想着大概了解一下Babel的主要内容以及基本用法，文章内容涉及不深，如果在理解和用法上有偏差的话，还请大家不吝赐教～","text":"随着JavaScript的飞速发展，浏览器的发展速度却不能与之相匹配，为了能够在现有的浏览器上使用js新的语法和新的数据类型，这时我们便需要一个转码器。Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码。Babel能将最新标准的JavaScript代码向下编译成浏览器普遍支持的版本，实现了“源码到源码”编译。比如，Babel能将新的ES2015的箭头函数语法：1const area = n =&gt; n * n; 转译为123const area = function area(n)&#123; return n * n;&#125;; 因为在学习Vue等过程中涉及到Babel的一些知识点，所以想着大概了解一下Babel的主要内容以及基本用法，文章内容涉及不深，如果在理解和用法上有偏差的话，还请大家不吝赐教～ 前期准备初始化项目在习惯的工作目录下新建一个文件夹，我取名为babel-blog，使用命令行进入babel-blog的工作目录，执行1$ npm init // 初始化并创建package.json文件 可以看到在babel-blog项目的根目录下创建了名为package.json的文件。 安装Babel命令行工具安装babel的命令行工具的目的是为了在命令行中使用babel。babel命令行工具可以全局安装也可以本地安装，官方文档推荐本地安装，原因有2点： 本地安装不同的项目可以使用不同版本的babel，你也可以单独对某个项目的babel进行升级等操作 每个项目单独安装的意味着对计算机环境没有依赖，便于移植 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来我们在babel-blog项目中安装babel命令行工具1$ cnpm install --save-dev babel-cli 安装成功后，可以在package.json文件中看到名为babel-cli的依赖包 本地安装的babel是不能够在直接命令行中运行的，为了在命令行中运行babel，我们可以配置package.json文件下的script选项1\"build\": \"babel src -d lib\" 配置成功后，当我们在终端运行npm run build时就会在命令行执行babel src -d lib，这也意味着我们要创建一个名为src的文件夹（ps：如果现在执行的话，项目会报错，它会提示我们src不存在，因为我们除了安装了babel-cli其他都还没有做呢～） .babelrc配置文件Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。该文件用来设置转码规则和插件，基本格式如下：1234&#123; \"presets\": [], \"plugins\": []&#125; presets字段设定转码规则，在这里我们需要在项目中安装ES2015的转码规则12# ES2015转码规则$ cnpm install --save-dev babel-preset-es2015 然后将安装的规则加入.babelrc文件中1234&#123; \"presets\": [\"es2015\"], \"plugins\": [] &#125; 接下来我们在项目根目录下创建名为src的文件夹，其中创建一个名为index.js文件，我们就拿最开始的area箭头函数来进行演示：123const area = n =&gt; n * n;console.log(area(4)); 接下来，你就可以在命令行执行npm run build命令了，执行成功后你可以发现，在根目录下生成了一个名为lib的文件夹，其中有一个index.js文件，内容就是src下index.js通过babel转码生成的代码 到这里我们就已经学会了使用babel来进行简单的转码功能。是不是觉得很简单呢～ Babel扩展Babel中有很多包，常用的包有babel-node, babel-register, babel-core, babel-polyfill等，这些在实际应用中用的频率都是很高的。 babel-nodebable-node是babel-cli自带的命令，提供了一个支持ES6的REPL环境，它支持node的REPL环境的所有功能，而且可以直接运行ES6代码。首先我们需要全局安装babel-cli。1$ cnpm install --save-dev -g babel-cli 安装成功后，输入babel-node,PEPL环境或者直接执行js文件1$ babel-node 文件路径/文件名.后缀 babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码。1$ cnpm install --save-dev babel-register 为了方便，我直接在刚刚新建的babel-blog项目中src文件夹下新建一个register.js文件1console.log(\"Hello babel-register!\"); 如果我们用 node register.js 来运行它是不会使用 Babel 来编译的。所以我们需要设置 babel-register，我们在项目的根目录下创建一个名为console.js的文件，并引入babel-register以及register.js文件12require(\"babel-register\");require(\"./src/register\"); 此时执行1$ node console.js 可以发现命令行输出了register.js文件中的内容 “Hello babel-register!”。这样做可以把 Babel 注册到 Node 的模块系统中并开始编译其中 require 的所有文件。 babel-core如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块。借用阮一峰老师的例子：(字符串转码)transform方法的第一个参数是一个字符串，表示需要转换的ES6代码，第二个参数是转换的配置对象。 babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，为了解决这个问题，必须要使用babel-polyfill，为当前环境提供一个垫片。 Babel与其他工具集成Babel可以与很多构建工具（如 Browserify、Grunt、Gulp、Webpack等）进行集成。关于babel与Webpack构建工具的集成，在我使用webpack搭建vue项目——入门博客中就有使用到。 集成Webpack babel-preset-env，转译器，最常用的转译器。通过在.babelrc中配置env选项，可以让代码兼容不同版本的浏览器或者node。 这里我将使用原先的babel-blog项目，并将lib文件夹，src文件夹下的文件删除仅保留开始的index.js文件，当前目录结构如下： 进入项目工作目录，安装webpack，babel-preset-env和babel-loader123$ cnpm install --save-dev webpack$ cnpm install --save-dev babel-preset-env$ cnpm install --save-dev babel-loader 安装成功后，可以在package.json文件中看到相应的依赖包。 接下来在根目录下创建webpack.config.js文件 entry为入口文件，我们选择当前目录下，src文件夹下的index.js文件作为入口。output为输出选项，path为输出的目录，filename为输出文件名。感兴趣的朋友们可以戳戳Webpack中文文档进行学习哦～ 最重要的一点：我们要记得在.babelrc文件中设定相应的转码规则哦 在命令行执行1$ webpack 运行成功后，可以发现在根目录下创建了名为public文件夹，以及名为index.output.js输出文件 通过集成webpack构建工具，可以将转码后的文件打包。 总结写这篇博文的逻辑性可能不是很强，主要是边学习边记录，把Babel主要的知识点记录下来，作为Babel的一篇学习笔记，以便后续的深入学习，这里推荐一下阮一峰老师的 Babel入门推荐教程，这篇博文里面很多知识点都来自阮一峰老师的推荐课程～ 希望能对大家有所帮助～","categories":[],"tags":[{"name":"babel","slug":"babel","permalink":"https://qiuruolin.github.io/tags/babel/"}]},{"title":"使用iconfont创建项目图标","slug":"iconfont","date":"2017-10-30T16:06:39.000Z","updated":"2017-10-31T02:59:26.000Z","comments":true,"path":"2017/10/31/iconfont/","link":"","permalink":"https://qiuruolin.github.io/2017/10/31/iconfont/","excerpt":"在学习他人网站代码时，我常常会发现前端开发人员习惯使用1&lt;i class=\"iconfont icon-time\"&gt;&lt;/i&gt; 来生成页面的图标，这打破了我们传统的方式——将icon图标以png等图片的形式下载下来，然后通过img标签引入页面中。在刚开始接触到这种方式时，我感到不解，想要试图在css文件中找到相应类的样式设置，认为是在css中设置了背景图，找寻无果…最近想要充实一下个人博客，也就想着要把这次学习的心路历程记录下来，以供后续的深入学习。初次学习可能有些地方讲解的不是很细致，还请各位不吝赐教～ 使用Iconfont的优点Iconfont其实就是指用字体文件取代图片文件，来展示图标、特殊字体等元素的一种方法。主要有以下4个优点 加载文件体积小，提高加载速度","text":"在学习他人网站代码时，我常常会发现前端开发人员习惯使用1&lt;i class=\"iconfont icon-time\"&gt;&lt;/i&gt; 来生成页面的图标，这打破了我们传统的方式——将icon图标以png等图片的形式下载下来，然后通过img标签引入页面中。在刚开始接触到这种方式时，我感到不解，想要试图在css文件中找到相应类的样式设置，认为是在css中设置了背景图，找寻无果…最近想要充实一下个人博客，也就想着要把这次学习的心路历程记录下来，以供后续的深入学习。初次学习可能有些地方讲解的不是很细致，还请各位不吝赐教～ 使用Iconfont的优点Iconfont其实就是指用字体文件取代图片文件，来展示图标、特殊字体等元素的一种方法。主要有以下4个优点 加载文件体积小，提高加载速度 可以直接通过css的font-size，color修改它的大小和颜色，可以缩放多个尺寸的图标，提高图标的可复用性 支持一些css3对文字的效果，例如：阴影、旋转、透明度等 兼容低版本浏览器相对于我们传统的将icon下载为图片的形式，使用iconfont确实方便不少。当我们项目要修改主色调时，iconfont只需要修改css中颜色属性即可，而传统模式则需要你重新下载，这样不仅增加了我们的开发时间，而且会让前端开发工作变得枯燥无味。 Iconfont使用流程在这里我们需要使用到第三方Iconfont在线服务（例如： 阿里巴巴Iconfont平台 ），个人比较偏向于阿里巴巴Iconfont平台，而在此文中也是在阿里巴巴Iconfont平台上进行操作的。 首先，我们打开阿里巴巴Iconfont平台（ps:使用阿里巴巴Iconfont平台需要你有github账号或者微博账号） 接下来，我们搜索我们想要的图标，建议使用英文搜索，匹配的icon可能更多哦～ 回车以后，你会看到很多有关于time的icon图标，选择你需要的那个，并添加至购物车中（如未登录的话，此时会要求你先登录）加入成功后你可以在右上角购物车处看到你所添加的icon 依此，你可以在项目中添加很多icon图标，这里就不一一演示了 接下来，我们将购物车中所有的icon图标打包在一个新建的项目中添加成功后，你可以看到你创建的项目中有你所添加的所有icon图标点击下载至本地，将zip文件解压后其中的文件如下 接下来，就是如何在项目中使用了在原来的html中我使用的是传统方式，将icon以图片的形式引入可以看到的效果如下将刚刚解压的文件放置在项目的根目录下，可以对文件进行重命名，为了方便我重命名为icon-fonts，当前项目目录如下 接下来我们在头部引入icon-fonts中的iconfont.css文件并使用i标签来替换传统方式 其中iconfont是必须的类名，icon-time是你在阿里巴巴Iconfont平台创建的项目中图标所对应的类名，如下图img是我自己创建的用来定位的css类你会发现icon已经成功的被我们引入了，并且替换了传统的img标签 你可以在css中任意设置icon图标的大小以及颜色，如下： 总结写到这里，也差不多结束了，在这篇文章里我简单介绍了iconfont在项目中的使用，在实际运用中，你可以把项目中所需要的图标都以这种方式引入，这样在用户要求更换icon主色调时，就仅需要统一修改icon图标的颜色即可，而不需要重新下载icon图片，这样也就在一定程度上减少了项目的开发时间，提高了项目的开发质量，更重要的是前端开发人员不会因为重复无用功儿感觉枯燥无味。 这些只是一些小小的应用，希望能对大家有所帮助～","categories":[],"tags":[{"name":"iconfont 项目图标icon","slug":"iconfont-项目图标icon","permalink":"https://qiuruolin.github.io/tags/iconfont-项目图标icon/"}]},{"title":"使用webpack搭建vue项目——入门","slug":"webpack-vue","date":"2017-10-25T03:11:50.000Z","updated":"2017-10-28T03:22:52.000Z","comments":true,"path":"2017/10/25/webpack-vue/","link":"","permalink":"https://qiuruolin.github.io/2017/10/25/webpack-vue/","excerpt":"vue以数据为驱动，是近年来比较火的一个轻量级的前后端分离的框架，前段时间学习了vue的一些基本知识，明白了vue中指令等的使用，个人觉得较难的一部分当属于使用vue进行组件化开发，在vue.js专业中文开发者社区上有不少大牛们使用vue重构的一些例子，比如豆瓣，饿了么等，大家可以clone下来自己重构一下，建议初学者在豆瓣和饿了么两个中先选择豆瓣的例子，豆瓣的例子会相对简单直观一些。我在刚学习使用vue进行组件化开发时，常常会使用 1$ vue init webpack project-name 来初始化一个vue项目，接着在这个初始化完成的项目中进行vue的组件化开发。我们可能明白每一个配置文件以及文件夹中的相关内容，但使用webpack构建vue项目的过程又是怎样的？这就不得而知了。随着后来的学习，我开始自己慢慢使用webpack从零构建vue项目，踩了很多坑，可能也不是很深入，但是总想着能把这次过程写下来，以便后续的深入学习，初次学习可能理解以及步骤上会有偏差，还请各位不吝赐教～ webpack构建vue项目流程安装","text":"vue以数据为驱动，是近年来比较火的一个轻量级的前后端分离的框架，前段时间学习了vue的一些基本知识，明白了vue中指令等的使用，个人觉得较难的一部分当属于使用vue进行组件化开发，在vue.js专业中文开发者社区上有不少大牛们使用vue重构的一些例子，比如豆瓣，饿了么等，大家可以clone下来自己重构一下，建议初学者在豆瓣和饿了么两个中先选择豆瓣的例子，豆瓣的例子会相对简单直观一些。我在刚学习使用vue进行组件化开发时，常常会使用 1$ vue init webpack project-name 来初始化一个vue项目，接着在这个初始化完成的项目中进行vue的组件化开发。我们可能明白每一个配置文件以及文件夹中的相关内容，但使用webpack构建vue项目的过程又是怎样的？这就不得而知了。随着后来的学习，我开始自己慢慢使用webpack从零构建vue项目，踩了很多坑，可能也不是很深入，但是总想着能把这次过程写下来，以便后续的深入学习，初次学习可能理解以及步骤上会有偏差，还请各位不吝赐教～ webpack构建vue项目流程安装 首先需要你已下载安装node.js 还没有下载安装？戳这里进入Node.js中文网进行下载安装在你习惯使用的工作目录下新建文件夹，在这里我新建了一个名为webpack-vue-blog的文件夹（ps:项目名称中不可以含有空格，这在初始化时会报错的～大家注意一下，建议使用-或_代替），打开你的终端，进入到webpack-vue-blog的工作目录，使用1$ npm init //初始化并自动创建package.json文件，npm是node.js的命令 接下来是一些项目的相关信息，一路按enter键就可以了，之后你可以在package.json文件中看到项目的相关信息 这里建议大家可以下载安装一下cnpm淘宝npm镜像，因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，使用cnpm的话可以在一定程度上提高我们模块的下载安装速度1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 接下来就要安装vue webpack等相关的模块，在这里先大致介绍一下相关的命令 使用npm安装插件：命令提示符执行npm(cnpm) install [-g] [–save-dev] -g：全局安装 –save：将保存配置信息至package.json（package.json是nodejs项目配置文件） -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点 12345678910//安装vue$ cnpm install --save vue //安装webpack以及webpack测试服务器，默认安装是1.0版本的，所以必须指定版本号$ cnpm install --save-dev webpack@^2.1.0-beta.25 webpack-dev-server@^2.1.0-beta.9 //安装babel，一般的浏览器是不认识es6语法的，babel的作用是将ES6代码转为ES5代码，从而编译成浏览器认识的语法$ cnpm install --save-dev babel-core babel-loader babel-preset-es2015//用来解析vue的组件，.vue后缀的文件$ cnpm install --save-dev vue-loader vue-template-compiler//用来解析css$ cnpm install --save-dev css-loader file-loader 需要用到的模块我们已经安装完之后，就可以开始在package.json看到我们所安装的依赖包，在webpack-vue-blog目录下也会生成名为node_modules的文件夹 编码安装了这么多的依赖包，终于要进入编码的阶段了，打开你的编辑器，这里我使用的是VS Code工具进行编码，这个工具比较小，但是要安装相关的插件，我这里不详细介绍了哈，感兴趣的萌友们可以安装使用一下。现在我们的webpack-vue-blog工程目录下只有node_modules文件夹以及package.json文件接下来我们在根目录下新建src文件夹用来存放我们项目的源码，在src目录下新建App.vue以及main.js文件，其中App.vue是我们的入口页面，main.js是应用初始化入口文件1234567891011121314151617181920//App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 'This is your first webpack-vue project!' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789//main.jsimport Vue from 'vue'import App from './App.vue' // 将同目录下的App.vue导入/* 实例化一个vue */new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) render函数是渲染一个视图，然后提供给el挂载，如果没有render那页面什么都不会出来 Vue2.0的渲染过程： Vue实例选项对象的 render 方法作为一个函数，接受传入的参数 h 函数，返回 h(App) 的函数调用结果 Vue 在创建 Vue 实例时，通过调用 render 方法来渲染实例的 DOM 树 Vue 在调用 render 方法时，会传入一个 createElement 函数作为参数，也就是这里的 h 的实参是 createElement 函数，然后 createElement 会以 APP 为参数进行调用 [官方文档]:123456render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name 标签名称 this.$slots.default // 子组件中的阵列 )&#125; 接下来我们将进入webpack部分 戳进来学习webpack中文文档，在根目录下新建名为webpack.config.js的文件，用来进行相关的配置 webpack入口出口等核心概念中文文档 123456789101112131415161718192021222324252627282930313233//webpack.config.jsvar path = require('path');var webpack = require('webpack');module.exports = &#123; /* 入口文件 */ entry: './src/main.js', /* 输出 */ output: &#123; /* 输出目录，没有则新建 通过__dirname获得当前文件所在目录的完整目录名：*/ path: path.resolve(__dirname, './dist'), /* 静态目录，可以直接从这里取文件 */ publicPath: '/dist/', /* 文件名 */ filename: 'build.js' &#125;, module: &#123; rules: [ /* 用来解析vue后缀的文件 */ &#123; test: /\\.vue$/, loader: 'vue-loader' &#125;, /* 用babel来解析js文件并把es6的语法转换成浏览器认识的语法 */ &#123; test: /\\.js$/, loader: 'babel-loader', /* 排除模块安装目录的文件 */ exclude: /node_modules/ &#125; ] &#125;&#125; 我们当前的项目目录为：接下来我们将进行webpack的核心功能——模块打包1$ cnpm install -g webpack@^2.1.0-beta.25 //全局安装webpack，以便使用webpack命令进行打包等 进入webpack-vue-blog目录下并运行命令1$ webpack 执行完毕后你可以发现在根目录下新增了一个名为dist的文件夹，其中有个build.js文件，而这输出的文件夹名及文件名正是我们在webpack.config.js中配置好的。这么久还不能看效果，急死人了，不要着急，已经快要接近尾声啦！！接下来，我们在根目录下新建名为index.html的文件，并引入我们刚刚生成的build.js文件12345678910111213//index.html&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0\"&gt; &lt;title&gt;webpack-vue-blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./dist/build.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 接下来运行命令1$ webpack-dev-server 稍微等待一会，就会提示你已经运行成功啦，并且可以通过访问localhost:8080来访问我们的第一个使用webpack构建的vue项目。这样我们的使用webpack构建的vue项目也算是搭建完成了。 结语这是自搭建个人博客网站以来着手写的第一篇博客，当然，这只是一个很简单的项目，在后续深入学习中，你会发现程序员们会将babel的相关配置保存在.babelrc配置文件中，比如：相信大家在学习babel相关教程时会了解到 Babel入门推荐教程 希望能对萌友们有所帮助～","categories":[],"tags":[{"name":"webpack vue","slug":"webpack-vue","permalink":"https://qiuruolin.github.io/tags/webpack-vue/"}]}]}